<!DOCTYPE html>
<html lang="en">
<head>
<!--  2025-02-01 Sat 13:23  -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>‎</title>
<meta name="author" content="basti" />
<meta name="generator" content="Org Mode" />

<link type="text/css" rel="stylesheet" href="org_html_export.css" />
<script type="text/javascript">

document.addEventListener('DOMContentLoaded', function() {
    // Set the initial width for subfigures and their images
    document.querySelectorAll('figure.subfigure[data-width]').forEach(function(subfigure) {
        subfigure.style.width = subfigure.getAttribute('data-width');
    });

    document.querySelectorAll('figure.subfigure img[data-width]').forEach(function(img) {
        img.style.width = img.getAttribute('data-width');
    });

    // Event listener for images within subfigures
    document.querySelectorAll('figure.subfigure img[data-width]').forEach(function(img) {
        img.addEventListener('click', function() {
            // Determine the .figure-wrapper that contains the clicked image
            let wrapper = this.closest('.figure-wrapper');

            // If found, adjust the sizes of its subfigures
            if (wrapper) {
                let subfigures = wrapper.querySelectorAll('figure.subfigure');
                subfigures.forEach(subfigure => {
                    let width = parseFloat(subfigure.getAttribute('data-width'));
                    if (width < 50) { // Double size if less than 50%
                        subfigure.setAttribute('data-width', (width * 2) + '%');
                        subfigure.style.width = (width * 2) + '%';
                    } else { // Halve size otherwise
                        subfigure.setAttribute('data-width', (width / 2) + '%');
                        subfigure.style.width = (width / 2) + '%';
                    }
                });
            }
        });
    });
});

document.addEventListener('DOMContentLoaded', function () {
    var headers = document.querySelectorAll('h1 .extended, h2 .extended, h3 .extended, h4 .extended, h5 .extended, h6 .extended');

    headers.forEach(function (header) {
        var foldableHeader = header.closest('h1, h2, h3, h4, h5, h6');
        if (foldableHeader) {
            foldableHeader.classList.add('foldable-header');
            var nextElement = foldableHeader.nextElementSibling;
            var contentToFold = [];
            while (nextElement && !nextElement.matches('h1, h2, h3, h4, h5, h6')) {
                contentToFold.push(nextElement);
                nextElement = nextElement.nextElementSibling;
            }
            contentToFold.forEach(function (element) {
                element.classList.add('folded-content');
            });

            foldableHeader.addEventListener('click', function () {
                contentToFold.forEach(function (element) {
                    if (element.style.display === 'none' || element.style.display == '') {
                        element.style.display = 'block';
                    } else {
                        element.style.display = 'none';
                    }
                });
            });
        }
    });
});

</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script type="text/x-mathjax-config">
<!-- /* --><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js", "[Contrib]/siunitx/siunitx.js", "[Contrib]/mhchem/mhchem.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"], ['$', '$'], ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 1.0,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        },
        TeX: {
              equationNumbers: { autoNumber: 'AMS' },
              Macros: {
                  ccsini: '{\\mathrm{Si}₃\\mathrm{N}₄}',
                  cefe: '{\\ce{^{55}Fe}}',
                  vektor: ['{\\begin{pmatrix}#1\\end{pmatrix}}', 1],
                  mtrix: ['{\\begin{pmatrix}#1\\end{pmatrix}}', 1],
                  cp: '{\\mathrm{CP}}',
                  cpt: '{\\mathrm{CPT}}',
                  dd: '{\\mathop{}\\!{\\mathrm{d}}}',
                  sinc: '{\\mathrm{sinc}}'
              }
        }
    });
/*]]>*///--&gt;
</script>
</head>
<body>
<div id="content" class="content">
<nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li>  <a href="./errata.html#sec:errata">1. Errata   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./introduction.html#sec:introduction">2. Introduction   <span class="tag">    <span class="Intro">Intro</span>  </span></a></li>
<li><a href="./about_thesis.html#sec:about_thesis">3. About this thesis   <span class="tag">  <span class="Intro">Intro</span></span></a>
<ul>
<li>  <a href="./about_thesis.html#orgfe77eb6">3.1. Extended notes for the extended thesis <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./about_thesis.html#orgf40a93d">3.2. Why Org mode   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./about_thesis.html#org607bd89">3.3. Notes for future PhD students and IAXO analyses   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./theory.html#sec:theory">4. Theory of axions   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./theory.html#sec:theory:useful_reading_material">4.1. Useful reading material   <span class="tag">    <span class="optional">optional</span>  </span></a></li>
<li>  <a href="./theory.html#sec:theory:illustration_cpt">4.2. Illustration of the \cpt symmetry <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./theory.html#sec:theory:invisible_axion_models">4.3. Invisible axion models and axion couplings</a></li>
<li>  <a href="./theory.html#sec:theory:axion_interactions">4.4. Implications for axion interactions - conversion probability</a></li>
<li>  <a href="./theory.html#sec:theory:solar_axion_flux">4.5. Solar axion flux</a></li>
<li>  <a href="./theory.html#sec:theory:chameleon">4.6. Chameleons</a></li>
<li>  <a href="./theory.html#sec:theory:current_bounds">4.7. Current bounds on coupling constants</a></li>
</ul>
</li>
<li><a href="./helioscopes.html#sec:helioscopes">5. Axion helioscopes   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./helioscopes.html#sec:helioscopes:cast">5.1. CERN Axion Solar Telescope (CAST)</a></li>
<li>  <a href="./helioscopes.html#sec:helioscopes:iaxo">5.2. International AXion Observatory (IAXO)</a></li>
</ul>
</li>
<li><a href="./theory_detector.html#sec:theory_detector">6. X-rays, cosmic muons and gaseous detectors   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./theory_detector.html#sec:theory:particle_int">6.1. Particle interactions with matter</a></li>
<li>  <a href="./theory_detector.html#sec:theory:cosmic_radiation">6.2. Cosmic rays</a></li>
<li>  <a href="./theory_detector.html#sec:theory:gas_fundamentals">6.3. Gaseous detector fundamentals</a></li>
</ul>
</li>
<li><a href="./septemboard.html#sec:septemboard">7. Septemboard detector   <span class="tag">  <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./septemboard.html#sec:detector:micromegas">7.1. Micromegas working principle</a></li>
<li>  <a href="./septemboard.html#sec:detector:timepix">7.2. Timepix ASIC</a></li>
<li>  <a href="./septemboard.html#sec:detector:gridpix">7.3. GridPix</a></li>
<li>  <a href="./septemboard.html#sec:detector:detector_2014_15">7.4. 2014 / 2015 GridPix detector for CAST</a></li>
<li>  <a href="./septemboard.html#sec:detector:detector_overview">7.5. Septemboard detector overview</a></li>
<li>  <a href="./septemboard.html#org2a0c0f4">7.6. Detector readout system</a></li>
<li>  <a href="./septemboard.html#sec:detector:scintillators">7.7. Scintillator vetoes</a></li>
<li>  <a href="./septemboard.html#sec:detector:fadc">7.8. FADC</a></li>
<li>  <a href="./septemboard.html#sec:detector:sin_window">7.9. SiN window</a></li>
<li>  <a href="./septemboard.html#sec:detector:septemboard">7.10. Septemboard - 6 GridPixes around a center one</a></li>
<li>  <a href="./septemboard.html#sec:detector:water_cooling">7.11. Water cooling and temperature readout for the septemboard</a></li>
<li>  <a href="./septemboard.html#sec:septem:efficiency">7.12. Detector efficiency</a></li>
<li>  <a href="./septemboard.html#sec:detector:daq">7.13. Data acquisition and detector monitoring</a></li>
</ul>
</li>
<li><a href="./operation_calibration.html#sec:operation_calibration">8. Detector calibration for operation   <span class="tag">  <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:timepix">8.1. Timepix calibrations</a></li>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:fadc">8.2. FADC calibration</a></li>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:scintillators">8.3. Scintillator calibration</a></li>
</ul>
</li>
<li><a href="./reconstruction.html#sec:reconstruction">9. Data reconstruction   <span class="tag">  <span class="Reconstruction">Reconstruction</span></span></a>
<ul>
<li>  <a href="./reconstruction.html#sec:reco:tpa">9.1. <code>TimepixAnalysis</code> and Nim</a></li>
<li>  <a href="./reconstruction.html#sec:reco:tos_data_parsing">9.2. TOS data parsing</a></li>
<li>  <a href="./reconstruction.html#sec:reco:event_shape">9.3. Expectation of event shapes</a></li>
<li>  <a href="./reconstruction.html#sec:reco:data_reconstruction">9.4. Data reconstruction</a></li>
<li>  <a href="./reconstruction.html#sec:reco:fadc_data">9.5. FADC reconstruction</a></li>
<li>  <a href="./reconstruction.html#sec:reco:scintillator_data">9.6. Scintillator data</a></li>
</ul>
</li>
<li><a href="./cast.html#sec:cast">10. Detector installation &amp; data taking at CAST   <span class="tag">  <span class="CAST">CAST</span></span></a>
<ul>
<li>  <a href="./cast.html#sec:cast:timeline">10.1. Timeline</a></li>
<li>  <a href="./cast.html#sec:cast:alignment">10.2. Alignment</a></li>
<li>  <a href="./cast.html#sec:cast:detector_setup">10.3. Detector setup at CAST</a></li>
<li>  <a href="./cast.html#sec:cast:window_accident">10.4. Window accident</a></li>
<li>  <a href="./cast.html#sec:cast:data_taking_woes">10.5. Data taking woes</a></li>
<li>  <a href="./cast.html#sec:cast:data_taking_campaigns">10.6. Summary of CAST data taking</a></li>
</ul>
</li>
<li><a href="./calibration.html#sec:calibration">11. Data calibration   <span class="tag">  <span class="Calibration">Calibration</span></span></a>
<ul>
<li>  <a href="./calibration.html#sec:calibration:energy">11.1. Energy calibration - in principle</a></li>
<li>  <a href="./calibration.html#sec:calib:detector_behavior_over_time">11.2. Detector behavior over time</a></li>
<li>  <a href="./calibration.html#sec:calib:final_energy_calibration">11.3. Energy calibration dependence on the gas gain</a></li>
<li>  <a href="./calibration.html#sec:calib:fadc">11.4. FADC</a></li>
</ul>
</li>
<li><a href="./background.html#sec:background">12. Finding signal and defining background | Background rate computation   <span class="tag">  <span class="Analysis">Analysis</span></span></a>
<ul>
<li>  <a href="./background.html#sec:background:likelihood_method">12.1. Likelihood method</a></li>
<li>  <a href="./background.html#sec:cdl">12.2. CAST Detector Lab</a></li>
<li>  <a href="./background.html#sec:background:likelihood_cut">12.3. Application of likelihood cut for background rate</a></li>
<li>  <a href="./background.html#sec:background:mlp">12.4. Artificial neural networks as cluster classifiers</a></li>
<li>  <a href="./background.html#sec:background:additional_vetoes">12.5. Additional detector features as vetoes</a></li>
<li>  <a href="./background.html#sec:background:all_vetoes_combined">12.6. Background rates of combined vetoes and efficiencies</a></li>
</ul>
</li>
<li><a href="./limit.html#sec:limit">13. Limit calculation   <span class="tag">  <span class="Limit">Limit</span></span></a>
<ul>
<li>  <a href="./limit.html#sec:limit:method_introduction">13.1. Limit method - introduction</a></li>
<li>  <a href="./limit.html#sec:limit:method_likelihood">13.2. Limit method - likelihood function \(\mathcal{L}\)</a></li>
<li>  <a href="./limit.html#sec:limit:method_computing_L">13.3. Limit method - computing \(\mathcal{L}\)</a></li>
<li>  <a href="./limit.html#sec:limit:method_computing_a_limit">13.4. Limit method - computing a limit</a></li>
<li>  <a href="./limit.html#sec:limit:method_expected_limit">13.5. Limit method - toy candidate sets and expected limits</a></li>
<li>  <a href="./limit.html#sec:limit:method_systematics">13.6. Limit method - extending \(\mathcal{L}\) for systematics</a></li>
<li>  <a href="./limit.html#sec:limit:method_mcmc">13.7. Limit method - evaluating \(\mathcal{L}\) with nuisance parameters</a></li>
<li>  <a href="./limit.html#org5995639">13.8. Note about likelihood integral   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#orgc3e5f13">13.9. Derivation of short form of \(\mathcal{L}\) <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#sec:limit:ingredients">13.10. Likelihood ingredients in detail</a></li>
<li>  <a href="./limit.html#sec:limit:systematics">13.11. Systematics</a></li>
<li>  <a href="./limit.html#sec:limit:mcmc_calc_limit">13.12. MCMC to sample the distribution and compute a limit</a></li>
<li>  <a href="./limit.html#sec:limit:expected_limits">13.13. Expected limits of different setups</a></li>
<li>  <a href="./limit.html#sec:limit:candidates">13.14. Solar tracking candidates</a></li>
<li>  <a href="./limit.html#sec:limit:observed_limit">13.15. Observed limit - \(g_{ae}\)</a></li>
<li>  <a href="./limit.html#sec:limit:other_couplings">13.16. Other coupling constants</a></li>
<li>  <a href="./limit.html#org75d3b34">13.17. Comparison to 2013 limit (using their method)   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#orgfcbf364">13.18. Observed limit for different axion masses   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./outlook.html#sec:outlook">14. Outlook</a></li>
<li>  <a href="./summary.html#sec:summary">15. Summary &amp; conclusion</a></li>
<li>  <a href="./bibliography.html#sec:bibliography">16. Bibliography   <span class="tag">    <span class="html">html</span>  </span></a></li>
<li><a href="./daq.html#sec:daq">17. Data acquisition and detector monitoring   <span class="tag"><span class="Appendix">Appendix</span> <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./daq.html#sec:daq:tof">17.1. Timepix Operating Firmware - TOF</a></li>
<li>  <a href="./daq.html#sec:daq:tos">17.2. Timepix Operating Software - TOS</a></li>
<li>  <a href="./daq.html#sec:daq:septemboard_event_display">17.3. Septemboard event display</a></li>
</ul>
</li>
<li><a href="./appendix_configuration.html#sec:appendix:configuration">18. Configuration and TOS / TOF versions   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_configuration.html#sec:appendix:configuration:tos_config">18.1. TOS configuration file</a></li>
<li>  <a href="./appendix_configuration.html#sec:appendix:configuration:tos_tof_versions">18.2. TOS and TOF versions used at CAST</a></li>
</ul>
</li>
<li><a href="./appendix_calibration.html#sec:appendix:calibration">19. Calibrations   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_calibration.html#sec:appendix:calibration:timepix">19.1. Timepix calibrations</a></li>
<li>  <a href="./appendix_calibration.html#sec:appendix:septemboard_calibrations">19.2. Septemboard calibration</a></li>
<li>  <a href="./appendix_calibration.html#sec:appendix:scintillator_calibration_notes">19.3. Calibration measurements of the veto scintillator paddle   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_cast_operations.html#sec:appendix:cast_operations">20. CAST operation procedures   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_cast_operations.html#sec:appendix:cast_operations:terminology">20.1. CAST terminology</a></li>
<li>  <a href="./appendix_cast_operations.html#sec:cast:high_voltage">20.2. High voltage supply</a></li>
<li>  <a href="./appendix_cast_operations.html#sec:cast:vacuum_system">20.3. Vacuum system</a></li>
<li>  <a href="./appendix_cast_operations.html#sec:cast:watercooling_gas">20.4. Watercooling system &amp; gas supply</a></li>
<li>  <a href="./appendix_cast_operations.html#sec:cast:interlock_systems">20.5. Interlock systems</a></li>
<li>  <a href="./appendix_cast_operations.html#sec:appendix:cast_log_files">20.6. CAST log files</a></li>
</ul>
</li>
<li><a href="./appendix_cast_run_list.html#sec:appendix:cast_run_list">21. CAST data taking run list   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_cast_run_list.html#orgb52235a">21.1. Full version   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_cast_data_taking_notes.html#sec:appendix:cast_data_taking_notes">22. CAST data taking notes <code>[0/1]</code>   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./appendix_cast_data_taking_notes.html#orgd947e01">22.1. Run table</a></li>
<li>  <a href="./appendix_cast_data_taking_notes.html#orgf8afac6">22.2. Data runs</a></li>
<li>  <a href="./appendix_cast_data_taking_notes.html#orgfe96ddc">22.3. Calibration runs</a></li>
<li>  <a href="./appendix_cast_data_taking_notes.html#orgac5a852">22.4. Automatically generated run list</a></li>
<li>  <a href="./appendix_cast_data_taking_notes.html#orgd5cdef1">22.5. Automatically calculated total run times</a></li>
<li>  <a href="./appendix_cast_data_taking_notes.html#org2406344">22.6. InGrid temperature from shift forms</a></li>
</ul>
</li>
<li><a href="./appendix_cabling_and_softwar_setup.html#sec:appendix:cabling_and_softwar_setup">23. Cabling &amp; software setup <code>[/]</code>   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./appendix_cabling_and_softwar_setup.html#orge32a9e1">23.1. Virtex V6 cabling</a></li>
<li>  <a href="./appendix_cabling_and_softwar_setup.html#orge17b088">23.2. Detector cabling</a></li>
<li>  <a href="./appendix_cabling_and_softwar_setup.html#org93c1c60">23.3. Vivado / ISE on void linux &amp; flashing Virtex V6</a></li>
<li>  <a href="./appendix_cabling_and_softwar_setup.html#org9625327">23.4. Setting up the chips in TOS</a></li>
</ul>
</li>
<li><a href="./appendix_vacuum_contamination.html#sec:appendix:vacuum_contamination">24. Window rupture and vacuum contamination   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./appendix_vacuum_contamination.html#org3cd49bd">24.1. Calculation of vacuum volume</a></li>
<li>  <a href="./appendix_vacuum_contamination.html#orgc39e76f">24.2. Calculation of potential influx of gas</a></li>
<li>  <a href="./appendix_vacuum_contamination.html#orgc67dc29">24.3. Consider pumping of pumps</a></li>
<li>  <a href="./appendix_vacuum_contamination.html#orgbac7f48">24.4. Calculation of possible contamination</a></li>
</ul>
</li>
<li><a href="./appendix_detector_time_behavior.html#sec:appendix:detector_time_behavior">25. Detector behavior over time   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_detector_time_behavior.html#sec:appendix:choice_gas_gain_binning">25.1. Choice of gas gain binning time interval</a></li>
<li>  <a href="./appendix_detector_time_behavior.html#sec:appendix:correlation_gas_gain_ambient_temp">25.2. Correlation of gas gain and ambient CAST temperature</a></li>
</ul>
</li>
<li><a href="./appendix_cast_detector_lab.html#sec:appendix:cast_detector_lab">26. CAST Detector Lab data   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_cast_detector_lab.html#orgc899fb3">26.1. Generate all spectrum plots split by run   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_cast_detector_lab.html#sec:appendix:cdl_spectra_by_run">26.2. All spectra split by run</a></li>
<li>  <a href="./appendix_cast_detector_lab.html#sec:appendix:cdl:all_spectra_fits">26.3. All CDL spectra with line fits   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_cast_detector_lab.html#sec:appendix:cdl:all_spectra_fits_by_run">26.4. All CDL spectra with line fits by run</a></li>
</ul>
</li>
<li><a href="./appendix_fit_by_run_justification.html#sec:appendix:fit_by_run_justification">27. CAST Detector Lab variations and fitting by run   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_fit_by_run_justification.html#sec:appendix:fit_by_run:gas_gain_var_cluster_prop">27.1. Influence of gas gain variations on cluster properties</a></li>
<li>  <a href="./appendix_fit_by_run_justification.html#org13d2559">27.2. Data overview with pixel spectra <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra">28. Morphing of CDL reference spectra   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_morphing_cdl_spectra.html#org78be87a">28.1. Generate all morphing / tile related plots   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_morphing_cdl_spectra.html#orgdadd742">28.2. Generate plot comparing likelihood behavior   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:tilemaps">28.3. Tilemap of each likelihood dataset</a></li>
<li>  <a href="./appendix_morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:interpolation_raster">28.4. Interpolation of each likelihood dataset</a></li>
<li>  <a href="./appendix_morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:binwise_linear">28.5. Binwise linear interpolations for each likelihood dataset</a></li>
<li>  <a href="./appendix_morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:notes">28.6. Notes on CDL morphing development   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_occupancy.html#sec:appendix:occupancy">29. Occupancy maps   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_occupancy.html#org71d0d19">29.1. Run-2</a></li>
<li>  <a href="./appendix_occupancy.html#orgcbfcb5e">29.2. Run-3</a></li>
<li>  <a href="./appendix_occupancy.html#org3a727ee">29.3. Generate occupancy map plots   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_fadc.html#sec:appendix:fadc">30. FADC   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_fadc.html#sec:appendix:fadc:rise_fall">30.1. FADC rise and fall time</a></li>
<li>  <a href="./appendix_fadc.html#sec:appendix:background:fadc">30.2. FADC veto</a></li>
<li>  <a href="./appendix_fadc.html#org595d68a">30.3. Generate plot of rise time vs skewness   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_fadc.html#sec:appendix:fadc_veto_empirical_cluster_length">30.4. Expected cluster size</a></li>
</ul>
</li>
<li><a href="./appendix_background_rates.html#sec:appendix:background_rates">31. Raw data and background rates   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_background_rates.html#sec:appendix:background_rates:full_chip">31.1. Background rates over full chip</a></li>
<li>  <a href="./appendix_background_rates.html#org6b8736f">31.2. Generate rate without any vetoes over full chip   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_background_rates.html#org7827cf1">31.3. Generate background rates over full chip   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_background_rates.html#org88d5321">31.4. Generate table of background rates for all setups   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./appendix_background_interpolation_chip_area.html#sec:appendix:background_interpolation_chip_area">32. Background interpolation chip cutout correction   <span class="tag">    <span class="Appendix">Appendix</span>  </span></a></li>
<li><a href="./appendix_limit_additional.html#sec:appendix:limit_additional">33. Additional limit information   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_limit_additional.html#sec:appendix:conversion_probability">33.1. Conversion probability as a function of mass   <span class="tag">    <span class="Appendix">Appendix</span>  </span></a></li>
<li>  <a href="./appendix_limit_additional.html#sec:appendix:exp_limit_percentiles">33.2. Expected limit table with percentiles</a></li>
<li>  <a href="./appendix_limit_additional.html#sec:appendix:limit_additional:axion_photon">33.3. Observed limit - axion photon \(g_{aγ}\)</a></li>
<li>  <a href="./appendix_limit_additional.html#sec:appendix:limit_additional:chameleon">33.4. Observed limit - chameleon \(β_γ\)</a></li>
</ul>
</li>
<li><a href="./appendix_software.html#sec:appendix:software">34. Software   <span class="tag"><span class="Software">Software</span> <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_software.html#orge51f988">34.1. Why did I start writing my own analysis framework?   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_software.html#org378ccdf">34.2. Nim   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_software.html#sec:appendix:timepix_analysis">34.3. TimepixAnalysis</a></li>
<li>  <a href="./appendix_software.html#org92b1f48">34.4. Other libraries relevant for TimepixAnalysis</a></li>
</ul>
</li>
<li><a href="./appendix_full_data_reconstruction.html#sec:appendix:full_data_reconstruction">35. Full data reconstruction   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_full_data_reconstruction.html#orgc87960b">35.1. Raw data parsing and reconstruction</a></li>
<li>  <a href="./appendix_full_data_reconstruction.html#org652a080">35.2. Parse and reconstruct the CDL data</a></li>
<li>  <a href="./appendix_full_data_reconstruction.html#org5831301">35.3. Add tracking information to background files</a></li>
<li>  <a href="./appendix_full_data_reconstruction.html#org904d73c">35.4. Using <code>runAnalysisChain</code></a></li>
<li>  <a href="./appendix_full_data_reconstruction.html#orgb4de31c">35.5. Applying a classifier</a></li>
<li>  <a href="./appendix_full_data_reconstruction.html#org9252218">35.6. Computing limits</a></li>
</ul>
</li>
<li><a href="./appendix_average_depth_xrays_argon.html#sec:appendix:average_depth_xrays_argon">36. Average distance X-rays travel in argon at CAST conditions   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_average_depth_xrays_argon.html#org89ae1e7">36.1. Reference to original document   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_average_depth_xrays_argon.html#orgc035fda">36.2. Calculate conversion point numerically</a></li>
<li>  <a href="./appendix_average_depth_xrays_argon.html#orgc101b38">36.3. Compiling and running the code   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./appendix_raytracing.html#sec:appendix:raytracing">37. Raytracing   <span class="tag"><span class="Software">Software</span> <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./appendix_raytracing.html#sec:appendix:raytracing:traxer">37.1. TrAXer - An interactive axion raytracer</a></li>
<li>  <a href="./appendix_raytracing.html#sec:appendix:raytracing:llnl_telescope">37.2. A few more details about the LLNL telescope</a></li>
<li>  <a href="./appendix_raytracing.html#sec:appendix:raytracing:panter">37.3. Comparison of TrAXer results with PANTER measurements</a></li>
<li>  <a href="./appendix_raytracing.html#sec:appendix:raytracing:axion_image">37.4. Computing an axion image with TrAXer</a></li>
<li>  <a href="./appendix_raytracing.html#orgdb277d0">37.5. Reproducing an X-ray finger run with TrAXer   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_raytracing.html#org33f56e2">37.6. <span class="done DONE">DONE</span> Can we finish our interactive ray tracer?   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_raytracing.html#org66d4b31">37.7. Rerunning Al Kα after replacing target   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./appendix_raytracing.html#orgab3dcf7">37.8. Figure error development notes   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./appendix_acknowledgments.html#sec:appendix:acknowledgments">38. Acknowledgments   <span class="tag">    <span class="Ack">Ack</span>  </span></a></li>
</ul>
</div>
</nav>
<div id="outline-container-sec:calibration" class="outline-2">
<h2 id="sec:calibration">  <a href="#sec:calibration">  <span class="section-number-2">11.</span> Data calibration   <span class="tag">    <span class="Calibration">Calibration</span>  </span></a></h2>
<div id="text-sec:calibration" class="outline-text-2">
<p>
With the roughly \(\SI{3500}{h}\) of data recorded at CAST it is time to
discuss the final calibrations <sup>  <a id="fnr.1" href="#fn.1" class="footref" role="doc-backlink">1</a></sup> necessary for the
calculation of a physics result. On the side of the Septemboard
detector this means the &apos;energy calibration&apos;,
sec. <a href="./calibration.html#sec:calibration:energy">11.1</a>; the calculation of the energy of each
event recorded with the Septemboard detector. This necessarily needs
to include a discussion of detector variability both due to external
factors as well as differing detector calibrations and setups,
sec. <a href="./calibration.html#sec:calib:detector_behavior_over_time">11.2</a>. Here we provide the
reasoning for the choices leading to the final energy calibration,
presented in sec. <a href="./calibration.html#sec:calib:final_energy_calibration">11.3</a>. Similarly, for
the FADC the impact of the noise seen during data taking and resulting
differing amplifier settings will be discussed in
sec. <a href="./calibration.html#sec:calib:fadc">11.4</a>.
</p>
</div>
<div id="outline-container-sec:calibration:energy" class="outline-3">
<h3 id="sec:calibration:energy">  <a href="#sec:calibration:energy">  <span class="section-number-3">11.1.</span> Energy calibration - in principle</a></h3>
<div id="text-sec:calibration:energy" class="outline-text-3">
<p>
The reconstructed data from the GridPixes, as described in chapter
<a href="./reconstruction.html#sec:reco:data_reconstruction">9.4</a> (cluster finding, cluster reconstruction
and charge calibration), still needs to be calibrated in energy. The
charge calibration <a href="./operation_calibration.html#sec:operation_calibration:tot_calibration">8.1.1</a> computes
the number of electrons recorded on each GridPix pixel in an event
from the <code>ToT</code> counts.
</p>

<p>
In order to calculate an equivalent energy based on a certain amount
of charge – which depends on the gas gain – the data recorded using
the \cefe calibration source at CAST is used. As the \cefe spectrum
(see sec. <a href="./theory_detector.html#sec:theory:escape_peaks_55fe">6.3.8</a>) has a photopeak at
\(\SI{5.9}{keV}\) and an escape peak at \(\SI{2.9}{keV}\) it provides two
different lines relating charges to energies for calibration. While
the charge calibration for each pixel from <code>ToT</code> to electrons is
non-linear, the relation between energy and recorded charge is
linear. The position of the two peaks in the \cefe spectrum needs to
be determined precisely, which is done using a double gaussian fit
</p>

\begin{equation}
\label{eq:calib:fe55_charge_fit_function}
f(N_e, μ_e, σ_e, N_p, μ_p, σ_p) =
G^{\text{esc}}_{\text{K}_{α}}(N_e,μ_e,σ_e) + G_{\text{K}_{α}}(N_p,μ_p,σ_p),
\end{equation}

<p>
where \(G\) is a regular gaussian, one for the escape peak
\(G^{\text{esc}}\) and one for the photopeak \(G\). An example spectrum
with such a fit can be seen in
fig. <a href="#fig:calib:fe55_example_fit_spectrum">1(a)</a>.
</p>

<figure id="fig:calib:fe55_calibration" class="figure-wrapper">
<figure id="fig:calib:fe55_example_fit_spectrum" class="subfigure" data-width="49%">  <img src="./figs/home/basti/phd/Figs/energyCalibration/run_149/fe_spec_run_149_chip_3_charge.svg" data-width="99%" />  <figcaption>Figure 1(a): \cefe spectrum</figcaption></figure> <figure id="fig:calib:fe55_example_energy_calib" class="subfigure" data-width="49%">  <img src="./figs/home/basti/phd/Figs/energyCalibration/run_149/energy_calib_run_149_charge.svg" data-width="99%" />  <figcaption>Figure 1(b): Energy calibration</figcaption></figure>
<figcaption>Figure 1: <a href="#fig:calib:fe55_example_fit_spectrum">1(a)</a>: Fit to a \cefe calibration run from the CAST data (run 149)
           using a double gaussian fit. <a href="#fig:calib:fe55_example_energy_calib">1(b)</a>: Linear fit to the escape and photopeak energies to relate charges
           in electrons to energies in $\si{keV}$.</figcaption>
</figure>


<p>
Then, a linear function without y-offset
</p>

<p>
\[
Q(E) = m_c · E
\]
</p>

<p>
is fitted to the found peak positions of the spectra by charge \(Q\),
against the known energies \(E\) of the peaks in the \cefe
spectrum. This yields the calibration factor, \(a = m_c⁻¹\), which can
be used to calibrate all events with <span class="underline">the same</span> gas gain. Over the
time of data taking at CAST the gas gain varies by a significant
margin, requiring a more complex calibration routine as the
calibration factor would produce too imprecise energy values otherwise
(for example if each \cefe calibration run were used to deduce one
calibration factor \(a = m_c⁻¹\) to be applied to the closest background
data in time). An example for this fit is seen in fig. <a href="#fig:calib:fe55_example_energy_calib">1(b)</a>.
</p>

<p>
Fortunately, the gas gain can be computed using raw data without
evaluating any physical events, allowing calculation of it also for
raw background data. This motivates the idea to map a gas gain to a
calibration factor needed to calibrate events at such gas gains in
energy. Taking a certain time interval in which the detector gas gain
is assumed constant, the gas gain of all time slices of this length is
computed for background and calibration data. For all time slices in
the calibration data the procedure above – fitting the \cefe spectrum
and calculating the energy calibration – is performed. A higher gas
gain leads to linearly more recorded electrons in the \cefe
spectra. Therefore, all energy calibration factors determined from
different time intervals should be on a slope depending on the gas
gain. As such a final fit
</p>

\begin{equation}
\label{eq:gas_gain_vs_calib_factor}
a(G) = m_g · G + b
\end{equation}

<p>
is performed to all time intervals of all calibration runs. This
yields the energy calibration factor \(a\) valid for a given gas gain
\(G\). Then in order to calibrate the energy of a given cluster in the
background data, the same time slicing is performed and one gas gain
calculated for each slice. The gas gain is inserted into the fit and
the resulting calibration factor is used to calibrate the energy of
every cluster in that time slice. We will come back to this fit in
sec. <a href="./calibration.html#sec:calib:final_energy_calibration">11.3</a> to finalize the energy
calibration.
</p>

<p>
The remaining question is the stability of the gas gain over time,
which we will look at next in the context of the general detector
behavior over time. This allows us to find a suitable time interval to
use for all data and hence perform a temporally stable energy calibration.
</p>
</div>
<div id="outline-container-sec:calib:energy_gen_example_cefe" class="outline-4">
<h4 id="sec:calib:energy_gen_example_cefe">  <a href="#sec:calib:energy_gen_example_cefe">  <span class="section-number-4">11.1.1.</span> Generate example plot for \cefe spectrum   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-sec:calib:energy_gen_example_cefe" class="outline-text-4">
<p>
We use run number 149 (for no important reason) as an example
calibration run.
</p>

<p>
Desktop:
</p>
<div class="org-src-container">
<pre class="src src-sh">raw_data_manipulation <span style="color: #E6DB74; font-weight: bold;">\</span>
    -p /mnt/4TB/CAST/Data/2018/CalibrationRuns/Run_149_180219-17-25.tar.gz <span style="color: #E6DB74; font-weight: bold;">\</span>
    -r calib <span style="color: #E6DB74; font-weight: bold;">\</span>
    -o /tmp/run_149.h5
</pre>
</div>
<p>
Laptop:
</p>
<div class="org-src-container">
<pre class="src src-sh">raw_data_manipulation <span style="color: #E6DB74; font-weight: bold;">\</span>
    -p /mnt/1TB/CAST/2018/CalibrationRuns/Run_149_180219-17-25.tar.gz <span style="color: #E6DB74; font-weight: bold;">\</span>
    -r calib <span style="color: #E6DB74; font-weight: bold;">\</span>
    -o /tmp/run_149.h5
</pre>
</div>

<p>
We overwrite the default to use TikZ output via an environment
variable here just to make sure it is set independent of the
<code>config.toml</code> file.
</p>
<div class="org-src-container">
<pre class="src src-sh">reconstruction -i /tmp/run_149.h5 --out /tmp/reco_149.h5 --useTeX=true --plotOutPath ~/phd/Figs/energyCalibration/run_149/
</pre>
</div>

<p>
This produces the following plots:
</p>
<ul class="org-ul">
<li>  <img alt="energy_calib_run_149.svg" class="org-svg" src="./figs/home/basti/phd/Figs/energyCalibration/run_149/energy_calib_run_149.svg" /></li>
<li>  <img alt="energy_calib_run_149_charge.svg" class="org-svg" src="./figs/home/basti/phd/Figs/energyCalibration/run_149/energy_calib_run_149_charge.svg" /></li>
<li>  <img alt="fe_spec_run_149_chip_3.svg" class="org-svg" src="./figs/home/basti/phd/Figs/energyCalibration/run_149/fe_spec_run_149_chip_3.svg" /></li>
<li>  <img alt="fe_spec_run_149_chip_3_charge.svg" class="org-svg" src="./figs/home/basti/phd/Figs/energyCalibration/run_149/fe_spec_run_149_chip_3_charge.svg" /></li>
</ul>
</div>
</div>
<div id="outline-container-org535f848" class="outline-4">
<h4 id="org535f848">  <a href="#org535f848">  <span class="section-number-4">11.1.2.</span> On <code>ToT</code> vs. <code>ToA</code> for a Timepix1 detector   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-11-1-2" class="outline-text-4">
<p>
This is a good point to comment on the choice of using all pixels in
the CAST data taking to record <code>ToT</code> values. One might argue that due
to the single electron efficiency of GridPix detectors it would have
been a good idea to either just record only <code>ToA</code> values for all
pixels as to have access to time information (yielding longitudinal
information about events) or at least use a checkerboard pattern with
half the pixels recording <code>ToT</code> and half <code>ToA</code> values.
</p>

<p>
There are two major issues with that (outside of the fact that at the
time of making these choices I was not in a position to make an
educated choice anyway):
</p>

<ol class="org-ol">
<li>the <code>ToA</code> counter, as far as I&apos;m aware, is too short for the
Timepix1 as needed in the context for CAST like shutter times. Ref
(<a href="./bibliography.html#citeproc_bib_item_150">Lupberger 2016</a>) page 30, but the gist is that Timepix1
pixels can count to 11810. At a clock frequency of \(\SI{40}{MHz}\)
this only yields a time window of \(\SI{295}{μs}\) for <code>ToA</code>
values. For shutter lengths on the order of seconds such short
<code>ToA</code> counters would run over pretty much always.</li>
<li>ignoring the practical limitation of 1, which may or may not be
possible to circumvent in some way or another, there is a separate
problem: Single electron efficiency is an ideal approximation of
reality. Either for higher energies or in rare cases – which are
extremely important for low rate experiments like CAST where &quot;rare&quot;
means precisely important for the selection of candidates! –
conversion of photons can happen very close to the grid. In those
cases <span class="underline">many</span> primary electrons will enter single holes, resulting
in events with very few pixels but very high charges. See
sec. <a href="./calibration.html#sec:large_events_few_pixels_tot">11.1.2.1</a> below.</li>
</ol>

<p>
Fortunately, we do have the FADC signal to get at least some time
information regardless of the choice.
</p>

<p>
At the same time in the future with a Timepix3 based GridPix detector
all these points will become mute: it records both <code>ToT</code> and <code>ToA</code> at
the same time at time high resolution. This <span class="underline">also</span> means using an FADC
will become irrelevant, avoiding the difficulties of dealing with
analogue signals and associated EMI issues.
</p>
</div>
<div id="outline-container-sec:large_events_few_pixels_tot" class="outline-5">
<h5 id="sec:large_events_few_pixels_tot">  <a href="#sec:large_events_few_pixels_tot">  <span class="section-number-5">11.1.2.1.</span> (While generating fake data) Events with large energy, but few pixels</a></h5>
<div id="text-sec:large_events_few_pixels_tot" class="outline-text-5">
<blockquote>
<p>
This section is taken out of my regular notes. It was written while
trying to understand certain behaviors while trying to generate fake
event data from existing data by removal of pixels. That approach is
the easiest way to generate lower energy &apos;simulated&apos; data from
existing data without having to simulate full events (which we ended
up doing later anyway).
</p>
</blockquote>

<p>
While developing some fake data using existing events in the photo
peak &amp; filtering out pixels to end up at ~3 keV, I noticed the
prevalence of events with &lt;150 pixels &amp; ~6 keV energy.
</p>

<p>
Code produced by splicing in the following code into the body of <code>generateFakeData</code>.
</p>
<div class="org-src-container">
<pre class="src src-nim">    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; xs.<span style="color: #F92672;">len</span>:
      <span style="color: #F92672;">if</span> xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> &lt; <span style="font-style: italic;">150</span> <span style="color: #F92672;">and</span> energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> &gt; <span style="font-style: italic;">5</span>.<span style="font-style: italic;">5</span>:
        <span style="color: #75715E;"># </span><span style="color: #75715E;">recompute from data</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pp </span>= toSeq<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span> ..&lt; xs<span style="color: #66D9EF;">[</span>i<span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>x: xs<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, y: ys<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, ch: ts<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">newEnergy </span>= h5f.computeEnergy<span style="color: #AE81FF;">(</span>pp, group, a, b, c, t, bL, mL<span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Length &quot;</span>, xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> , <span style="color: #E6DB74;">&quot; w/ energy &quot;</span>, energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>, <span style="color: #E6DB74;">&quot; recomp &quot;</span>, newEnergy
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;x&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.x.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;y&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.y.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;ch&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.ch.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
        ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;x&quot;</span>, <span style="color: #E6DB74;">&quot;y&quot;</span>, color = <span style="color: #E6DB74;">&quot;ch&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
          geom_point<span style="color: #AE81FF;">()</span> +
          ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;funny its real&quot;</span><span style="color: #AE81FF;">)</span> + 
          ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/fake_event.pdf&quot;</span><span style="color: #AE81FF;">)</span>
        sleep<span style="color: #AE81FF;">(</span><span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">if</span> <span style="color: #AE81FF;">true</span>: <span style="color: #F92672;">quit</span><span style="color: #AE81FF;">()</span>
</pre>
</div>

<p>
This gives about 100 events that fit the criteria out of a total of
O(20000). A ratio of 1/200 seems probably reasonable for absorption of
X-rays at 5.9 keV.
</p>

<p>
While plotting them I noticed that they all share that they are
incredibly dense, like:
<img alt="event_few_pixels_large_energy.svg" class="org-svg" src="./figs/home/basti/org/Figs/statusAndProgress/exampleEvents/event_few_pixels_large_energy.svg" />
</p>

<p>
These events must be events where the X-ray to photoelectron
conversion happens very close to the grid!
This is one argument &quot;in favor&quot; of using ToT instead of ToA on the
Timepix1 and more importantly a good reason to keep using the ToT
values instead of pure pixel counting for at least some events!
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> We should look at number of pixels vs. energy as a scatter plot to see</li>
</ul>
<p>
what this gives us.
</p>
</div>
</div>
<div id="outline-container-org8d558a4" class="outline-5">
<h5 id="org8d558a4">  <a href="#org8d558a4">  <span class="section-number-5">11.1.2.2.</span> Plotting low count / high energy events with <code>plotData</code></a></h5>
<div id="text-11-1-2-2" class="outline-text-5">
<p>
Alternatively to the above section we can also just use <code>plotData</code> to
create some event displays for such events for us. We can utilize the
<code>--cuts</code> argument to create event displays only for events with fewer
than a certain number of pixels and more than some amount of energy.
</p>

<p>
Let&apos;s say &lt; 100 pixels and &gt; 5 keV for example:
</p>
<div class="org-src-container">
<pre class="src src-sh">plotData <span style="color: #E6DB74; font-weight: bold;">\</span>
    --h5file ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --runType=rtBackground <span style="color: #E6DB74; font-weight: bold;">\</span>
    --eventDisplay --septemboard <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;hits&quot;, 0, 100)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;energyFromCharge&quot;, 5.0, Inf)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;centerX&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;centerY&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --applyAllCuts
</pre>
</div>

<p>
Or we can produce a scatter plot of how the number of hits relates to
the energy if we make some similar cuts (producing the plot for all
background data obviously drowns it in uninteresting events). We do
this by utilizing the custom <code>--x</code> and <code>--y</code> argument:
</p>
<div class="org-src-container">
<pre class="src src-sh">plotData <span style="color: #E6DB74; font-weight: bold;">\</span>
  --h5file ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
  --runType=rtBackground <span style="color: #E6DB74; font-weight: bold;">\</span>
  --x energyFromCharge --y hits --z length <span style="color: #E6DB74; font-weight: bold;">\</span>
  --cuts <span style="color: #E6DB74;">&apos;(&quot;hits&quot;, 0, 150)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
  --cuts <span style="color: #E6DB74;">&apos;(&quot;energyFromCharge&quot;, 4.0, Inf)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
  --cuts <span style="color: #E6DB74;">&apos;(&quot;centerX&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
  --cuts <span style="color: #E6DB74;">&apos;(&quot;centerY&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
  --applyAllCuts 
</pre>
</div>
<p>
In addition we colored each point by the length of the cluster to see
if these clusters are commonly small.
</p>

<p>
This yields the following plot, fig. <a href="#fig:calibration:large_energy_few_hits_scatter">2</a>.
</p>


<figure id="fig:calibration:large_energy_few_hits_scatter">
<img alt="events_few_hits_large_energy_scatter.svg" class="org-svg" src="./figs/home/basti/phd/Figs/eventProperties/events_few_hits_large_energy_scatter.svg" />

<figcaption>Figure 2: <span class="figure-number">Figure 38: </span>Scatter plot of the energy of clusters against the number of hits for clusters not at the edges of the chips and filtered to &lt; 150 hits and more than 4 keV. The color code is the length of the clusters in milli meter.</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="outline-container-sec:calib:detector_behavior_over_time" class="outline-3">
<h3 id="sec:calib:detector_behavior_over_time">  <a href="#sec:calib:detector_behavior_over_time">  <span class="section-number-3">11.2.</span> Detector behavior over time</a></h3>
<div id="text-sec:calib:detector_behavior_over_time" class="outline-text-3">
<p>
Outside the detector related issues discussed in section
<a href="./cast.html#sec:cast:data_taking_woes">10.5</a> the detector generally ran very stable
during Run-2 and Run-3 at CAST. This allows and requires to assess the
data quality in more nuanced ways. Specifically, the stability of the
recorded signals over time is of interest, which is one of the main
purposes of the \cefe calibration runs. A fixed spectrum allows to verify
stable operation easily. In particular of interest for the energy
calibration of the data are the detected charge and gas gain of the
detector.
</p>

<p>
As the charge and gas gain can be computed purely from individual
pixel data without any physical interpretation, it serves as a great
reference over time. Longer time scale variations of the gas gain were
already evident from the calibration runs during data taking and
partially expected due to the power supply and grounding problems
encountered, as well as different sets of calibrations between Run-2
and Run-3. By binning the data into short intervals of order one hour,
significant fluctuations can be observed even on such time
scales. Fig. <a href="#fig:calib:total_charge_over_time">3</a> shows the normalized
median of the total charge in events for all CAST data normalized by
the datasets (background and calibration). Each data point represents
a \(\SI{90}{min}\) time slice. Some data is removed prior to calculation
of the median as mentioned in the caption. The important
takeaway of the figure is the extreme variability of the median charge
(up to \(\SI{30}{\%}\)!). Fortunately though, the background and
calibration data behaves the same, evident by the strong correlation
(purple background, green calibration). While the causes for the
variability are not entirely certain (see
sec. <a href="./calibration.html#sec:calib:causes_variability">11.2.2</a>), it allows us to take action and
calibrate the data accordingly.
</p>


<figure id="fig:calib:total_charge_over_time">
<img alt="background_median_charge_binned_90.0_min_filtered_crSilver.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/plotTotalChargeOverTime/background_median_charge_binned_90.0_min_filtered_crSilver.svg" />

<figcaption>Figure 3: <span class="figure-number">Figure 39: </span>The plot shows the median charge within \(\SI{90}{min}\) time windows of both background and calibration data. Some data is removed (only clusters with less than 500 pixels active to remove the worst sparks and extremely large events) and only events within the inner \(\SI{4.5}{mm}\) radius are considered. Each data type (calibration and background) is normalized to 1 as the median charge is very different in the datasets. The median is used instead of the mean to further remove effect of very rare, but extreme outliers. Each pane of the plot shows a portion of data taking with significant time without data between each.</figcaption>
</figure>
</div>
<div id="outline-container-org0e14cca" class="outline-4">
<h4 id="org0e14cca">  <a href="#org0e14cca">  <span class="section-number-4">11.2.1.</span> Generate plot for median of charge over time   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-11-2-1" class="outline-text-4">
<p>
Let&apos;s generate the plot for the median charge within 90 minutes,
filtered to only clusters with less than 500 hits, also showing the
calibration data, filtered to the silver region &amp; each data type
(calibration &amp; background) normalized to 1, as a facet plot.
</p>

<ul class="org-ul">
<li class="on"><code>[X]</code> We hand <code>StartHue=285</code> manually here for now, but we should change
that to become a thesis wide setting for everything we compile.
-&gt; Done.</li>
</ul>

<p>
For a note on why the median and not the mean, see the whole section
on &quot;Detector behavior over time&quot; in the <code>statusAndProgress</code> and in
particular the &apos;Addendum&apos; there (extreme outliers in some cases is the tl/dr).
</p>
<div class="org-src-container">
<pre class="src src-sh">nim c -d:danger -d:<span style="color: #FD971F;">StartHue</span>=285 plotTotalChargeOverTime &amp;&amp; <span style="color: #E6DB74; font-weight: bold;">\</span>
<span style="color: #FD971F;">LEFT</span>=4.0 <span style="color: #FD971F;">FACET_MARGIN</span>=0.75 <span style="color: #FD971F;">ROT_ANGLE</span>=0.0 <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
         plotTotalChargeOverTime <span style="color: #E6DB74; font-weight: bold;">\</span>
         ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
         ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --interval 90 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --cutoffCharge 0 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --cutoffHits 500 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --calibFiles ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --calibFiles ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
         --applyRegionCut <span style="color: #E6DB74; font-weight: bold;">\</span>
         --timeSeries <span style="color: #E6DB74; font-weight: bold;">\</span>
         --useMedian <span style="color: #E6DB74; font-weight: bold;">\</span>
         --normalizeMedian <span style="color: #E6DB74; font-weight: bold;">\</span>
         --outpath ~/phd/Figs/behavior_over_time/plotTotalChargeOverTime/ <span style="color: #E6DB74; font-weight: bold;">\</span>
         --titleSuff <span style="color: #E6DB74;">&quot; &quot;</span> 
</pre>
</div>
<p>
We use a <code>titleSuff</code> suffix of a single space, because a) it&apos;s not
empty but b) we don&apos;t want an actual suffix (about the cut region etc.).
</p>


<p>
yielding
<img alt="background_median_charge_binned_90.0_min_filtered_crSilver.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/plotTotalChargeOverTime/background_median_charge_binned_90.0_min_filtered_crSilver.svg" />
among other things, with many more related plots to be found in:
<a href="./Figs/behavior_over_time/plotTotalChargeOverTime/">./Figs/behavior_over_time/plotTotalChargeOverTime/</a>
</p>
</div>
</div>
<div id="outline-container-sec:calib:causes_variability" class="outline-4">
<h4 id="sec:calib:causes_variability">  <a href="#sec:calib:causes_variability">  <span class="section-number-4">11.2.2.</span> Potential causes for the variability</a></h4>
<div id="text-sec:calib:causes_variability" class="outline-text-4">
<p>
One possible cause for the variability seen in the previous section is
the electronics of the detector readout. Either a floating ground or
unstable power supply can result in the activation thresholds of the
pixels moving – as was indeed observed – as mentioned in section
<a href="./cast.html#sec:cast:data_taking_woes">10.5</a>. Lesser versions of the problems discussed
in that section could theoretically explain the
variations. Specifically, in regards to the \cefe spectra showing
variation, the number of pixels and the amount of charge are directly
correlated. The number of pixels is plainly a clamped version of the
charge information. If electronics caused threshold variations, it
would both change the effective <code>ToT</code> value as well as the number of
pixels activated in the first place. Fortunately, the center chip also
contains the FADC, which allows for an independent measurement of the
effective charge generated below the grid and thus another indirect
measurement of the gas gain. By comparing how the mean position of the
\cefe spectra behave in the FADC data compared to the GridPix data we
can deduce if the GridPix behavior likely is due to real gas gain
changes or due to electronics.
</p>

<p>
Fig. <a href="#fig:calib:fe55_peak_pos_charge_pixel_fadc">4</a> shows the (normalized)
position of the \cefe photopeak based on a fit to the pixel, charge
and FADC spectrum (the latter based on the amplitudes of the FADC
signals). Aside from the variations in the FADC data in the 2017 data
(left) due to the changed FADC settings (more on that in
sec. <a href="./calibration.html#sec:calib:fadc">11.4</a>), the &apos;temporally local&apos; changes in all three
datasets are almost perfectly correlated. This implies a <i>real
physical origin</i> in the observed variation and not an electronic or
power supply origin.
</p>


<figure id="fig:calib:fe55_peak_pos_charge_pixel_fadc">
<img alt="time_vs_peak_pos.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_pos.svg" />

<figcaption>Figure 4: <span class="figure-number">Figure 40: </span>Normalized photopeak positions in the Run-2 data based on the charge (purple), pixel (green) and FADC (orange) spectra. The empty range in the middle is the period between Dec 2017 and Feb 2018. The strong changes in the FADC on the left are due to the different FADC settings. Beyond that the three sets of data are fully correlated, implying a physical origin in the variation. Compare how local (in time) features appear identical in each data.</figcaption>
</figure>

<p>
A physical change in the gas gain can either be caused by a change in
high voltage in the amplification region, a change in gas composition
or gas properties (assuming no change in the physical size of the
amplification gap, which is reasonable at least within Run-2 and Run-3
as the detector was not touched).
</p>

<p>
Firstly, the high voltage, while not logged to a file <sup>  <a id="fnr.2" href="#fn.2" class="footref" role="doc-backlink">2</a></sup>,
was visually inspected regularly and was always kept at the desired
voltages by the Iseg HV module within the operating window. It is a
very unlikely source of the
variability. <sup>  <a id="fnr.3" href="#fn.3" class="footref" role="doc-backlink">3</a></sup>
</p>

<p>
Secondly, there is no reason to believe the gas composition to be at
fault as a) the detector is used in an open loop at a constant gas
flow and b) it would then if anything show up as a sudden change in
detector properties upon a gas bottle change and not a continuous
change during operation.
</p>

<p>
This finally leaves the properties of the gas itself, for which three
variables are (partially) known:
</p>
<ol class="org-ol">
<li>the gas flow</li>
<li>the chamber pressure via the pressure controller on the outlet side</li>
<li>the temperature</li>
</ol>

<p>
The gas flow was at a relatively constant \(\SI{2}{\liter\per\hour}\). The
absolute value should not be too relevant, as the flow is small in
absolute terms and thus should have no effect on the gas properties in
the chamber as such (via gas flow related effects causing turbulence
or similar in the chamber). Its secondary impact is only one on
absolute gas pressure, which is controlled by the pressure controller,
which provides granular control. While also no log files were written
for the chamber pressure, visual inspection was also done regularly
and the pressure was at a constant \(\SI{1050}{mbar}\) at most varying
by \(\SI{1}{mbar}\) in rare cases, but certainly not in a way
correlating to the gas gain variations.
</p>

<p>
This leaves the temperature inside the chamber and in the
amplification region as the final plausible source of the
variations. As the temperature log files for the Septemboard were lost
due to a software bug (more on that in appendix
sec. <a href="./daq.html#sec:daq:temperature_readout">17.2.4</a>), there are two other sources of
temperature information. First of all the shift log of each morning
shift contains one temperature reading of the Septemboard, which
yields one value for every solar tracking. Second of all the CAST slow
control log files contain multiple different temperature readings in
one second intervals. Most notably the ambient temperature in the CAST
hall, which up to an offset (and some variation due to detector load
and cooling efficiency) should be equivalent to the gas
temperature. Fig. <a href="#fig:calib:correlation_ambient_temperature_gasgain_and_spectra">5</a>
shows the normalized temperature sensors in the CAST hall (excluding
the exterior temperature) during the Run-3 data taking period together
with the normalized peak position of the \cefe spectra in pixels
(black points), the temperature from the shift logs (blue points) and
the gas gain values of each chip (smaller points using the color
scale, based on \(\SI{90}{min}\) intervals per point). The blue points
of the temperature of the Septemboard recorded during each solar
tracking nicely follow the temperature trend of the ambient
temperature (<code>T_amb</code>) in the hall, as expected. Comparing the \cefe
spectra mean positions with the shift log temperatures does not allow
to draw meaningful conclusions about possible correlations, due to
lack of statistics. But the gas gains of each chip compared to the
temperature lines does imply an (imperfect) <i>inverse</i> correlation
between the temperature and the gas gain.
</p>

<p>
As discussed in theory sec. <a href="./theory_detector.html#sec:theory:gas_gain_polya">6.3.6</a> the expectation
for the gas gain given constant pressure is \(G ∝ e^α\) where the first
Townsend coefficient \(α\) scales with temperature by
</p>

\begin{equation}
\label{eq:calib:townsend_scaling_prop}
α ∝ \frac{1}{T} \exp\left(-\frac{1}{T}\right).
\end{equation}

<p>
The combination of the inverse relation to \(T\) and its negative
exponential is a monotonically increasing sublinear function (and not
decreasing as \(1/T\) would imply alone) in the relevant parameter
ranges. This should imply an increase in gas gain instead of the
apparent decrease we see for increasing temperatures. The kind of
scaling according to eq. \eqref{eq:calib:townsend_scaling_prop} was also
already experimentally measured for GridPix detectors by
L. Scharenberg in (<a href="./bibliography.html#citeproc_bib_item_191">Scharenberg 2019</a>). The implications seem to be that
the assumptions going into the \(α\) scaling must have been
violated. The septemboard detector in its – essentially open – gas
system is a non-trivial thermodynamic system due to the significant
heating of the Timepix ASICs and very small amplification region of
\(\SI{50}{μm}\) height enclosing a gas mass, where gas flow is
potentially inhibited.
</p>

<p>
This is not meant as a definitive statement about the origins of the
gas gain variations in the Septemboard detector data. <i>However</i>, it
clearly motivates the need for an even more in depth study of the
behavior of these detectors for different gas temperatures at constant
pressures (continuing the work of (<a href="./bibliography.html#citeproc_bib_item_191">Scharenberg 2019</a>)). More precise
logging of temperatures and pressures in future detectors is highly
encouraged. Further, a significantly improved cooling setup (to more
closely approach a region where temperature changes have a smaller
relative impact), or theoretically even a temperature controlled setup
(to avoid temperature changes in the first place) with known inlet gas
temperatures might be useful. This behavior is one of the most
problematic from a data analysis point of view and thus it should be
taken seriously for future endeavors.
</p>

<p>
See appendix <a href="./appendix_detector_time_behavior.html#sec:appendix:detector_time_behavior">25</a> for plots similar to
fig. <a href="#fig:calib:correlation_ambient_temperature_gasgain_and_spectra">5</a> for
the other periods of CAST data taking and a scatter plot of the center
chip gas gains against the ambient temperature directly. 
</p>


<figure id="fig:calib:correlation_ambient_temperature_gasgain_and_spectra">
<img alt="correlation_fePixel_all_chips_gasgain_period_2018-10-19.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_all_chips_gasgain_period_2018-10-19.svg" />

<figcaption>Figure 5: <span class="figure-number">Figure 41: </span>Normalized data for Run-3 of the temperature sensors from the CAST slow control log files compared to the behavior of the mean peak position in the \cefe pixel spectra (black points), the recovered temperature values recorded during each solar tracking (blue points) and the gas gain values computed based on \SI{90}{min} of data for each chip (smaller points using Viridis color scale). The shift log temperatures nicely follow the trend of the general temperatures. Gas gains and temperatures seem to be inversely correlated, providing a possible explanation for the detector behavior.</figcaption>
</figure>
</div>
<div id="outline-container-org1bf29c0" class="outline-5">
<h5 id="org1bf29c0">  <a href="#org1bf29c0">  <span class="section-number-5">11.2.2.1.</span> Extended thoughts on missing temperature log data   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-2-1" class="outline-text-5">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>THINK ABOUT WHETHER TO PUT INTO MAIN AGAIN / REMOVE EXTENDED</b></li>
</ul>

<p>
Note that even if the temperature logs were still available, it is not
obvious how they could lead to a correction that goes beyond the gas
gain binning in time that was eventually settled on. The variations
lead to gain and loss of information that cannot easily be corrected
for without introducing potential biases, especially because the
temperature sensor on the bottom side of the Septemboard does not
yield an absolute temperature inside the amplification region
anyway. While theoretically a fit correlating temperature to energy
calibration factors is thinkable it is not clear it would improve the
calibration over using gas gains binned in time, as the gas gain is
the physical result of temperature changes. The only interesting
aspect of it would be potentially higher time resolution than the time
binning required to have good statistics for a gas gain. Further,
temperature changes are not expected to usually occur on time scales
much shorter than of the order of one hour, if they are due to ambient
temperature changes. Still, it could be an interesting avenue to
explore by experimenting with the available slow control log
information on the ambient temperature as a proxy for the temperature
in the amplification region (same as the Septemboard temperature
sensors, but just with a larger offset and lack of detail regarding
local temperature changes due to water cooling related variations).
</p>
</div>
</div>
<div id="outline-container-orgea63a17" class="outline-5">
<h5 id="orgea63a17">  <a href="#orgea63a17">  <span class="section-number-5">11.2.2.2.</span> Further thoughts about variability   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-2-2" class="outline-text-5">
<p>
What if (<i>put on my crackpot helmet</i>):
At lower temperatures gas diffusion is less efficient. This might lead
to stronger effects of &quot;over pressure&quot; / less gas cycling between
below and above the grid. This could increase the pressure below the
grid as it is further away from an open system in a thermodynamic
sense. The higher the temperature the more flow via diffusion
exchanges gas below and above the grid, bringing the detector closer
to desired 1050 mbar operating window. Yeah right lol.
</p>
</div>
</div>
<div id="outline-container-sec:calib:behavior_over_time:thoughts_townsend" class="outline-5">
<h5 id="sec:calib:behavior_over_time:thoughts_townsend">  <a href="#sec:calib:behavior_over_time:thoughts_townsend">  <span class="section-number-5">11.2.2.3.</span> Thoughts about Townsend coefficient &amp; gas gain temperature dependence   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-sec:calib:behavior_over_time:thoughts_townsend" class="outline-text-5">
<p>
<b>NOTE</b>: This section was me trying to better understand the origin of
the Townsend coefficient and its temperature dependence. The results
have since been merged back into the theory part (about mean free path
and gas gain) and the main section above.
</p>

<p>
Some further discussions of the fact that our temperature vs. gain
data in
fig. <a href="#fig:calib:correlation_ambient_temperature_gasgain_and_spectra">5</a>
seems to imply an inverse proportionality between temperature and gas
gain from our data at CAST. So let&apos;s go back to our theoretical
expectation here and see what we learn.
</p>


<p>
The number of electrons after a distance \(x\) should be
</p>

<p>
\[
n = n_0 e^{αx}
\]
</p>

<p>
where \(α\) is the first Townsend coefficient, (<a href="./bibliography.html#citeproc_bib_item_190">Sauli 2014</a>)
(eq. 5.2 p. 146). The gas gain is just this divided by the initial
number \(n_0\).
</p>

<p>
Sauli on the definition of the first Townsend coefficient:
(<a href="./bibliography.html#citeproc_bib_item_190">Sauli 2014</a>) page 145 eq. 5.1:
</p>
<blockquote>
<p>
The mean free path for ionization λ is deﬁned as the average distance an electron
has to travel before having an ionizing collision; its inverse, α = λ⁻¹, is the
ionization or ﬁrst Townsend coefﬁcient, and represents the number of ion pairs
produced per unit length of drift; it relates to the ionization cross section through
the expression:
α = N σ<sub>i</sub>                              (eq 5.1)
where N is the number of molecules per unit volume.
As for other quantities in gaseous electronics, the Townsend coefﬁcient is
proportional to the gas density and therefore to the pressure P; the ratio α/P is a
sole function of the reduced ﬁeld E/P, as shown in Figure 5.19 for noble gases
(Druyvesteyn and Penning, 1940).
</p>
</blockquote>

<p>
Also from Sauli (<a href="./bibliography.html#citeproc_bib_item_190">Sauli 2014</a>) p. 151 is
fig. <a href="#fig:sauli_gas_gain_T_over_P">6</a>. The plot (data at least) is taken
from (<a href="./bibliography.html#citeproc_bib_item_6">Altunbas et al. 2003</a>) and shows a linear (or very shallow
exponential) behavior of the gain vs \(T/P\) with experimental data from
GEMs for COMPASS and Magboltz simulations as well.
</p>


<figure id="fig:sauli_gas_gain_T_over_P">
<img alt="fig_5_25_sauli_p151_gas_gain_vs_T_P.png" src="./figs/home/basti/phd/Figs/gas_physics/fig_5_25_sauli_p151_gas_gain_vs_T_P.png" />

<figcaption>Figure 6: <span class="figure-number">Figure 42: </span>Figure from <a href="cite:&amp;sauli2014gaseous">cite:&amp;sauli2014gaseous</a> (page 151) showing the gas gain dependence on the ratio of temperature and pressure.</figcaption>
</figure>

<p>
Further papers of interest:
</p>
<ul class="org-ul">
<li>(<a href="./bibliography.html#citeproc_bib_item_18">Aoyama 1985</a>) 
-&gt; Contains a mathematical derivation for a generalized first
Townsend coefficient relationship with S = E/N (where N is the
density and E the electric field).</li>
<li>(<a href="./bibliography.html#citeproc_bib_item_78">Davydov 2006</a>) contains a discussion about the first Townsend
coefficient for very low densities and thus also discussions about
the math etc.</li>
</ul>

<p>
Now, if we just go by our intuition from ideal gas physics we would
expect the following:
</p>

<p>
Assuming \(α = 1 / λ\) where \(λ\) is the mean free path. If the
temperature increases in a gas, the density decreases for constant
pressure \(p\) via
</p>

<p>
\[
p = ρ R_s T
\]
</p>

<p>
with the specific gas constant \(R_s\). A lower density necessarily
implies less particles per unit volume and thus a typically longer
path between interactions. This means \(λ\) increases and due to the
inverse relationship with \(α\), the first Townsend coefficient – and
by extension the gas gain – decreases.
</p>

<p>
This is even explicitly mentioned by that quote of Sauli above,
literally in the sentence
</p>
<blockquote>
<p>
As for other quantities in gaseous electronics, the Townsend coefﬁcient is
proportional to the gas density […]
</p>
</blockquote>

<p>
However, this is in stark contrast to
</p>
<ul class="org-ul">
<li>the screenshot of the fig. above, <a href="#fig:sauli_gas_gain_T_over_P">6</a></li>
<li>the fact that Jochen kept going on about the gas gain being
essentially \(G ∝ e^{T/P}\)
-&gt; This is clearly wrong, see both below and generally the fact that
neither Magboltz nor Lucian&apos;s MSc measurements indicate anything of
the sorts of an exponential increase with temperature.</li>
<li>and my Magboltz simulations,
sec. <a href="sec:calib:behavior_over_time:magboltz_sim">11.2.2.3.2</a></li>
</ul>

<p>
After a discussion with Lucian today <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-10-23 Mon&gt;</span></span>, I&apos;m a little
bit more illuminated. In his MSc thesis (<a href="./bibliography.html#citeproc_bib_item_191">Scharenberg 2019</a>) goes through
a derivation based on (<a href="./bibliography.html#citeproc_bib_item_85">Engel and Marton 1965</a>) for the temperature
dependence of the first Townsend coefficient. Starting from the
argument above about \(α = 1/λ\) and then continuing with the
requirement to accumulate enough energy to produce secondary
ionization events, \(e |\vec{E}| l \geq eV_i\) with the ionization
potential \(V_i\) for the gas mixture and \(l\) for the forward distance
of an electron under the electric field \(|\vec{E}|\). This distance
</p>

<p>
\[
l = \frac{V_i}{|\vec{E}|} 
\]
</p>

<p>
can be compared to the mean free path \(λ\) of the electron
</p>

<p>
\[
\mathcal{N} = e^{-l/λ}
\]
</p>

<p>
where \(\mathcal{N}\) is the relative number of colliding electrons with
\(l &gt; λ\). This allows to define the probability of finding \(1/l\)
collisions per unit distance to be
</p>

<p>
\[
P(l) \frac{1}{λ} e^{-l / λ} = α
\]
</p>

<p>
which is precisely the definition of the first Townsend coefficient,
\(α\).
</p>

<p>
The mean free path \(λ\) can be related to the pressure \(p\), temperature
\(T\) and cross section of the electron in the gas, \(σ\):
</p>

<p>
\[
λ = \frac{kT}{pσ}.
\]
</p>

<p>
Inserting this into the above definition of \(α\) yields:
</p>

<p>
\[
α(T) = \frac{pσ}{kT} \exp\left( - \frac{V_i}{|\vec{E}|}\frac{pσ}{kT}\right)
\]
</p>

<p>
which allows to analytically compute the temperature dependence of the
first Townsend coefficient, which we&apos;ll do in
sec. <a href="sec:calib:behavior_over_time:townsend_coefficient_temp_scaling">11.2.2.3.1</a>. The
expression now is actually similar to (eq. 5.4) in
(<a href="./bibliography.html#citeproc_bib_item_190">Sauli 2014</a>). It seems to roughly match the Magboltz
simulations.
</p>

<p>
Note though that this dependence is &apos;fragile&apos;, as it is a higher order
dependence on \(T\) assuming idealized constant parameters for \(p\) and
\(σ\) and gas composition. In reality it is easily thinkable that gas
contamination and slight variations in pressure can change the results
from this result.
</p>
</div>
<ol class="org-ol">
<li><a id="sec:calib:behavior_over_time:townsend_coefficient_temp_scaling"> </a>Applying Lucians (eq. 5.17) formula and plotting it<br />
<div id="text-sec:calib:behavior_over_time:townsend_coefficient_temp_scaling" class="outline-text-6">
<p>
Lucian gives the following formula for the temperature dependence of
the first Townsend coefficient:
</p>

<p>
\[
α(T) = \frac{pσ}{kT} \exp\left( - \frac{V_i}{|\vec{E}|}\frac{pσ}{kT}\right)
\]
</p>

<p>
where \(p\) is the gas pressure, \(σ\) the cross section of electrons with
the gas at the relevant energies, \(V_i\) the ionization potential for
the gas, \(|\vec{E}|\) the electric field strength.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math, ggplotnim, sequtils

<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">V_i</span> = <span style="font-style: italic;">15</span>.<span style="font-style: italic;">7</span>.<span style="color: #66D9EF;">V</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">Lucian gives this ionization potential next to fig. 5.4</span>
defUnit<span style="color: #AE81FF;">(</span>kV•cm⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>cm⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">townsend</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">P</span>: <span style="color: #66D9EF;">Pressure</span>; <span style="color: #66D9EF;">A</span>: <span style="color: #66D9EF;">Area</span><span style="color: #AE81FF;">](</span>p: <span style="color: #66D9EF;">P</span>, σ: <span style="color: #66D9EF;">A</span>, <span style="color: #66D9EF;">T</span>: <span style="color: #66D9EF;">Kelvin</span>, <span style="color: #66D9EF;">E</span>: kV•cm⁻¹<span style="color: #AE81FF;">)</span>: cm⁻¹ =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">arg </span>= <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">V_i</span> * p * σ<span style="color: #AE81FF;">)</span> / <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span> * k_B * <span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> arg
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>p * σ / <span style="color: #66D9EF;">(</span>k_B * <span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">)</span> * exp<span style="color: #66D9EF;">(</span> -arg <span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>.to<span style="color: #AE81FF;">(</span>cm⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> townsend<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1013</span>.<span style="font-style: italic;">25</span>.mbar, <span style="font-style: italic;">500</span>.<span style="color: #66D9EF;">MegaBarn</span>, <span style="font-style: italic;">273</span>.<span style="font-style: italic;">15</span>.<span style="color: #66D9EF;">K</span>, <span style="font-style: italic;">60</span>.kV•cm⁻¹<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">temps </span>= linspace<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">100</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">1000</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">0 to 100 °C</span>
<span style="color: #75715E;">#</span><span style="color: #75715E;">let temps = linspace(-273.15, 10000.0, 1000) # all of da range!</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">αs </span>= temps.mapIt<span style="color: #AE81FF;">(</span>townsend<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1013</span>.<span style="font-style: italic;">25</span>.mbar, <span style="font-style: italic;">500</span>.<span style="color: #66D9EF;">MegaBarn</span>, <span style="color: #A6E22E;">(</span><span style="font-style: italic;">273</span>.<span style="font-style: italic;">15</span> + it<span style="color: #A6E22E;">)</span>.<span style="color: #66D9EF;">K</span>, <span style="font-style: italic;">60</span>.kV•cm⁻¹<span style="color: #66D9EF;">)</span>.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span>temps, αs<span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;temps&quot;</span>, <span style="color: #E6DB74;">&quot;αs&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Gas temperature [°C]&quot;</span><span style="color: #AE81FF;">)</span> +
  ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Townsend coefficient [cm⁻¹]&quot;</span><span style="color: #AE81FF;">)</span> +
  theme_font_scale<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>, family = <span style="color: #E6DB74;">&quot;serif&quot;</span><span style="color: #AE81FF;">)</span> +
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/gas_physics/townsend_coefficient_temperature_scaling_lucian.pdf&quot;</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</li>
<li><a id="sec:calib:behavior_over_time:magboltz_sim"> </a>Simulations with Magboltz<br />
<div id="text-sec:calib:behavior_over_time:magboltz_sim" class="outline-text-6">
<p>
I wrote a simple interfacing library with Magboltz for Nim:
</p>

<p>
<a href="https://github.com/SciNim/NimBoltz">https://github.com/SciNim/NimBoltz</a>
<a href="./../CastData/ExternCode/NimBoltz/nimboltz.nim">./../CastData/ExternCode/NimBoltz/nimboltz.nim</a>
</p>

<p>
and I ran simulations at different temperatures, but same pressure and
the first Townsend coefficient (based on the steady state simulation,
which should be the correct one for high fields
</p>
<blockquote>
<p>
The simulation of avalanche gain detectors at high field requires the use of SST Townsend parameters.
</p>
</blockquote>
<p>
from <a href="https://magboltz.web.cern.ch/magboltz/usage.html">https://magboltz.web.cern.ch/magboltz/usage.html</a> and line 256 in
<a href="./../src/Magboltz/magboltz-11.17.f">./../src/Magboltz/magboltz-11.17.f</a>.
</p>

<p>
These seem to indicate that the coefficient should increase.
</p>

<p>
<b>Why?</b>
-&gt; See above!
</p>
</div>
</li>
</ol>
</div>
<div id="outline-container-orga9390a5" class="outline-5">
<h5 id="orga9390a5">  <a href="#orga9390a5">  <span class="section-number-5">11.2.2.4.</span> <span class="todo TODO">TODO</span> Note about variability in GridPix 1   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-2-4" class="outline-text-5">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>CREATE TEMPERATURE PLOT OF TEMP IN CAST HALL DURING GRIDPIX1
DATA!</b>
-&gt; for noexport this is very useful info.</li>
</ul>

<p>
Christoph <b>did</b> see variations in his gas gain as well!! Fig. 9.7 of
his thesis and he <b>even notes it is likely due to temperature effects
in the hall</b>!
The big difference is just that the absolute variations were quite a
bit smaller.
</p>

<p>
Why this has never been on the mind of people like Jochen I will never
understand…
</p>

<p>
Further: in fig. 7.26 he even sees significant differences in the gas
gain for different targets of CDL data. But he concludes (by taking a
cut) that this is due to multiple electrons in the same hole instead
of real changes. Likely a combination of both I assume.
</p>
</div>
</div>
<div id="outline-container-org094637a" class="outline-5">
<h5 id="org094637a">  <a href="#org094637a">  <span class="section-number-5">11.2.2.5.</span> Generate plot of \cefe peak position   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-2-5" class="outline-text-5">
<p>
From my zsh history:
</p>
<div class="org-src-container">
<pre class="src src-nil">: 1672709064:0;./mapSeptemTempToFePeak ~/CastData/data/CalibrationRuns2017_Reco.h5 --inputs fePixel --inputs feCharge --inputs feFadc
: 1672709066:0;evince /t/time_vs_peak_pos.pdf
: 1672709148:0;cp /t/time_vs_peak_pos.pdf ~/phd/Figs/time_vs_55fe_peak_pos_2017.pdf
</pre>
</div>

<p>
First of all we need to make sure our calibration HDF5 file not only
has the reconstructed \cefe spectra including their fits, but also the
fits for the FADC spectra. If that is not the case:
</p>

<ol class="org-ol">
<li>Make sure the FADC data is fully reconstructed:</li>
</ol>
<div class="org-src-container">
<pre class="src src-sh">reconstruction -i ~/CastData/data/CalibrationRuns2017_Reco.h5 --only_fadc
</pre>
</div>
<ol class="org-ol">
<li>Now redo the \cefe fits:</li>
</ol>
<div class="org-src-container">
<pre class="src src-sh">reconstruction -i ~/CastData/data/CalibrationRuns2017_Reco.h5 --only_fe_spec
</pre>
</div>

<p>
With that done we can create a plot of all normalized \cefe peak
positions and compare it to the temperatures recovered from the CAST
shift forms of the septemboard. 
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">WRITE_PLOT_CSV</span>=true <span style="color: #FD971F;">USE_TEX</span>=true ./mapSeptemTempToFePeak <span style="color: #E6DB74; font-weight: bold;">\</span>
<span style="color: #75715E;">#             </span><span style="color: #75715E;">~/CastData/data/CalibrationRuns2017_Reco.h5 \</span>
                    /mnt/1TB/CAST/2017/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
             --inputs fePixel --inputs feCharge --inputs feFadc <span style="color: #E6DB74; font-weight: bold;">\</span>
             --outpath ~/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/
</pre>
</div>

<p>
Note that the plot that we include in the thesis from the following created:
</p>
<ul class="org-ul">
<li>  <img alt="time_vs_peak_pos.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_pos.svg" /></li>
<li>  <img alt="time_vs_peak_pos_feFadc.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_pos_feFadc.svg" /></li>
<li>  <img alt="time_vs_peak_norm_by_temp.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_norm_by_temp.svg" /></li>
<li>  <img alt="time_vs_peak_pos_fePixel.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_pos_fePixel.svg" /></li>
<li>  <img alt="time_vs_peak_temp_normed_comparison.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_temp_normed_comparison.svg" /></li>
<li>  <img alt="time_vs_peak_pos_feCharge.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/mapSeptemTempToFePeak/time_vs_peak_pos_feCharge.svg" /></li>
</ul>
<p>
is actually one of the ones that does not include the septemboard
temperatures from the shift forms. That&apos;s because of the much more in
depth plot below of course!
</p>
</div>
</div>
<div id="outline-container-orga608fdc" class="outline-5">
<h5 id="orga608fdc">  <a href="#orga608fdc">  <span class="section-number-5">11.2.2.6.</span> Generate plot of ambient CAST temp against 55Fe peaks   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-2-6" class="outline-text-5">
<p>
First we run the CAST log reader to get the temperature data as a
simple CSV file (by default just written to
<code>/tmp/temperatures_cast.csv</code>):
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/LogReader <span style="color: #75715E;"># </span><span style="color: #75715E;">&lt;- directory of TimepixAnalysis</span>
./cast_log_reader sc -p ../resources/LogFiles/SClogs -s Version.idx
</pre>
</div>
<p>
Note that this requires the slow control files for the relevant times
to be present in the <code>SCLogs</code> directory!
</p>


<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>MOVE CODE OVER TO TPA, DEDUCTION TO STATUS, MAYBE KEEP HERE AS
WELL?</b>
-&gt; well, the interesting stuff will go straight into the thesis, so
there is less</li>
</ul>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>strutils, sequtils, times, stats, strformat<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> os <span style="color: #F92672;">except</span> <span style="color: #66D9EF;">FileInfo</span>
<span style="color: #F92672;">import</span> ggplotnim, nimhdf5
<span style="color: #F92672;">import</span> ingrid / tos_helpers
<span style="color: #F92672;">import</span> ingrid / ingrid_types

<span style="color: #F92672;">type</span>
  <span style="color: #66D9EF;">FeFileKind</span> = <span style="color: #F92672;">enum</span>
    fePixel, feCharge, feFadc

<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">UseTex</span> = getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;USE_TEX&quot;</span>, <span style="color: #E6DB74;">&quot;false&quot;</span><span style="color: #AE81FF;">)</span>.parseBool
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Width</span> = getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;WIDTH&quot;</span>, <span style="color: #E6DB74;">&quot;1000&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Height</span> = getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;HEIGHT&quot;</span>, <span style="color: #E6DB74;">&quot;600&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat

<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">Peak</span> = <span style="color: #E6DB74;">&quot;μ&quot;</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">PeakNorm</span> = <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">UseTex</span>: r<span style="color: #E6DB74;">&quot;$μ/μ_{\text{max}}$&quot;</span> <span style="color: #F92672;">else</span>: <span style="color: #E6DB74;">&quot;μ/μ_max&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">TempPeak</span> = <span style="color: #E6DB74;">&quot;(μ/T) / max&quot;</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">T_amb</span> = <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">UseTex</span>: r<span style="color: #E6DB74;">&quot;$T_{\text{amb}}$&quot;</span> <span style="color: #F92672;">else</span>: <span style="color: #E6DB74;">&quot;T_amb&quot;</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readFePeaks</span><span style="color: #AE81FF;">(</span>files: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span>, feKind: <span style="color: #66D9EF;">FeFileKind</span> = fePixel<span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">kalphaPix </span>= <span style="font-style: italic;">10</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">kalphaCharge </span>= <span style="font-style: italic;">4</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">parPrefix </span>= <span style="color: #E6DB74;">&quot;p&quot;</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">dateStr </span>= <span style="color: #E6DB74;">&quot;yyyy-MM-dd&apos;.&apos;HH:mm:ss&quot;</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">example: 2017-12-04.13:39:45</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dset</span>: <span style="color: #66D9EF;">string</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">kalphaIdx</span>: <span style="color: #66D9EF;">int</span>
  <span style="color: #F92672;">case</span> feKind
  <span style="color: #F92672; font-style: italic;">of</span> fePixel:
    kalphaIdx = kalphaPix
    dset = <span style="color: #E6DB74;">&quot;FeSpectrum&quot;</span>
  <span style="color: #F92672; font-style: italic;">of</span> feCharge:
    kalphaIdx = kalphaCharge
    dset = <span style="color: #E6DB74;">&quot;FeSpectrumCharge&quot;</span>
  <span style="color: #F92672; font-style: italic;">of</span> feFadc:
    kalphaIdx = kalphaCharge
    dset = <span style="color: #E6DB74;">&quot;FeSpectrumFadcPlot&quot;</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">raw dataset is `</span><span style="color: #AE81FF;">minvals</span><span style="color: #75715E;">` instead of `</span><span style="color: #AE81FF;">FeSpectrumFadc</span><span style="color: #75715E;">`</span>

  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">h5files </span>= files.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">H5open</span><span style="color: #66D9EF;">(</span>it, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">fileInfos </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">FileInfo</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">for</span> h5f <span style="color: #F92672;">in</span> <span style="color: #F92672;">mitems</span><span style="color: #AE81FF;">(</span>h5files<span style="color: #AE81FF;">)</span>:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fi </span>= h5f.getFileInfo<span style="color: #AE81FF;">()</span>
    fileInfos.<span style="color: #F92672;">add</span> fi
  <span style="color: #F92672;">var</span>
    peakSeq = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
    dateSeq = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>h5f, fi<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> zip<span style="color: #AE81FF;">(</span>h5files, fileInfos<span style="color: #AE81FF;">)</span>:
    <span style="color: #F92672;">for</span> r <span style="color: #F92672;">in</span> fi.runs:
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">group </span>= h5f<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span>recoBase<span style="color: #A6E22E;">()</span> &amp; $r<span style="color: #66D9EF;">)</span>.grp_str<span style="color: #AE81FF;">]</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">chpGrpName </span>= <span style="color: #F92672;">if</span> feKind <span style="color: #F92672;">in</span> <span style="color: #AE81FF;">{</span>fePixel, feCharge<span style="color: #AE81FF;">}</span>: group.name / <span style="color: #E6DB74;">&quot;chip_3&quot;</span>
                       <span style="color: #F92672;">else</span>: group.name / <span style="color: #E6DB74;">&quot;fadc&quot;</span>
      peakSeq.<span style="color: #F92672;">add</span> h5f<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span>chpGrpName / dset<span style="color: #66D9EF;">)</span>.dset_str<span style="color: #AE81FF;">]</span>.attrs<span style="color: #AE81FF;">[</span>
        parPrefix &amp; $kalphaIdx, <span style="color: #66D9EF;">float</span>
      <span style="color: #AE81FF;">]</span>
      dateSeq.<span style="color: #F92672;">add</span> parseTime<span style="color: #AE81FF;">(</span>group.attrs<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;dateTime&quot;</span>, <span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span>,
                            dateStr,
                            utc<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>.toUnix.<span style="color: #66D9EF;">float</span>
  <span style="color: #FD971F;">result</span> = toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span> <span style="color: #66D9EF;">Peak</span> : peakSeq,
                  <span style="color: #E6DB74;">&quot;Timestamp&quot;</span> : dateSeq <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .arrange<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, <span style="color: #66D9EF;">SortOrder</span>.<span style="color: #66D9EF;">Ascending</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #66D9EF;">PeakNorm</span> ~ idx<span style="color: #A6E22E;">(</span><span style="color: #66D9EF;">Peak</span><span style="color: #A6E22E;">)</span> / <span style="color: #F92672;">max</span><span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #66D9EF;">Peak</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span>,
            f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Type&quot;</span> &lt;- $feKind<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">toDf</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span>: <span style="color: #F92672;">object</span><span style="color: #AE81FF;">](</span>data: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #E6DB74;">## Converts a seq of objects that (may only contain scalar fields) to a DF</span>
  <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> i, d <span style="color: #F92672;">in</span> data:
    <span style="color: #F92672;">for</span> field, val <span style="color: #F92672;">in</span> <span style="color: #F92672;">fieldPairs</span><span style="color: #AE81FF;">(</span>d<span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">if</span> field <span style="color: #F92672;">notin</span> <span style="color: #FD971F;">result</span>:
        <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span>field<span style="color: #AE81FF;">]</span> = newColumn<span style="color: #AE81FF;">(</span>toColKind<span style="color: #66D9EF;">(</span><span style="color: #F92672;">type</span><span style="color: #A6E22E;">(</span>val<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>, data.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>
      <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span>field, i<span style="color: #AE81FF;">]</span> = val
    
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readGasGainSliceData</span><span style="color: #AE81FF;">(</span>files: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =     
  <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> files:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5file</span><span style="color: #AE81FF;">(</span>f, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fInfo </span>= h5f.getFileInfo<span style="color: #AE81FF;">()</span>
    <span style="color: #F92672;">for</span> r <span style="color: #F92672;">in</span> fInfo.runs:
      <span style="color: #F92672;">for</span> c <span style="color: #F92672;">in</span> fInfo.chips:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">group </span>= recoDataChipBase<span style="color: #AE81FF;">(</span>r<span style="color: #AE81FF;">)</span> &amp; $c
        <span style="color: #F92672;">var</span> <span style="color: #FD971F;">gainSlicesDf </span>= h5f<span style="color: #AE81FF;">[</span>group &amp; <span style="color: #E6DB74;">&quot;/gasGainSlices90&quot;</span>, <span style="color: #66D9EF;">GasGainIntervalResult</span><span style="color: #AE81FF;">]</span>.toDf
        gainSlicesDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Chip&quot;</span><span style="color: #AE81FF;">]</span> = c
        gainSlicesDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Run&quot;</span><span style="color: #AE81FF;">]</span> = r
        gainSlicesDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;File&quot;</span><span style="color: #AE81FF;">]</span> = f
        <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> gainSlicesDf
    <span style="color: #F92672;">discard</span> h5f.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span>

<span style="color: #F92672;">const</span> <span style="color: #FD971F;">periods </span>= <span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;2017-10-30&quot;</span>, <span style="color: #E6DB74;">&quot;2017-12-23&quot;</span><span style="color: #66D9EF;">)</span>,
                 <span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;2018-02-15&quot;</span>, <span style="color: #E6DB74;">&quot;2018-04-22&quot;</span><span style="color: #66D9EF;">)</span>,
                 <span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;2018-10-19&quot;</span>, <span style="color: #E6DB74;">&quot;2018-12-21&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">toPeriod</span><span style="color: #AE81FF;">(</span>x: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">string</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">date </span>= x.fromUnix<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> p <span style="color: #F92672;">in</span> periods:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t0 </span>= p<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.parseTime<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;YYYY-MM-dd&quot;</span>, utc<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t1 </span>= p<span style="color: #AE81FF;">[</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.parseTime<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;YYYY-MM-dd&quot;</span>, utc<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">if</span> date &gt;= t0 <span style="color: #F92672;">and</span> date &lt;= t1: <span style="color: #F92672;">return</span> p<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>
  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">mapToPeriod</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, timeCol: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = df.mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span> -&gt; <span style="color: #66D9EF;">string</span>: <span style="color: #E6DB74;">&quot;RunPeriod&quot;</span> ~ toPeriod<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span>timeCol<span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">bool</span>: `<span style="color: #66D9EF;">RunPeriod</span>`.<span style="color: #F92672;">len</span> &gt; <span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readSeptemTemps</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">TempFile</span> = <span style="color: #E6DB74;">&quot;/home/basti/CastData/ExternCode/TimepixAnalysis/resources/cast_2017_2018_temperatures.csv&quot;</span>
  <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">OrgFormat</span> = <span style="color: #E6DB74;">&quot;&apos;&lt;&apos;yyyy-MM-dd ddd H:mm&apos;&gt;&apos;&quot;</span>
  <span style="color: #FD971F;">result</span> = toDf<span style="color: #AE81FF;">(</span>readCsv<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">TempFile</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>c<span style="color: #E6DB74;">&quot;Temp / °&quot;</span> != <span style="color: #E6DB74;">&quot;-&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span><span style="color: #AE81FF;">]</span> = <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Date&quot;</span><span style="color: #AE81FF;">]</span>.toTensor<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>.map_inline<span style="color: #AE81FF;">(</span>parseTime<span style="color: #66D9EF;">(</span>x, <span style="color: #66D9EF;">OrgFormat</span>, utc<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span>.toUnix<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readCastTemps</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/temperatures_cast.csv&quot;</span><span style="color: #AE81FF;">)</span>
    <span style="color: #75715E;">#</span><span style="color: #75715E;">.filter(f{float: `</span><span style="color: #AE81FF;">Time</span><span style="color: #75715E;">` &gt;= t0 and `</span><span style="color: #AE81FF;">Time</span><span style="color: #75715E;">` &lt;= t1})</span>
    .group_by<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Temperature&quot;</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;TempNorm&quot;</span> ~ `<span style="color: #66D9EF;">TempVal</span>` / <span style="color: #F92672;">max</span><span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;TempVal&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`<span style="color: #66D9EF;">Temperature</span>` != <span style="color: #E6DB74;">&quot;T_ext&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">newKeys </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">string</span>, <span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">UseTex</span>:
    <span style="color: #FD971F;">result</span> = <span style="color: #FD971F;">result</span>.mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">string</span>: <span style="color: #E6DB74;">&quot;Temperature&quot;</span> ~ <span style="color: #A6E22E;">(</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">suff </span>= `<span style="color: #66D9EF;">Temperature</span>`.split<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;_&quot;</span><span style="color: #E6DB74;">)[</span><span style="font-style: italic;">1</span><span style="color: #E6DB74;">]</span> 
      r<span style="color: #E6DB74;">&quot;$T_{\text{&quot;</span> &amp; suff &amp; <span style="color: #E6DB74;">&quot;}}$&quot;</span><span style="color: #A6E22E;">)</span>
    <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Resulting DF: &quot;</span>, <span style="color: #FD971F;">result</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">toPeriod</span><span style="color: #AE81FF;">(</span>v: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">string</span> =
  <span style="color: #FD971F;">result</span> = v.<span style="color: #66D9EF;">int</span>.fromUnix.format<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;dd/MM/YYYY&quot;</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">keepEvery</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, num: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #E6DB74;">## Keeps only every `</span><span style="color: #AE81FF;">num</span><span style="color: #E6DB74;">` row of the data frame</span>
  <span style="color: #FD971F;">result</span> = df
  <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;idxMod&quot;</span><span style="color: #AE81FF;">]</span> = toSeq<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span> ..&lt; df.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #FD971F;">result</span>.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span> -&gt; <span style="color: #66D9EF;">bool</span>: `idxMod` <span style="color: #F92672;">mod</span> num == <span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotCorrelationPerPeriod</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, kind: <span style="color: #66D9EF;">FeFileKind</span>, gainDf, dfCastTemp, dfTemp: <span style="color: #66D9EF;">DataFrame</span>,
                              period, outpath = <span style="color: #E6DB74;">&quot;/tmp&quot;</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t0 </span>= df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">min</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t1 </span>= df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">max</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfCastTemp </span>= dfCastTemp
    .keepEvery<span style="color: #AE81FF;">(</span><span style="font-style: italic;">50</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: `<span style="color: #66D9EF;">Time</span>` &gt;= t0 <span style="color: #F92672;">and</span> `<span style="color: #66D9EF;">Time</span>` &lt;= t1<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>  
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfTemp </span>= dfTemp
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: `<span style="color: #66D9EF;">Timestamp</span>` &gt;= t0 <span style="color: #F92672;">and</span> `<span style="color: #66D9EF;">Timestamp</span>` &lt;= t1<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">gainDf </span>= gainDf
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: `tStart` &gt;= t0 <span style="color: #F92672;">and</span> `tStart` &lt;= t1<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;gainNorm&quot;</span> ~ `<span style="color: #66D9EF;">G</span>` / <span style="color: #F92672;">max</span><span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;G&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> gainDf

  <span style="color: #E6DB74;">## XXX: combine point like data for legend?</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">let dfC = bind_rows([(&quot;Fe55&quot;, df), (&quot;SeptemTemp&quot;, dfTemp)], &quot;Type&quot;)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">plt </span>= ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, <span style="color: #66D9EF;">PeakNorm</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_line<span style="color: #AE81FF;">(</span>data = dfCastTemp, aes = aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Time&quot;</span>, <span style="color: #E6DB74;">&quot;TempNorm&quot;</span>, color = <span style="color: #E6DB74;">&quot;Temperature&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_point<span style="color: #AE81FF;">()</span> +
    scale_x_continuous<span style="color: #AE81FF;">(</span>labels = toPeriod<span style="color: #AE81FF;">)</span> 

  <span style="color: #F92672;">if</span> dfTemp.<span style="color: #F92672;">len</span> &gt; <span style="font-style: italic;">0</span>: <span style="color: #75715E;"># </span><span style="color: #75715E;">only if septemboard data available in this period</span>
    plt = plt + geom_point<span style="color: #AE81FF;">(</span>data = dfTemp, aes = aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, f<span style="color: #A6E22E;">{</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Temp / °&quot;</span><span style="color: #E6DB74;">)</span> / <span style="color: #F92672;">max</span><span style="color: #E6DB74;">(</span>col<span style="color: #FD971F;">(</span><span style="color: #E6DB74;">&quot;Temp / °&quot;</span><span style="color: #FD971F;">)</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, color = <span style="color: #E6DB74;">&quot;blue&quot;</span><span style="color: #AE81FF;">)</span>

  

  <span style="color: #F92672;">block</span> <span style="color: #66D9EF;">AllChips</span>:
    plt + geom_point<span style="color: #AE81FF;">(</span>data = gainDf, aes = aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;tStart&quot;</span>, <span style="color: #E6DB74;">&quot;gainNorm&quot;</span>, color = gradient<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;Chip&quot;</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">7</span>, size = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Correlation between temperatures (Septem = blue points) \\&amp; 55Fe position &quot;</span> &amp; $kind &amp;
        <span style="color: #E6DB74;">&quot; (black) and gas gains by chip&quot;</span>, titleFont = font<span style="color: #66D9EF;">(</span><span style="font-style: italic;">11</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, textWidth = <span style="font-style: italic;">677</span>.<span style="font-style: italic;">3971</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">the `</span><span style="color: #AE81FF;">\textheight</span><span style="color: #75715E;">`, want to insert in landscape</span>
                  width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +
      margin<span style="color: #AE81FF;">(</span>bottom = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outpath}/correlation_{kind}_all_chips_gasgain_period_{period}.pdf&quot;</span>,
              width = <span style="font-style: italic;">1000</span>, height = <span style="font-style: italic;">600</span>,
              useTeX = <span style="color: #66D9EF;">UseTeX</span>, standalone = <span style="color: #66D9EF;">UseTeX</span><span style="color: #AE81FF;">)</span>                                                                              

  <span style="color: #F92672;">block</span> <span style="color: #66D9EF;">CenterChip</span>:
    gainDf = gainDf.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`<span style="color: #66D9EF;">Chip</span>` == <span style="font-style: italic;">3</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    plt + geom_point<span style="color: #AE81FF;">(</span>data = gainDf, aes = aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;tStart&quot;</span>, <span style="color: #E6DB74;">&quot;gainNorm&quot;</span><span style="color: #66D9EF;">)</span>, color = <span style="color: #E6DB74;">&quot;purple&quot;</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">7</span>, size = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> + 
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Correlation between temperatures (Septem = blue points) \\&amp; 55Fe position &quot;</span> &amp; $kind &amp;
        <span style="color: #E6DB74;">&quot; (black) and gas gains (chip3) in purple&quot;</span>, titleFont = font<span style="color: #66D9EF;">(</span><span style="font-style: italic;">11</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, textWidth = <span style="font-style: italic;">677</span>.<span style="font-style: italic;">3971</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">the `</span><span style="color: #AE81FF;">\textheight</span><span style="color: #75715E;">`, want to insert in landscape</span>
                 width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outpath}/correlation_{kind}_period_{period}.pdf&quot;</span>, width = <span style="font-style: italic;">1000</span>, height = <span style="font-style: italic;">600</span>,
             useTeX = <span style="color: #66D9EF;">UseTeX</span>, standalone = <span style="color: #66D9EF;">UseTeX</span><span style="color: #AE81FF;">)</span>                                   

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotCorrelation</span><span style="color: #AE81FF;">(</span>files: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span>, kind: <span style="color: #66D9EF;">FeFileKind</span>, gainDf, dfCastTemp, dfTemp: <span style="color: #66D9EF;">DataFrame</span>,
                     outpath = <span style="color: #E6DB74;">&quot;/tmp&quot;</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= readFePeaks<span style="color: #AE81FF;">(</span>files, feCharge<span style="color: #AE81FF;">)</span>
    .mapToPeriod<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span><span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>df.group_by<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;RunPeriod&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
    plotCorrelationPerPeriod<span style="color: #AE81FF;">(</span>subDf, kind, gainDf, dfCastTemp, dfTemp, tup<span style="color: #66D9EF;">[</span><span style="font-style: italic;">0</span><span style="color: #66D9EF;">][</span><span style="font-style: italic;">1</span><span style="color: #66D9EF;">]</span>.toStr, outpath<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotTempVsGain</span><span style="color: #AE81FF;">(</span>dfCastTemp, gainDf: <span style="color: #66D9EF;">DataFrame</span>, outpath: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span> =    
  <span style="color: #E6DB74;">## Now let&apos;s plot the actual gas gain against the temperature in each slice.</span>
  <span style="color: #E6DB74;">## Only for the center chip.</span>
  <span style="color: #E6DB74;">## 1. compute mean temperature within time associated with each gain value</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">dfCastTemp</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">gainDf</span>
  <span style="color: #E6DB74;">## NOTE: We do not compute the mean temperature associated with the</span>
  <span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">mapGainToTemp</span><span style="color: #AE81FF;">(</span>gainDf, dfCastTemp: <span style="color: #66D9EF;">DataFrame</span>, period: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t0G </span>= gainDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;tStart&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">min</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">t1G </span>= gainDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;tStop&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">max</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">filter temperature data to relevant range</span>
    <span style="color: #F92672;">echo</span> dfCastTemp.<span style="color: #F92672;">isNil</span>
    <span style="color: #F92672;">echo</span> dfCastTemp
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfF </span>= dfCastTemp
       .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span>: `<span style="color: #66D9EF;">Time</span>` &gt;= t0G <span style="color: #F92672;">and</span> `<span style="color: #66D9EF;">Time</span>` &lt;= t1G<span style="color: #66D9EF;">}</span>,
               f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">bool</span>: `<span style="color: #66D9EF;">Temperature</span>` == <span style="color: #66D9EF;">T_amb</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
      
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">cT</span>: <span style="color: #66D9EF;">RunningStat</span>    
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ambT </span>= dfF<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;TempVal&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">time </span>= dfF<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Time&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span>    
  
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">j </span>= <span style="font-style: italic;">0</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">gDf </span>= gainDf.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span> -&gt; <span style="color: #66D9EF;">bool</span>: `<span style="color: #66D9EF;">Chip</span>` == <span style="font-style: italic;">3</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">temps </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>gDf.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>
    <span style="color: #E6DB74;">## we now walk all temperatures and accumulate them in a `</span><span style="color: #AE81FF;">RunningStat</span><span style="color: #E6DB74;">` to compute</span>
    <span style="color: #E6DB74;">## the mean within `</span><span style="color: #AE81FF;">tStart</span><span style="color: #E6DB74;">` and `</span><span style="color: #AE81FF;">tStop</span><span style="color: #E6DB74;">` (by `</span><span style="color: #AE81FF;">tStart</span><span style="color: #E6DB74;">` of the next slice).</span>
    <span style="color: #E6DB74;">## First and last are just copied from ambient temperature values.</span>
    temps<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span> = ambT<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>    
    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">1</span> ..&lt; gDf.<span style="color: #F92672; font-style: italic;">high</span>:
      <span style="color: #F92672;">while</span> time<span style="color: #AE81FF;">[</span>j<span style="color: #AE81FF;">]</span> &lt; gDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;tStart&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">][</span>i<span style="color: #AE81FF;">]</span>:
        cT.push ambT<span style="color: #AE81FF;">[</span>j<span style="color: #AE81FF;">]</span>
        <span style="color: #F92672;">inc</span> j
      temps<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = cT.mean
      cT.clear<span style="color: #AE81FF;">()</span>
    temps<span style="color: #AE81FF;">[</span>gDf.<span style="color: #F92672; font-style: italic;">high</span><span style="color: #AE81FF;">]</span> = ambT<span style="color: #AE81FF;">[</span>ambT.<span style="color: #F92672;">len</span> - <span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">gains </span>= gDf<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;G&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
    <span style="color: #FD971F;">result</span> = toDf<span style="color: #AE81FF;">(</span>temps, gains, period<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfGT </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>gainDf.groupBy<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;RunPeriod&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
    dfGT.<span style="color: #F92672;">add</span> mapGainToTemp<span style="color: #AE81FF;">(</span>subDf, dfCastTemp, tup<span style="color: #66D9EF;">[</span><span style="font-style: italic;">0</span><span style="color: #66D9EF;">][</span><span style="font-style: italic;">1</span><span style="color: #66D9EF;">]</span>.toStr<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> dfGT
  <span style="color: #F92672;">echo</span> dfGT.tail<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span><span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>dfGT.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`temps` &gt; <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;temps&quot;</span>, <span style="color: #E6DB74;">&quot;gains&quot;</span>, color = <span style="color: #E6DB74;">&quot;period&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_point<span style="color: #AE81FF;">()</span> +
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Gas gain (90 min slices) vs ambient T at CAST (center chip)&quot;</span><span style="color: #AE81FF;">)</span> +
    xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Temperature [°C]&quot;</span><span style="color: #AE81FF;">)</span> + ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Gas gain&quot;</span><span style="color: #AE81FF;">)</span> +
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="font-style: italic;">600</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outpath}/gain_vs_temp_center_chip.pdf&quot;</span>,
           width = <span style="font-style: italic;">600</span>, height = <span style="font-style: italic;">360</span>,
           useTeX = <span style="color: #66D9EF;">UseTeX</span>, standalone = <span style="color: #66D9EF;">UseTeX</span><span style="color: #AE81FF;">)</span>            
      
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span>calibFiles: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span>, dataFiles: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span> = @<span style="color: #66D9EF;">[]</span>,
          outpath = <span style="color: #E6DB74;">&quot;/tmp/&quot;</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">## NOTE: this file needs the CSV file containing the temperature data from the slow control</span>
  <span style="color: #E6DB74;">## CAST log files, which is written running the `</span><span style="color: #AE81FF;">cast_log_reader</span><span style="color: #E6DB74;">` on the slow control log</span>
  <span style="color: #E6DB74;">## directory!</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">gainDf </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">if</span> dataFiles.<span style="color: #F92672;">len</span> &gt; <span style="font-style: italic;">0</span>:
    gainDf = readGasGainSliceData<span style="color: #AE81FF;">(</span>dataFiles<span style="color: #AE81FF;">)</span>
      .mapToPeriod<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;tStart&quot;</span><span style="color: #AE81FF;">)</span>
    <span style="color: #E6DB74;">## Make a plot of the raw gas gains of all chips</span>
    ggplot<span style="color: #AE81FF;">(</span>gainDf, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;tStart&quot;</span>, <span style="color: #E6DB74;">&quot;G&quot;</span>, color = <span style="color: #E6DB74;">&quot;Chip&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_point<span style="color: #AE81FF;">(</span>size = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Raw gas gain values in 90 min bins for all chips&quot;</span><span style="color: #AE81FF;">)</span> +
      themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +       
      ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outpath}/raw_gas_gain.pdf&quot;</span>,
             width = <span style="font-style: italic;">600</span>, height = <span style="font-style: italic;">360</span>, 
             useTeX = <span style="color: #66D9EF;">UseTeX</span>, standalone = <span style="color: #66D9EF;">UseTeX</span><span style="color: #AE81FF;">)</span>              

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfCastTemp </span>= readCastTemps<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfTemp </span>= readSeptemTemps<span style="color: #AE81FF;">()</span>
  plotTempVsGain<span style="color: #AE81FF;">(</span>dfCastTemp, gainDf, outpath<span style="color: #AE81FF;">)</span>
      
  plotCorrelation<span style="color: #AE81FF;">(</span>calibFiles, fePixel,  gainDf, dfCastTemp, dfTemp, outpath<span style="color: #AE81FF;">)</span>
  plotCorrelation<span style="color: #AE81FF;">(</span>calibFiles, feCharge, gainDf, dfCastTemp, dfTemp, outpath<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">import</span> cligen
  dispatch main
</pre>
</div>

<p>
Running the above as:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">WRITE_PLOT_CSV</span>=true code/correlation_ambient_temps_fe55_peaks <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -d ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -d ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/behavior_over_time/
</pre>
</div>

<p>
which generates the following plots:
</p>
<ul class="org-ul">
<li>  <img alt="raw_gas_gain.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/raw_gas_gain.svg" /></li>
<li>  <img alt="gain_vs_temp_center_chip.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/gain_vs_temp_center_chip.svg" /></li>
<li>  <img alt="correlation_fePixel_period_2018-10-19.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_period_2018-10-19.svg" /></li>
<li>  <img alt="correlation_fePixel_period_2018-02-15.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_period_2018-02-15.svg" /></li>
<li>  <img alt="correlation_fePixel_period_2017-10-30.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_period_2017-10-30.svg" /></li>
<li>  <img alt="correlation_fePixel_all_chips_gasgain_period_2018-10-19.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_all_chips_gasgain_period_2018-10-19.svg" /></li>
<li>  <img alt="correlation_fePixel_all_chips_gasgain_period_2018-02-15.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_all_chips_gasgain_period_2018-02-15.svg" /></li>
<li>  <img alt="correlation_fePixel_all_chips_gasgain_period_2017-10-30.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_fePixel_all_chips_gasgain_period_2017-10-30.svg" /></li>
<li>  <img alt="correlation_feCharge_period_2018-10-19.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_period_2018-10-19.svg" /></li>
<li>  <img alt="correlation_feCharge_period_2018-02-15.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_period_2018-02-15.svg" /></li>
<li>  <img alt="correlation_feCharge_period_2017-10-30.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_period_2017-10-30.svg" /></li>
<li>  <img alt="correlation_feCharge_all_chips_gasgain_period_2018-10-19.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_all_chips_gasgain_period_2018-10-19.svg" /></li>
<li>  <img alt="correlation_feCharge_all_chips_gasgain_period_2018-02-15.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_all_chips_gasgain_period_2018-02-15.svg" /></li>
<li>  <img alt="correlation_feCharge_all_chips_gasgain_period_2017-10-30.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/correlation_feCharge_all_chips_gasgain_period_2017-10-30.svg" /></li>
</ul>

<p>
of which we insert only one of them (Run 3) correlation of gas gains
and temperature against the time. That is mainly because in that
period there was no worry about power supply effects anymore. It
should be noted that the apparent inverse correlation is not apparent
in the Run-2 data of 2017. Generally the water cooling was working
better at those times, which may be relevant. I don&apos;t want to
introduce even more speculation into the main section and as the
scatter plot of gas gain and temperature clearly shows an inverse
correlation for a large chunk of the data, the existing text is justified.
</p>

<p>
Also, we chose to include the <code>fePixel</code> version and not the <code>feCharge</code>
version as the link between gas gain of the center chip and the \cefe
charge spectrum is much more direct, offering less additional information.
</p>
</div>
<ol class="org-ol">
<li><a id="org37b1149"> </a>Initial interpretation upon seeing the correlation plot<br />
<div id="text-11-2-2-6-1" class="outline-text-6">
<p>
Note: this text was written after I created the first version of the
above plot for the first time.
</p>

<p>
The first thing that jumps out is that the (normalized) temperature
recovered from the shift forms of the Septem board sensor is strongly
correlated with the ambient CAST temperature (<code>T_amb</code>). This is
interesting and reassuring as it partially explains why the
temperatures were higher on the Septemboard during Run-3 than Run-2:
it was hotter in the hall in Run-3 (not shown in this plot, see full
version of all data).
</p>

<p>
<b>Next paragraph was written before gas gain information was in the plot</b>
However, the peak position of the 55Fe data is either uncorrelated
<b>or</b> actually inversely proportional to the temperatures. When the
temperatures are lower the peak position is higher and vice versa. The
data is imo not good enough to make final statements about this, but
<span class="underline">something</span> might be going on there. This is something that one might
want to investigate in the future!
</p>

<p>
<b>UPDATE</b>: Having added the gas gain slice information to the plot now,
it seems pretty evident that there <b>is</b> an inverse correlation between
the gas gain and the temperature!
</p>

<ul class="org-ul">
<li>ideal gas, temp + constant pressure, lower density, higher mobility</li>
<li>less visible in old detector, as absolute temperatures under grid
much lower, therefore on a &quot;less steep&quot; part of the exponential that
makes up the gas gain temperature dependence!</li>
</ul>

<p>
PDG 2016 page 467 says: (detectors at accelerators chapter)
</p>
<blockquote>
<p>
For different temperatures and pressures, the mobility can be scaled
inversely with the density assuming an ideal gas law
</p>
</blockquote>
<p>
This <b>should</b> imply:
</p>
<ul class="org-ul">
<li>A higher temperature in the CAST hall, while keeping the same
pressure in the detector, means a lower gas density according to the
ideal gas law, p·V = nRT ⇔ n₁RT₁ = n₂RT₂ ⇔ T₁/T₂ = n₁/n₂ ⇔ T₁ &gt; T₂ ⇒
n₁ &lt; n₂. n ∝ ρ.</li>
<li>A lower density according to the quote then implies a <span class="underline">higher</span>
mobility.</li>
<li>The &apos;mobility&apos; should be proportional to the mean free path.
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>CHECK THIS</b></li>
</ul></li>
<li><b>Assuming</b> the mean free path is <span class="underline">long enough</span> in &apos;both&apos;
temperatures as to have enough kinetic energy to cause an ionization
~typically, <b>then</b> a <span class="underline">higher mobility</span> means <b>less</b> gas gain, as
there will be <b>less</b> collisions!
<b>However</b> if the mean free path would lead to typical collisions
that do <b>not</b> have enough energy to cause ionization, then the gas
gain would be <b>lower</b> for a <b>lower</b> mobility, as the gas would then
act as a dampener. But the former should always be true in the
amplification region I guess.</li>
</ul>

<p>
This explanation is not meant as a definitive statement about the
origins of the gas gain variations in the Septemboard detector
data. <b>However</b>, it clearly motivates the need for an in depth study
of the behavior of these detectors for different gas temperatures at
constant pressures and more precise logging of temperatures in future
detectors. Further, a significantly improved cooling setup (to more
closely approach a region where temperature changes have a smaller
relative impact), or theoretically even a temperature controlled setup
with known inlet gas temperatures might be useful. This behavior is
one of the most problematic from a data analysis point of view and
thus it should be taken seriously for future endeavors!
</p>


<ul class="org-ul">
<li class="on"><code>[X]</code> <b>INSERT THE PIXEL TEMP GASGAIN PLOT INTO THESIS ROTATED FULL
PAGE?</b></li>

<li class="on"><code>[X]</code> <b>ADD VERSION OF PLOTS THAT SHOW FULL DATA WITHOUT CUT TO RUN-3</b></li>

<li class="on"><code>[X]</code> <b>ADD A SIMILAR PLOT, BUT NOT USING 55FE POSITIONS, BUT GAS GAIN
SLICES</b>
-&gt; done by <b>adding</b> Gas gain data as well for all chips!</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec:calib:gas_gain_time_binning" class="outline-4">
<h4 id="sec:calib:gas_gain_time_binning">  <a href="#sec:calib:gas_gain_time_binning">  <span class="section-number-4">11.2.3.</span> Gas gain binning</a></h4>
<div id="text-sec:calib:gas_gain_time_binning" class="outline-text-4">
<p>
Motivated by the strong variation seen over timescales much shorter
than the typical length of a background run, the gas gain needs to be
computed in time slices of a fixed length. This is naturally a
trade-off between assigning accurate gas gains to a time slice and
acquiring enough statistics to compute said gas gain correctly.
</p>

<p>
To determine a suitable time window the gas gain was computed for a
fixed set of different time intervals and figures similar to
fig. <a href="#fig:calib:total_charge_over_time">3</a> were considered not only for the
median charge, but also different geometric cluster
distributions. Further, by applying the energy calibration based on each
different set of time intervals to the background data (as will be
explained in sec. <a href="./calibration.html#sec:calib:final_energy_calibration">11.3</a>), the histograms
of the median cluster energy in the background data was studied. The
ideal time interval is one in which the resulting median energy
distribution has low variance and is unimodal approaching a normal
distribution, (background in all slices is equivalent over large enough
times) while at the same time provides enough statistics in the \cefe
spectrum of the slice to perform a good fit.
</p>

<p>
Unimodality can be quantitatively checked using different goodness of
fit tests (Anderson-Darling, Cramér-von Mises,
Kolmogorov-Smirnov). See appendix
<a href="./appendix_detector_time_behavior.html#sec:appendix:choice_gas_gain_binning">25.1</a> for a comparison and further
plots comparing the intervals. The goodness of fit tests tend to favor
shorter intervals, in particular \(\SI{45}{min}\). However, looking at
fig. <a href="#fig:calib:median_energy_ridgeline_30_10_2017">7</a> shows that the
variance grows significantly below \(\SI{90}{min}\).
</p>


<figure id="fig:calib:median_energy_ridgeline_30_10_2017">
<img alt="medianEnergy_kde_ridges_30_10_2017.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_kde_ridges_30_10_2017.svg" />

<figcaption>Figure 7: <span class="figure-number">Figure 43: </span>Ridgeline plot of a kernel density estimation (bandwidth based on Silverman&apos;s rule of thumb) of the median cluster energies split by the used time intervals. The underlying data is the background data from Oct 2017 to Dec 2017. The overlap of the individual ridges is for easier visual comparison and a KDE was selected over a histogram due to strong binning dependence of the resulting histograms. For the dataset and binning the \(\SI{90}{min}\) interval (olive) strikes an acceptable balance between unimodality and variance.</figcaption>
</figure>

<p>
As the different ways to look at the data are not entirely conclusive,
the choice was made to choose an interval length that is not too long,
while still providing enough statistics for the \cefe spectra. As such
\(\SI{90}{min}\) was selected as the final interval time. Of course no
data taking run is a perfect multiple of \(\SI{90}{min}\). The last
slice smaller than the time interval is either added to the second to
last slice (making it longer than \(\SI{90}{min}\)) if it is smaller
than some fixed interval or will be kept as a single shorter
interval. This is controlled by an additional parameter that is set to
\(\SI{25}{min}\) by default. <sup>  <a id="fnr.4" href="#fn.4" class="footref" role="doc-backlink">4</a></sup>
</p>
</div>
<div id="outline-container-orgc8c5256" class="outline-5">
<h5 id="orgc8c5256">  <a href="#orgc8c5256">  <span class="section-number-5">11.2.3.1.</span> Ridgeline plot of the median energies   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-2-3-1" class="outline-text-5">
<p>
Finally, let&apos;s recreate the plot of the histograms of the median
energies in the time slices as a ridgeline plot to better explain why
we chose 90 min instead of anything else that we tested.
</p>

<p>
First, if one is not happy with using the provided CSV files that
contain the precomputed medians of the cluster energy in the
<code>phd/resources/optimize_gas_gain_length</code> directory, run the
<code>optimizeGasGainSliceTime</code> tool:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Tools
nim c -d:release -d:<span style="color: #FD971F;">StartHue</span>=285 optimizeGasGainSliceTime.nim
./optimizeGasGainSliceTime --path &lt;PathToDataRunsH5&gt; --genCsv
</pre>
</div>
<p>
Note that this takes some time, as the fitting of all gas gains in
each time slice is somewhat time consuming (for the 90 min case it
takes maybe 15 minutes for all data; more for shorter time scales,
less for longer).
(It may be necessary to modify the code as I may forget to change the
input data file paths; they are hardcoded as of right now)
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>CHANGE CODE TO NOT USE HARDCODED PATHS, THEN ADJUST SCRIPT
ABOVE</b>
-&gt; Change code to not point to hardcoded config file!</li>
</ul>

<p>
This generates CSV files in an <code>out</code> directory from wherever you
actually ran the code from.
</p>

<p>
To produce the plots as used in the thesis (and many more), just run:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=380 <span style="color: #FD971F;">FACET_MARGIN</span>=1.1 <span style="color: #FD971F;">LINE_WIDTH</span>=1.0 <span style="color: #FD971F;">WRITE_PLOT_CSV</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
             ./optimizeGasGainSliceTime <span style="color: #E6DB74; font-weight: bold;">\</span>
             --path out <span style="color: #E6DB74; font-weight: bold;">\</span>
             --plot <span style="color: #E6DB74; font-weight: bold;">\</span>
             --outpath ~/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/
</pre>
</div>

<p>
Among others this generates a plot of the scores for different
goodness of fit tests for each interval setting and period of data
taking. They all use the mean of the full data and the variance of the
full data (that&apos;s clearly not ideal, but it should be passable to have
something comparable).
</p>

<p>
The resulting plot is 
<img alt="gofs_for_different_binnings.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/gofs_for_different_binnings.svg" />
At least for the 2017 data set the 45 minute interval seems to be the
clear winner. However, in beginning 2018 it&apos;s one of the worst at
least for Anderson-Darling and Cramér-von-Mises (which are probably
the most interesting tests to look at).
</p>

<p>
The 90 min result is sort of mostly in the middle. The big advantage
of it though is that it definitely captures enough statistics, which
is extremely important for the \cefe spectrum, as the data rate is
very low there. As much statistics as possible is needed to get a nice
fit there.
</p>

<p>
At the same time comparing the ridgeline plot / histograms it is also
evident that the variance itself is quite a bit smaller in the 90 min
case, which is another important aspect.
</p>

<p>
In addition all these plots for the distribution of properties / the
energy are created:
</p>
<ul class="org-ul">
<li>  <img alt="medianEnergy_intervals.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_intervals.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_30.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_30.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_45.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_45.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_60.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_60.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_90.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_90.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_120.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_120.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_180.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_180.svg" /></li>
<li>  <img alt="medianEnergy_vs_time_300.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_vs_time_300.svg" /></li>
<li>  <img alt="medianEnergy_kde_intervals.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_kde_intervals.svg" /></li>
<li>  <img alt="medianEnergy_ridges_17_02_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_ridges_17_02_2018.svg" /></li>
<li>  <img alt="medianEnergy_ridges_21_10_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_ridges_21_10_2018.svg" /></li>
<li>  <img alt="medianEnergy_ridges_30_10_2017.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_ridges_30_10_2017.svg" /></li>
<li>  <img alt="medianEnergy_intervals_17_02_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_intervals_17_02_2018.svg" /></li>
<li>  <img alt="medianEnergy_intervals_21_10_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_intervals_21_10_2018.svg" /></li>
<li>  <img alt="medianEnergy_intervals_30_10_2017.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_intervals_30_10_2017.svg" /></li>
<li>  <img alt="medianEnergy_kde_ridges_17_02_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_kde_ridges_17_02_2018.svg" /></li>
<li>  <img alt="medianEnergy_kde_ridges_21_10_2018.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_kde_ridges_21_10_2018.svg" /></li>
<li>  <img alt="medianEnergy_kde_ridges_30_10_2017.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/optimizeGasGainSliceTime/medianEnergy_kde_ridges_30_10_2017.svg" /></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec:calib:final_energy_calibration" class="outline-3">
<h3 id="sec:calib:final_energy_calibration">  <a href="#sec:calib:final_energy_calibration">  <span class="section-number-3">11.3.</span> Energy calibration dependence on the gas gain</a></h3>
<div id="text-sec:calib:final_energy_calibration" class="outline-text-3">
<p>
With the final choice of time interval for the gas gain binning in
place, the actual calibration used for further analysis can be
presented. Fig. <a href="#fig:calib:gasgain_vs_energy_calib_comparison">8</a>
shows the fits according to the linear relation as explained in
sec. <a href="./calibration.html#sec:calibration:energy">11.1</a>, eq. \eqref{eq:gas_gain_vs_calib_factor}, for the
two data taking campaigns, Run-2 in
<a href="#fig:calib:gasgain_vs_energy_calib_2017">8(a)</a> and Run-3 in
<a href="#fig:calib:gasgain_vs_energy_calib_2018">8(b)</a>. Each point represents one
\(\SI{90}{min}\) slice of calibration data for which a \cefe spectrum
was fitted and then the linear energy calibration performed. The
resulting energy calibration factor is then plotted against the gas
gain computed for this time slice. The uncertainty of each point is
the uncertainty extracted from the fit parameter of the calibration
factor after error propagation. Calibrations need to be performed
separately for each data taking campaign as the detector behavior
changes due to different detector calibrations. These have an impact
on the <code>ToT</code> calibration as well as the activation threshold. Note
that the reduced \(χ²\) values shown in the figure, implies that this
calibration does not perfectly calibrate out the systematic effects of
the variability.
</p>


<figure id="fig:calib:gasgain_vs_energy_calib_comparison" class="figure-wrapper">
<figure id="fig:calib:gasgain_vs_energy_calib_2017" class="subfigure" data-width="49%">  <img src="./figs/home/basti/phd/Figs/energyCalibration/Run_2/gasgain_vs_energy_calibration_factors_4316675118229057340.svg" data-width="99%" />  <figcaption>Figure 8(a): Run-2</figcaption></figure> <figure id="fig:calib:gasgain_vs_energy_calib_2018" class="subfigure" data-width="49%">  <img src="./figs/home/basti/phd/Figs/energyCalibration/Run_3/gasgain_vs_energy_calibration_factors_-4542617296427170283.svg" data-width="99%" />  <figcaption>Figure 8(b): Run-3</figcaption></figure>
<figcaption>Figure 8: Fit of the gas gain values vs the calculated energy calibration factors
          for all calibration runs in Run-2 <a href="#fig:calib:gasgain_vs_energy_calib_2017">8(a)</a> and Run-3 <a href="#fig:calib:gasgain_vs_energy_calib_2018">8(b)</a>. Each run was further sliced into $\SI{90}{min}$ parts for the gas
         gain determination and \cefe fits.</figcaption>
</figure>


<p>
To compare the energy calibration using single gas gain values for
each full run against the method of time slicing them to
\(\SI{90}{min}\) chunks, we will look at the median cluster energy in
each time slice for background and calibration data. This is the same
idea as behind fig. <a href="#fig:calib:total_charge_over_time">3</a> previously, just
for the energy instead of charge. This yields
fig. <a href="#fig:calib:median_energy_binned_vs_unbinned">9</a>. The points represent
background and crosses calibration data. Green is the unbinned (full
run) approach and purple the binned approach using \(\SI{90}{min}\)
slices. The effect is a slight, but visible reduction in variance. It
represents an important aspect of increasing data reliability and
lowering associated systematic uncertainties. Note that the
variability looks much smaller than in
fig. <a href="#fig:calib:total_charge_over_time">3</a> due to not being
normalized. However, here we wish to emphasize that the absolute
energy calibration yields a flat result and matches our expectation.
</p>

<p>
As such the final energy calibration works by first deducing the gas
gain at the time of an event, computing the calibration factor
required for this gas gain and finally using that factor to convert
the charge into energy.
</p>


<figure id="fig:calib:median_energy_binned_vs_unbinned">
<img alt="median_energy_binned_vs_unbinned.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/median_energy_binned_vs_unbinned.svg" />

<figcaption>Figure 9: <span class="figure-number">Figure 44: </span>Median of the cluster energy after calibration using two different approaches. Green corresponds to calculating the energy based on a single gas gain for each run and purple implies calculation based on \(\SI{90}{min}\) time intervals for the gas gain. Both cases use the same \(\SI{90}{min}\) intervals to compute a local, temporal median of all clusters. Each subplot corresponds to a data taking period with significant times between for clarity. The energies from unbinned gas gains has a wider distribution than the binned data. The latter approaches a flat distribution of the background energies (points) better than the former. The impact for the calibration data (crosses) is much smaller, as they are not much longer than the \(\SI{90}{min}\) binning anyway.</figcaption>
</figure>
</div>
<div id="outline-container-org9c6c41e" class="outline-4">
<h4 id="org9c6c41e">  <a href="#org9c6c41e">  <span class="section-number-4">11.3.1.</span> Generate plot for the gas gain vs. energy calibration factors   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-11-3-1" class="outline-text-4">
<p>
In principle the plots shown in the section above are produced during
the regular data reconstruction and calibration, in particular by the
<code>reconstruction</code> program using the <code>--only_gain_fit</code> argument.
</p>

<p>
Let&apos;s recreate them in the style we want for the thesis.
</p>

<p>
We use a slightly taller height to have a bit more space (for y label
and annotation).
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=420 reconstruction <span style="color: #E6DB74; font-weight: bold;">\</span>
   -i ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
   --only_gain_fit <span style="color: #E6DB74; font-weight: bold;">\</span>
   --plotOutPath ~/phd/Figs/energyCalibration/Run_2/ <span style="color: #E6DB74; font-weight: bold;">\</span>
   --overwrite
<span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=420 reconstruction <span style="color: #E6DB74; font-weight: bold;">\</span>
   -i ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
   --only_gain_fit <span style="color: #E6DB74; font-weight: bold;">\</span>
   --plotOutPath ~/phd/Figs/energyCalibration/Run_3/ <span style="color: #E6DB74; font-weight: bold;">\</span>
   --overwrite
</pre>
</div>

<p>
which produces the plots in:
</p>
<ul class="org-ul">
<li>  <a href="./Figs/energyCalibration/Run_2">./Figs/energyCalibration/Run_2</a></li>
<li>  <a href="./Figs/energyCalibration/Run_3">./Figs/energyCalibration/Run_3</a></li>
</ul>
</div>
</div>
<div id="outline-container-org0f004fc" class="outline-4">
<h4 id="org0f004fc">  <a href="#org0f004fc">  <span class="section-number-4">11.3.2.</span> Generate plot of median cluster energy   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-11-3-2" class="outline-text-4">
<p>
Let&apos;s now generate the plots of the median cluster energy.
</p>

<p>
<b>Note</b>: As the gas gain calculation is time consuming:
If the gas gain values were computed at some point in the past and the
<code>gasGainSlices*</code> datasets are still present, the calculation of the
gas gain bins isn&apos;t needed. One can simply change the current
<code>gasGainInterval</code> in the <code>config.toml</code> and recompute the gas gain vs
energy calibration fit (<code>--only_gain_fit</code>) and the energy again to
re-generate the plots.
</p>

<p>
First here are two sections which cover how to compute the relevant
gas gain slices and calibrate the energy accordingly. They also show
how to use the tool to plot the median energy over the time bins. When
running them, they generate CSV files that we will use further down to
generate a plot that combines the data from the full run and 90 min
binned gas gain data into one plot.
</p>
</div>
<div id="outline-container-org6e92da6" class="outline-5">
<h5 id="org6e92da6">  <a href="#org6e92da6">  <span class="section-number-5">11.3.2.1.</span> Full run gas gain</a></h5>
<div id="text-11-3-2-1" class="outline-text-5">
<p>
First, the case of computing it from the full run gas gain, calculate
the median of 90 min data in the plot and second the 90 minute binned
gas gain version, with the same bins used for the plot.
</p>

<p>
To start, first need to recompute the gas gain based on the full
runs. Set the <code>fullRunGasGain</code> value in the <code>config.toml</code> file to
<code>true</code> and <code>gasGainInterval</code> to <code>0</code> (the latter because
<code>fullRunGasGain</code> appends a <code>0</code> suffix to the generated dataset &amp; the
<code>--only_gain_fit</code> step reads from the dataset with suffix of <code>gasGainInterval</code>) then run:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --back --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_gas_gain
</pre>
</div>

<p>
Then check that the <code>gasGainInterval</code> datasets in the H5 files now
actually contain a single slice in the dataset without a numbered
suffix (indicating the minutes used for the slice).
</p>

<p>
With that done, again, run the <code>only_gain_fit</code> argument on the
calibration files:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_gain_fit
</pre>
</div>

<p>
Side note:
to check if the fit was done correctly on the full run slices, check
the output directory, e.g. something like
<code>out/CalibrationRuns2018_Raw_2020-04-28_15-06-54</code> in case of the Run-3
data and compare the <code>gasgain_vs_energy_calibration_factors_*</code> files
present there. The latest (full run) version should have less data
points than the 90 min version that should already be present from the
initial reconstruction &amp; calibration of the data.
</p>

<p>
Then recompute the energy for all data:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --back --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_energy_from_e
</pre>
</div>


<p>
<b>Note</b>: The <code>plotTotalChargeOverTime</code> should be compiled using
</p>
<div class="org-src-container">
<pre class="src src-sh">nim c -d:danger -d:<span style="color: #FD971F;">StartHue</span>=285 plotTotalChargeOverTime
</pre>
</div>
<p>
as was done in the previous section where we generated the median
charge plot.
</p>

<p>
And again, generate the plot using our tool:
</p>
<div class="org-src-container">
<pre class="src src-sh">./plotTotalChargeOverTime ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --interval 90 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --cutoffCharge 0 --cutoffHits 500 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --calibFiles ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --calibFiles ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --applyRegionCut --timeSeries
</pre>
</div>

<p>
which yields the output file:
<code>out/background_median_energyFromCharge_90.0_min_filtered_crSilver.pdf</code>
and
<img alt="median_energy_full_run_gasgain_binned_90min_crSilver.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/median_energy_full_run_gasgain_binned_90min_crSilver.svg" />
</p>

<p>
Finally, it generates the following CSV file from the used data frame:
<code>out/data_90.0_min_filtered_crSilver.csv</code>
which we store in:
<a href="./resources/behavior_over_time/data_full_run_gasgain_90.0_min_filtered_crSilver.csv">./resources/behavior_over_time/data_full_run_gasgain_90.0_min_filtered_crSilver.csv</a>
</p>
</div>
</div>
<div id="outline-container-org7dcaf13" class="outline-5">
<h5 id="org7dcaf13">  <a href="#org7dcaf13">  <span class="section-number-5">11.3.2.2.</span> 90 min binning gas gains</a></h5>
<div id="text-11-3-2-2" class="outline-text-5">
<p>
Now to generate the 90 minute version, set the <code>fullRunGasGain</code> back
to <code>false</code> and make sure the gas gain time slice interval is set to 90
min in the <code>config.toml</code>. Then again run:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --back --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_gas_gain
</pre>
</div>
<p>
and again check the gas gain slice dataset without a suffix has
<span class="underline">multiple</span> slices each about 90 min in length.
</p>

<p>
With that done, again, run the <code>only_gain_fit</code> argument on the
calibration files:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_gain_fit
</pre>
</div>
<p>
and then recompute the energy for all data:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> $<span style="color: #FD971F;">TPA</span>/Analysis/ingrid
./runAnalysisChain -i ~/CastData/data --outpath ~/CastData/data <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --back --calib <span style="color: #E6DB74; font-weight: bold;">\</span>
                   --only_energy_from_e
</pre>
</div>

<p>
And again, generate the plot using our tool:
</p>
<div class="org-src-container">
<pre class="src src-sh">./plotTotalChargeOverTime ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --interval 90 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --cutoffCharge 0 --cutoffHits 500 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --calibFiles ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --calibFiles ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                          --applyRegionCut --timeSeries
</pre>
</div>

<p>
which - among others - generates the output file
<code>out/background_median_energyFromCharge_90.0_min_filtered_crSilver.pdf</code>
which for our purposes:
<img alt="median_energy_binned_90min_crSilver.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/median_energy_binned_90min_crSilver.svg" />
</p>

<p>
And again, it generates the CSV file:
<code>out/data_90.0_min_filtered_crSilver.csv</code>
which we store in:
<a href="./resources/behavior_over_time/data_gas_gains_binned_90.0_min_filtered_crSilver.csv">./resources/behavior_over_time/data_gas_gains_binned_90.0_min_filtered_crSilver.csv</a>
</p>
</div>
</div>
<div id="outline-container-orgcd38667" class="outline-5">
<h5 id="orgcd38667">  <a href="#orgcd38667">  <span class="section-number-5">11.3.2.3.</span> Comparison of the files</a></h5>
<div id="text-11-3-2-3" class="outline-text-5">
<p>
If you ran the code in the order above, your <code>config.toml</code> file should
again be in the 90 min &amp; binned gas gain setting. Otherwise change it
back and rerun the 90 min binning &amp; fitting &amp; energy calculation
commands from above to make sure we don&apos;t mess up plots that are
generated further!
</p>


<ul class="org-ul">
<li>  <code>~/phd/Figs/behavior_over_time/median_energy_full_run_gasgain_binned_90min_crSilver.pdf</code></li>
<li>  <code>~/phd/Figs/behavior_over_time/median_energy_binned_90min_crSilver.pdf</code></li>
</ul>

<p>
Comparing the two median energy files, both binned by the same
intervals (the ones used for the 90 min gas gain calculations), it&apos;s
evident that <span class="underline">more or less</span> they do agree. However, in some areas
significant spikes can be seen in the version from the full run gas
gain values, which is precisely expected: It&apos;s those runs in which the
temperature varied significantly within the one run, changing the gas
gain as a result. So there are times in which the average gas gain of
that run does not match locally within the run.
</p>


<p>
Now we use the CSV files from <code>phd/resources/behavior_over_time</code> to
generate the same plot as the individual ones here, but showing the
binned and unbinned data with different shapes / colors.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>times, strformat<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ggplotnim

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df1 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/phd/resources/behavior_over_time/data_full_run_gasgain_90.0_min_filtered_crSilver.csv&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df2 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/phd/resources/behavior_over_time/data_gas_gains_binned_90.0_min_filtered_crSilver.csv&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= bind_rows<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;Unbinned&quot;</span>, df1<span style="color: #A6E22E;">)</span>, <span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;Binned&quot;</span>, df2<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">]</span>, <span style="color: #E6DB74;">&quot;Data&quot;</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">th</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">Theme</span> =
  <span style="color: #FD971F;">result</span> = singlePlot<span style="color: #AE81FF;">()</span>
  <span style="color: #FD971F;">result</span>.tickLabelFont = some<span style="color: #AE81FF;">(</span>font<span style="color: #66D9EF;">(</span><span style="font-style: italic;">7</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">name </span>= <span style="color: #E6DB74;">&quot;energyFromChargeMedian&quot;</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;timestamp&quot;</span>, name, shape = <span style="color: #E6DB74;">&quot;runType&quot;</span>, color = <span style="color: #E6DB74;">&quot;Data&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  facet_wrap<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;runPeriods&quot;</span>, scales = <span style="color: #E6DB74;">&quot;free&quot;</span><span style="color: #AE81FF;">)</span> +
  facetMargin<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">75</span>, ukCentimeter<span style="color: #AE81FF;">)</span> +
  scale_x_date<span style="color: #AE81FF;">(</span>name = <span style="color: #E6DB74;">&quot;Date&quot;</span>, isTimestamp = <span style="color: #AE81FF;">true</span>,
               dateSpacing = initDuration<span style="color: #66D9EF;">(</span>weeks = <span style="font-style: italic;">2</span><span style="color: #66D9EF;">)</span>,
               formatString = <span style="color: #E6DB74;">&quot;dd/MM/YYYY&quot;</span>, dateAlgo = dtaAddDuration<span style="color: #AE81FF;">)</span> +
  geom_point<span style="color: #AE81FF;">(</span>alpha = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">8</span><span style="color: #66D9EF;">)</span>, size = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  ylim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">6</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
  margin<span style="color: #AE81FF;">(</span>top = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span>, left = <span style="font-style: italic;">4</span>.<span style="font-style: italic;">0</span>, bottom = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>, right = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  legendPosition<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">175</span><span style="color: #AE81FF;">)</span> +
  xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Date&quot;</span>, margin = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Energy [keV]&quot;</span>, margin = <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>, width = <span style="font-style: italic;">1200</span>, height = <span style="font-style: italic;">800</span>, baseTheme = th<span style="color: #AE81FF;">)</span> + 
  ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Median of cluster energy, binned vs. unbinned. 90 min intervals.&quot;</span><span style="color: #AE81FF;">)</span> +
  ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Figs/behavior_over_time/median_energy_binned_vs_unbinned.pdf&quot;</span>,
         width = <span style="font-style: italic;">1200</span>, height = <span style="font-style: italic;">800</span>,
         useTeX = <span style="color: #AE81FF;">true</span>, standalone = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
which results in
</p>


<figure id="org34792f4">
<img alt="median_energy_binned_vs_unbinned.svg" class="org-svg" src="./figs/home/basti/phd/Figs/behavior_over_time/median_energy_binned_vs_unbinned.svg" />

</figure>
</div>
</div>
</div>
</div>
<div id="outline-container-sec:calib:fadc" class="outline-3">
<h3 id="sec:calib:fadc">  <a href="#sec:calib:fadc">  <span class="section-number-3">11.4.</span> FADC</a></h3>
<div id="text-sec:calib:fadc" class="outline-text-3">
<p>
As touched on multiple times previously, in particular in
sec. <a href="./cast.html#sec:cast:data_taking_woes">10.5</a>, the FADC suffered from noise. This
meant multiple changes to the amplifier settings to mitigate this.
</p>

<p>
We will now go over what the FADC noise looks like and explain our
noise filter used to determine if an FADC event is noisy (to ignore
it), in sec. <a href="./calibration.html#sec:calibration:fadc_noise">11.4.1</a>. Then we check the impact of
the different amplification settings on the FADC data and discuss the
impact of the FADC data quality on the rest of the detector data in
sec. <a href="./calibration.html#sec:calib:fadc:amplifier_settings">11.4.2</a>.
</p>
</div>
<div id="outline-container-sec:calibration:fadc_noise" class="outline-4">
<h4 id="sec:calibration:fadc_noise">  <a href="#sec:calibration:fadc_noise">  <span class="section-number-4">11.4.1.</span> FADC noise example and detection</a></h4>
<div id="text-sec:calibration:fadc_noise" class="outline-text-4">
<p>
An example of the most common type of noise events seen in the FADC
data is shown in fig. <a href="#fig:calib:fadc_noise_example">11</a>. As the FADC
registers effectively correspond to \(\SI{1}{ns}\) time resolution, the
periodicity of these noise events is about \(\SI{150}{ns}\),
corresponding to roughly \(\SI{6.6}{MHz}\) frequency. Other types of
less common noise events are events with a noise frequency of about
\(\SI{1.5}{MHz}\). <sup>  <a id="fnr.5" href="#fn.5" class="footref" role="doc-backlink">5</a></sup> A final type of noise events are
events in which the FADC input is fully at a low input voltage (in
the tens of \(\si{mV}\) range), but contains no real &apos;activity&apos;. The values
though are lower than the threshold in these cases triggering the
FADC.
</p>


<figure id="fig:calib:fadc_noise_example">
<img alt="fadc_event_run109_event19157_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadcNoise/fadc_event_run109_event19157_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" />

<figcaption>Figure 11: <span class="figure-number">Figure 45: </span>Example of the most common type of noise example. Noise has a periodicity of about \(\sim\SI{150}{ns}\), or about \(\SI{6.6}{MHz}\).</figcaption>
</figure>

<p>
For data analysis purposes, in particular when the FADC data is used
in conjunction with the GridPix data, it is important to not
accidentally use an FADC event, which contains noise. While generally
noise events are unlikely to be part of physical ionization events on
the center GridPix it is better to be on the conservative side. The
noise analysis is kept very simple <sup>  <a id="fnr.6" href="#fn.6" class="footref" role="doc-backlink">6</a></sup>. The FADC
spectrum, consisting of \(\num{2560}\) registers, is being sliced into
\(\num{150}\) register wide intervals. In each interval we check for the
minimum of the signal, \(m_s\). The slice is adjusted around the found
minimum to check if the minimum is contained fully in the slice (if
not it is part of the next slice). If that minimum is below \(m_s &lt; B -
σ\), where \(B\) is the signal baseline and \(σ\) the standard deviation of
the full FADC signal (including the peaks!), it will be counted as a
peak. The noise filter detection is then defined by signals with at
least \(\num{4}\) peaks within slices of \(\SI{150}{ns}\). 
</p>
</div>
<div id="outline-container-orgaf55238" class="outline-5">
<h5 id="orgaf55238">  <a href="#orgaf55238">  <span class="section-number-5">11.4.1.1.</span> Notes on FADC noise analysis   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-4-1-1" class="outline-text-5">
<p>
The <code>fadc_analysis.nim</code> program in <code>TimepixAnalysis</code> on the one hand
contains the code to detect noisy events and is used as a library for
that purpose. But it can also be used to perform a standalone FADC
noise analysis if compiled on its own.
</p>


<p>
To determine if an event is noisy:
</p>
<ul class="org-ul">
<li>check for dips in the signal of width 150 ns</li>
<li>if more than 4 dips in one event -&gt; noisy</li>
</ul>

<p>
<code>fadc_helpers.nim</code> -&gt; <code>isFadcFileNoisy</code> using <code>findPeaks</code> from
<code>NimUtil/helpers/utils.nim</code>.
</p>

<p>
Note: the implementation is rather simple. Instead of slicing the FADC
data into chunks of the desired width it would be smarter to work with
a running version of the data and see if the running mean crosses some
lower threshold. The difficulty in that is detecting separate
peaks. One would need to track the &apos;last return to baseline&apos; and only
count more dips if the next minimum had a baseline return (or maybe
50% of baseline return) in it.
</p>
</div>
</div>
<div id="outline-container-org39c27e2" class="outline-5">
<h5 id="org39c27e2">  <a href="#org39c27e2">  <span class="section-number-5">11.4.1.2.</span> Find a good noisy FADC event   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-4-1-2" class="outline-text-5">
<p>
Types of noise:
</p>
<ul class="org-ul">
<li>O(4) periods in 2560 ns</li>
<li>O(16) periods in 2560 ns</li>
<li>signal at negative voltage (with no periodicity) over entire range</li>
</ul>
<p>
-&gt; appendix one example of each? Then again, we also don&apos;t show
examples of all sorts of fun GridPix events. Then again again, those
don&apos;t cause data loss because they are extremely infrequent :)
</p>

<p>
Run 109 (based on our notes taken during the CAST data taking) was a
run with serious amounts of noise. We&apos;ll find a good FADC event using
<code>plotData</code> by filtering to <code>noisy == 1</code> and producing FADC event
displays.
</p>

<p>
First let&apos;s generate some events:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_LEFT</span>=0.8 <span style="color: #E6DB74; font-weight: bold;">\</span>
    plotData <span style="color: #E6DB74; font-weight: bold;">\</span>
    --h5file ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --runType=rtBackground <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;fadc/noisy&quot;, 0.5, 1.5)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --applyAllCuts <span style="color: #E6DB74; font-weight: bold;">\</span>
    --fadc <span style="color: #E6DB74; font-weight: bold;">\</span>
    --eventDisplay <span style="color: #E6DB74; font-weight: bold;">\</span>
    --runs 109 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --head 50
</pre>
</div>

<p>
Good examples for the three main types of noise we had are:
High frequency event:
event #: 19157
</p>

<p>
Full on negative value event:
event #: 4147
</p>

<p>
Low frequency event:
event #: 9497
</p>

<p>
For each of these let&apos;s generate a prettier version:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_LEFT</span>=-0.8 <span style="color: #FD971F;">L_MARGIN</span>=2.5 <span style="color: #FD971F;">B_MARGIN</span>=2.0 <span style="color: #FD971F;">T_MARGIN</span>=1.0 <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=420 <span style="color: #E6DB74; font-weight: bold;">\</span>
    plotData <span style="color: #E6DB74; font-weight: bold;">\</span>
    --h5file ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --runType=rtBackground <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cuts <span style="color: #E6DB74;">&apos;(&quot;fadc/noisy&quot;, 0.5, 1.5)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --applyAllCuts <span style="color: #E6DB74; font-weight: bold;">\</span>
    --fadc <span style="color: #E6DB74; font-weight: bold;">\</span>
    --eventDisplay <span style="color: #E6DB74; font-weight: bold;">\</span>
    --runs 109 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --events 19157 --events 4147 --events 9497 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotPath ~/phd/Figs/FADC/fadcNoise/
</pre>
</div>

<ul class="org-ul">
<li>  <img alt="fadc_event_run109_event19157_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadcNoise/fadc_event_run109_event19157_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" /></li>
<li>  <img alt="fadc_event_run109_event4147_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadcNoise/fadc_event_run109_event4147_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" /></li>
<li>  <img alt="fadc_event_run109_event9497_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadcNoise/fadc_event_run109_event9497_region_crAll_fadc_noisy_0.5_1.5_applyAll_true.svg" /></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec:calib:fadc:amplifier_settings" class="outline-4">
<h4 id="sec:calib:fadc:amplifier_settings">  <a href="#sec:calib:fadc:amplifier_settings">  <span class="section-number-4">11.4.2.</span> Amplifier settings impact and activation threshold</a></h4>
<div id="text-sec:calib:fadc:amplifier_settings" class="outline-text-4">
<p>
Now let&apos;s look at the impact of the different amplifier settings on
the FADC data properties. This includes differences in the rise time
and fall time, but because changing the integration and
differentiation times on the amplifier has a direct impact on the
absolute amplification on the signal, we also need to consider the
change in activation threshold of the signals.
</p>

<p>
As a short reminder, the FADC settings were changed twice during the
Run-2 period in 2017. Starting from 2018, the settings were left
unchanged from the end of 2017. An overview of the setting changes is
shown in tab. <a href="#tab:calib:fadc_amplifier_settings">16</a>. Note that the Ortec
amplifier has a coarse and a fine gain. Only the coarse gain was
changed. <sup>  <a id="fnr.7" href="#fn.7" class="footref" role="doc-backlink">7</a></sup> The gain changes were performed to counteract
the resulting amplification changes due to the integration and
differentiation setting changes (this is documented as a side effect
in the FADC manual (<a href="./bibliography.html#citeproc_bib_item_58">CAEN 2010</a>)).
</p>

<table id="tab:calib:fadc_amplifier_settings">
<caption class="t-above"><span class="table-number">Table 16:</span> Overview of the different FADC amplifier settings and the associated run numbers.</caption>

<colgroup>
<col class="org-left" />

<col class="org-right" />

<col class="org-right" />

<col class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Runs</th>
<th scope="col" class="org-right">Integration [\(\si{ns}\)]</th>
<th scope="col" class="org-right">Differentiation [\(\si{ns}\)]</th>
<th scope="col" class="org-left">Coarse gain</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">76 - 100</td>
<td class="org-right">50</td>
<td class="org-right">50</td>
<td class="org-left">  <code>6x</code></td>
</tr>

<tr>
<td class="org-left">101 - 120</td>
<td class="org-right">50</td>
<td class="org-right">20</td>
<td class="org-left">  <code>10x</code></td>
</tr>

<tr>
<td class="org-left">121 - 306</td>
<td class="org-right">100</td>
<td class="org-right">20</td>
<td class="org-left">  <code>10x</code></td>
</tr>
</tbody>
</table>

<p>
The \cefe calibration spectra come in handy for the FADC data, as they
also give a known baseline to compare against for this type of
data. To get an idea of the rise and fall times of the FADC for
different settings, we can compute a truncated mean of all rise and
fall times in each calibration run. <sup>  <a id="fnr.8" href="#fn.8" class="footref" role="doc-backlink">8</a></sup> This is done in
fig. <a href="#fig:fadc:mean_rise_times_55fe_fadc_run2">12</a>, which shows the mean
rise time for each run in 2017 with the fall time color coded in each
point. The shaded regions indicate the FADC amplifier
settings. Changing the differentiation time from \(\SI{50}{ns}\) down to
\(\SI{20}{ns}\) decreased the rise time by about \(\SI{10}{ns}\). The
change in the fall time is much more pronounced. The change of the
integration time from \(\SI{50}{ns}\) to \(\SI{100}{ns}\) then brings the
rise time back up by about \(\SI{5}{ns}\) with now a drastic extension
in the fall time from the mid \(\SI{200}{ns}\) to over
\(\SI{400}{ns}\). Clearly the fall time is much more determined by the
amplifier settings.
</p>


<figure id="fig:fadc:mean_rise_times_55fe_fadc_run2">
<img alt="fadc_mean_riseTime_run2.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadc_mean_riseTime_run2.svg" />

<figcaption>Figure 12: <span class="figure-number">Figure 46: </span>The mean rise time of the FADC signals recorded during the \cefe data during Run-2 of the FADC. Again, the FADC amplifier settings are visible as expected. &apos;∫&apos;: integration time, &apos;∂&apos;: differentiation time, &apos;G&apos;: coarse gain.</figcaption>
</figure>

<p>
A direct scatter plot of the rise times against the fall times is
shown in fig. <a href="#fig:fadc:riseTime_vs_fallTime_55fe_fadc_run2">13</a>, where the
drastic changes to the fall time are even more pronounced. Each point
once again represents one \cefe calibration run. The different
settings manifest as separate &apos;islands&apos; in this space.
</p>


<figure id="fig:fadc:riseTime_vs_fallTime_55fe_fadc_run2">
<img alt="fadc_mean_riseTime_vs_fallTime_run2.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadc_mean_riseTime_vs_fallTime_run2.svg" />

<figcaption>Figure 13: <span class="figure-number">Figure 47: </span>The mean rise time of the FADC signals recorded during the \cefe data against the fall time during Run-2 at CAST. One point for each calibration run. The different settings create three distinct blobs. &apos;∫&apos;: integration time, &apos;∂&apos;: differentiation time, &apos;G&apos;: coarse gain.</figcaption>
</figure>

<p>
The FADC pulses contain a measure of the total charge that was induced
on the grid and therefore an indirect measure of the charge seen on
the center GridPix. The \cefe calibration runs could be used to fully
calibrate the FADC signals in charge if desired. Ideally one would
fully (numerically) integrate the FADC signal for each event to
compute an effective charge. As we only use the FADC signals in the
context of this thesis for their sensitivity to longitudinal shape
information, this is not implemented. For \cefe calibration data the
amplitude of the FADC pulse is a direct proxy for the charge anyway,
because the signal shape is (generally) the same for
X-rays. <sup>  <a id="fnr.9" href="#fn.9" class="footref" role="doc-backlink">9</a></sup> For the determination of whether the gas gain
variations discussed in sec. <a href="./calibration.html#sec:calib:detector_behavior_over_time">11.2</a>
have a physical origin due to changing gas gain or are caused by
electronic effects, we already included the FADC data in
fig. <a href="#fig:calib:fe55_peak_pos_charge_pixel_fadc">4</a> of
sec. <a href="./calibration.html#sec:calib:causes_variability">11.2.2</a>. Computing the histogram of all
amplitudes of the FADC signals in a \cefe calibration run, yields a
\cefe spectrum like for the center GridPix. The fitted position of the
photopeak in these spectra is then a direct counterpart to those
computed for the GridPix. Due to its independence and only being
sensitive to induced charge, it acts as a good validator.
</p>

<p>
In the context of the FADC amplifier settings it is interesting to see
how the photopeak position changes between runs when computed like
that. This is shown in
fig. <a href="#fig:fadc:peak_position_55fe_run2_settings">14</a>. We can see that the
initial change in differentiation time resulted in a larger gain
decrease than the attempt at compensation from <code>6x</code> to <code>10x</code> on the
coarse gain. The final increase in the integration time then caused
another drop in signal amplitudes, implying an even lower absolute
gain. In addition though the gas gain variation within a single
setting is very visible (as discussed in
sec. <a href="./calibration.html#sec:calib:causes_variability">11.2.2</a>).
</p>


<figure id="fig:fadc:peak_position_55fe_run2_settings">
<img alt="peak_positions_fadc_run2.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/peak_positions_fadc_run2.svg" />

<figcaption>Figure 14: <span class="figure-number">Figure 48: </span>The peak position in \si{V} of the photopeak in the \cefe calibration runs during Run-2 as seen on the FADC. The different FADC amplifier settings are clearly visible. &apos;∫&apos;: integration time, &apos;∂&apos;: differentiation time, &apos;G&apos;: coarse gain.</figcaption>
</figure>

<p>
Finally, we can look at the activation threshold of the FADC. The
easiest way to do this is the following: we read the energies of all
events on the center GridPix, then map them to their FADC
events. Although not common in calibration data, some events may not
trigger the FADC. By then computing – for example – the first
percentile of the energy data (the absolute lowest value may be some
outlier) we automatically get the lowest equivalent GridPix energy
that triggers the FADC. Doing this leads to yet another similar plot
to the previous,
fig. <a href="#fig:fadc:activation_threshold_gridpix_55fe_run2_settings">15</a>. With
the first FADC settings the activation threshold was at a low
\(\sim\SI{1.1}{keV}\). Unfortunately, both amplifier settings moved the
threshold further up to about \(\SI{2.2}{keV}\) with the final
settings. In hindsight it likely would have been a better idea to try
to run with a lower activation threshold so that the FADC trigger is
available for more events at low energies. However, at the time of the
data taking campaign not all information was available for an educated
assessment, nor was there enough time to test and implement other
ideas. Especially because there is a high likelihood that other
settings might have run back into noise problems. 
</p>


<figure id="fig:fadc:activation_threshold_gridpix_55fe_run2_settings">
<img alt="activation_threshold_gridpix_energy_fadc_run2.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/activation_threshold_gridpix_energy_fadc_run2.svg" />

<figcaption>Figure 15: <span class="figure-number">Figure 49: </span>The activation threshold of the FADC for each calibration run in 2017. Computed by the first percentile of the corresponding energies recorded by the GridPix. &apos;∫&apos;: integration time, &apos;∂&apos;: differentiation time, &apos;G&apos;: coarse gain.</figcaption>
</figure>
</div>
<div id="outline-container-orga3c7510" class="outline-5">
<h5 id="orga3c7510">  <a href="#orga3c7510">  <span class="section-number-5">11.4.2.1.</span> Further thoughts on understanding impact of \(\SI{50}{ns}\) vs \(\SI{100}{ns}\)   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-4-2-1" class="outline-text-5">
<p>
We did actually take a measurement of the FADC in the laboratory at
some point comparing \(\SI{50}{ns}\) integration time with
\(\SI{100}{ns}\) integration time. This was during the course of the
master thesis of Hendrik Schmick (<a href="./bibliography.html#citeproc_bib_item_193">Schmick 2019</a>).
</p>

<p>
Unfortunately, the exact values of the amplifier gain and
differentiation times were not recorded (dummy me!). These two
datasets may still be valuable (and are part of the raw data hosted at
Zenodo), but I haven&apos;t attempted to use them for a deeper
understanding in the last years (we looked into them back in 2019 though).
</p>
</div>
</div>
<div id="outline-container-sec:reco:fadc_rise_fall_plots" class="outline-5">
<h5 id="sec:reco:fadc_rise_fall_plots">  <a href="#sec:reco:fadc_rise_fall_plots">  <span class="section-number-5">11.4.2.2.</span> Generate plots of FADC fall &amp; rise times and FADC \cefe spectrum <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-sec:reco:fadc_rise_fall_plots" class="outline-text-5">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>REPLACE THE ORIGIN OF THIS PLOT</b></li>

<li class="off"><code>[ ]</code> <b>CREATE A NEW FADC \cefe SPECTRUM</b>
-&gt; Follow sec. <a href="./calibration.html#sec:calib:energy_gen_example_cefe">11.1.1</a>
-&gt; Use the same run too!</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">raw_data_manipulation -p ~/CastData/data/2018_2/Run_240_181021-14-54/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                      --out /t/raw_240.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                      --runType rtBackground
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">reconstruction /t/raw_240.h5 --out /t/reco_240.h5
</pre>
</div>
<div class="org-src-container">
<pre class="src src-sh">reconstruction /t/reco_240.h5 --only_fadc
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">raw_data_manipulation -p ~/CastData/data/2017/Run_96_171123-10-42 <span style="color: #E6DB74; font-weight: bold;">\</span>
                      --out /t/raw_96.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
                      --runType rtCalibration
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">reconstruction /t/raw_96.h5 --out /t/reco_96.h5
</pre>
</div>
<div class="org-src-container">
<pre class="src src-sh">reconstruction /t/reco_96.h5 --only_fadc
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> nimhdf5, ggplotnim
<span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>strutils, os, sequtils, strformat<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / <span style="color: #AE81FF;">[</span>tos_helpers<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / calibration / <span style="color: #AE81FF;">[</span>calib_fitting, calib_plotting<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / calibration 

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">stripPrefix</span><span style="color: #AE81FF;">(</span>s, p: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">string</span> =
  <span style="color: #FD971F;">result</span> = s
  <span style="color: #FD971F;">result</span>.removePrefix<span style="color: #AE81FF;">(</span>p<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">useTeX </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;USE_TEX&quot;</span>, <span style="color: #E6DB74;">&quot;false&quot;</span><span style="color: #AE81FF;">)</span>.parseBool
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Width</span> = getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;WIDTH&quot;</span>, <span style="color: #E6DB74;">&quot;600&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Height</span> = getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;HEIGHT&quot;</span>, <span style="color: #E6DB74;">&quot;450&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat

<span style="color: #F92672;">from</span> ginger <span style="color: #F92672;">import</span> transparent

<span style="color: #F92672;">const</span> <span style="color: #FD971F;">settings </span>= @<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;∫: 50 ns, ∂: 50 ns, G: 6x&quot;</span>,
                   <span style="color: #E6DB74;">&quot;∫: 50 ns, ∂: 20 ns, G: 10x&quot;</span>,
                   <span style="color: #E6DB74;">&quot;∫: 100 ns, ∂: 20 ns, G: 10x&quot;</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">runs </span>= @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">80</span>, <span style="font-style: italic;">101</span>, <span style="font-style: italic;">121</span><span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">const</span> <span style="color: #FD971F;">riseTimeS </span>= <span style="color: #E6DB74;">&quot;riseTime [ns]&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">fallTimeS </span>= <span style="color: #E6DB74;">&quot;fallTime [ns]&quot;</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">fadcSettings</span><span style="color: #AE81FF;">(</span>plt: <span style="color: #66D9EF;">GgPlot</span>, allRuns: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span>, hideText: <span style="color: #66D9EF;">bool</span>, minVal, maxVal, margin: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">GgPlot</span> =
  <span style="color: #E6DB74;">## This is a bit of a mess, but:</span>
  <span style="color: #E6DB74;">## It handles drawing the colored rectangles for the different FADC settings and</span>
  <span style="color: #E6DB74;">## adjusting the margin if any given via the R_MARGIN environment variable.</span>
  <span style="color: #E6DB74;">## The rectangle drawing is a bit ugly to look at, because we use the numbers initially</span>
  <span style="color: #E6DB74;">## intended for the peak position plot, but rescale them to map the completely different</span>
  <span style="color: #E6DB74;">## values for the other plots using min/max value and a potential margin.</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">mRight </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;R_MARGIN&quot;</span>, <span style="color: #E6DB74;">&quot;6.0&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">widths </span>= @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">101</span> - <span style="font-style: italic;">80</span>, <span style="font-style: italic;">121</span> - <span style="font-style: italic;">101</span>, allRuns.<span style="color: #F92672;">max</span> - <span style="font-style: italic;">121</span> + <span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Δ</span> = <span style="color: #AE81FF;">(</span>maxVal - minVal<span style="color: #AE81FF;">)</span> 
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">min </span>= minVal - <span style="color: #66D9EF;">Δ</span> * margin
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ys </span>= @<span style="color: #AE81FF;">[</span><span style="color: #F92672;">min</span>, <span style="color: #F92672;">min</span>, <span style="color: #F92672;">min</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">heights </span>= @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">25</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">25</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">25</span><span style="color: #AE81FF;">]</span>.mapIt<span style="color: #AE81FF;">(</span>it / <span style="font-style: italic;">0</span>.<span style="font-style: italic;">25</span> * <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">Δ</span> * <span style="color: #A6E22E;">(</span><span style="font-style: italic;">1</span> + <span style="font-style: italic;">2</span> * margin<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> 
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">textYs </span>= @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">325</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">27</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">22</span><span style="color: #AE81FF;">]</span>.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>it - <span style="font-style: italic;">0</span>.<span style="font-style: italic;">1</span><span style="color: #66D9EF;">)</span> / <span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">35</span> - <span style="font-style: italic;">0</span>.<span style="font-style: italic;">1</span><span style="color: #66D9EF;">)</span> * <span style="color: #66D9EF;">Δ</span> + minVal<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfRects </span>= toDf<span style="color: #AE81FF;">(</span>settings, ys, textYs, runs, heights, widths<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> dfRects
  <span style="color: #FD971F;">result</span> = plt +
    geom_tile<span style="color: #AE81FF;">(</span>data = dfRects, aes = aes<span style="color: #66D9EF;">(</span>x = <span style="color: #E6DB74;">&quot;runs&quot;</span>, y = <span style="color: #E6DB74;">&quot;ys&quot;</span>, height = <span style="color: #E6DB74;">&quot;heights&quot;</span>, width = <span style="color: #E6DB74;">&quot;widths&quot;</span>, fill = <span style="color: #E6DB74;">&quot;settings&quot;</span><span style="color: #66D9EF;">)</span>,
              alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">3</span><span style="color: #AE81FF;">)</span> +
    xlim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">80</span>, <span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span> +
    margin<span style="color: #AE81FF;">(</span>right = mRight<span style="color: #AE81FF;">)</span> +
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> 
  <span style="color: #F92672;">if</span> <span style="color: #F92672;">not</span> hideText:
    <span style="color: #FD971F;">result</span> = <span style="color: #FD971F;">result</span> + geom_text<span style="color: #AE81FF;">(</span>data = dfRects, aes = aes<span style="color: #66D9EF;">(</span>x = f<span style="color: #A6E22E;">{</span>`runs` + <span style="font-style: italic;">2</span><span style="color: #A6E22E;">}</span>, y = <span style="color: #E6DB74;">&quot;textYs&quot;</span>, text = <span style="color: #E6DB74;">&quot;settings&quot;</span><span style="color: #66D9EF;">)</span>, alignKind = taLeft<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">getSetting</span><span style="color: #AE81FF;">(</span>run: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">string</span> =
  <span style="color: #FD971F;">result</span> = settings<span style="color: #AE81FF;">[</span>lowerBound<span style="color: #66D9EF;">(</span>runs, run<span style="color: #66D9EF;">)</span> - <span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotFallTimeRiseTime</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, suffix: <span style="color: #66D9EF;">string</span>, allRuns: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span>, hideText: <span style="color: #66D9EF;">bool</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">## Given a full run of FADC data, create the</span>
  <span style="color: #E6DB74;">## Note: it may be sensible to compute a truncated mean instead</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfG </span>= df.group_by<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;runNumber&quot;</span><span style="color: #AE81FF;">)</span>.summarize<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: riseTimeS &lt;&lt; truncMean<span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;riseTime&quot;</span><span style="color: #E6DB74;">)</span>.toSeq1D, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">05</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span>,
                                               f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: fallTimeS &lt;&lt; truncMean<span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;fallTime&quot;</span><span style="color: #E6DB74;">)</span>.toSeq1D, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">05</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span> -&gt; <span style="color: #66D9EF;">string</span>: <span style="color: #E6DB74;">&quot;settings&quot;</span> ~ getSetting<span style="color: #A6E22E;">(</span>`runNumber`<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">width </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;WIDTH_RT&quot;</span>, <span style="color: #E6DB74;">&quot;600&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">height </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;HEIGHT_RT&quot;</span>, <span style="color: #E6DB74;">&quot;450&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">mRight </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;R_MARGIN&quot;</span>, <span style="color: #E6DB74;">&quot;4.0&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fontScale </span>= getEnv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;FONT_SCALE&quot;</span>, <span style="color: #E6DB74;">&quot;1.0&quot;</span><span style="color: #AE81FF;">)</span>.parseFloat

  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>rMin, rMax<span style="color: #AE81FF;">)</span> = <span style="color: #AE81FF;">(</span>dfG<span style="color: #66D9EF;">[</span>riseTimeS, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">min</span>, dfG<span style="color: #66D9EF;">[</span>riseTimeS, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">max</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">perc </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">025</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Δr</span> = <span style="color: #AE81FF;">(</span>rMax - rMin<span style="color: #AE81FF;">)</span> * perc
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">plt </span>= ggplot<span style="color: #AE81FF;">(</span>dfG, aes<span style="color: #66D9EF;">(</span>runNumber, riseTimeS<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + 
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;FADC signal rise times in ⁵⁵Fe data for all runs in </span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">&quot;</span> % suffix<span style="color: #AE81FF;">)</span> +
    margin<span style="color: #AE81FF;">(</span>right = mRight<span style="color: #AE81FF;">)</span> +
    <span style="color: #75715E;">#</span><span style="color: #75715E;">theme_font_scale(fontScale) +</span>
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = width, height = height, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +     
    ylim<span style="color: #AE81FF;">(</span>rMin - <span style="color: #66D9EF;">Δr</span>, rMax + <span style="color: #66D9EF;">Δr</span><span style="color: #AE81FF;">)</span>
  plt = plt.fadcSettings<span style="color: #AE81FF;">(</span>allRuns, hideText, rMin, rMax, perc<span style="color: #AE81FF;">)</span>
  plt + geom_point<span style="color: #AE81FF;">(</span>aes = aes<span style="color: #66D9EF;">(</span>color = fallTimeS<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Figs/FADC/fadc_mean_riseTime_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">.pdf&quot;</span> % suffix,
               width = width, height = height, useTeX = useTeX, standalone = useTeX<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>fMin, fMax<span style="color: #AE81FF;">)</span> = <span style="color: #AE81FF;">(</span>dfG<span style="color: #66D9EF;">[</span>fallTimeS, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">min</span>, dfG<span style="color: #66D9EF;">[</span>fallTimeS, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">max</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Δf</span> = <span style="color: #AE81FF;">(</span>fMax - fMin<span style="color: #AE81FF;">)</span> * <span style="font-style: italic;">1</span>.<span style="font-style: italic;">025</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">plt2 </span>= ggplot<span style="color: #AE81FF;">(</span>dfG, aes<span style="color: #66D9EF;">(</span>runNumber, fallTimeS<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + 
    margin<span style="color: #AE81FF;">(</span>right = mRight<span style="color: #AE81FF;">)</span> +
    ylim<span style="color: #AE81FF;">(</span>fMin - <span style="color: #66D9EF;">Δf</span>, fMax + <span style="color: #66D9EF;">Δf</span><span style="color: #AE81FF;">)</span> + 
    <span style="color: #75715E;">#</span><span style="color: #75715E;">theme_font_scale(fontScale) +</span>
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;FADC signal fall times in ⁵⁵Fe data for all runsin </span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">&quot;</span> % suffix<span style="color: #AE81FF;">)</span>
  plt2 = plt2.fadcSettings<span style="color: #AE81FF;">(</span>allRuns, hideText, fMin, fMax, perc<span style="color: #AE81FF;">)</span>
  plt2 + geom_point<span style="color: #AE81FF;">(</span>aes = aes<span style="color: #66D9EF;">(</span>color = riseTimeS<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Figs/FADC/fadc_mean_fallTime_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">.pdf&quot;</span> % suffix,
                width = width, height = height, useTeX = useTeX, standalone = useTeX<span style="color: #AE81FF;">)</span>

  ggplot<span style="color: #AE81FF;">(</span>dfG, aes<span style="color: #66D9EF;">(</span>riseTimeS, fallTimeS, color = <span style="color: #E6DB74;">&quot;settings&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + 
    geom_point<span style="color: #AE81FF;">()</span> +
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;FADC signal rise vs fall times for ⁵⁵Fe data in </span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">&quot;</span> % suffix<span style="color: #AE81FF;">)</span> +
    margin<span style="color: #AE81FF;">(</span>right = mRight<span style="color: #AE81FF;">)</span> +
    <span style="color: #75715E;">#</span><span style="color: #75715E;">theme_font_scale(fontScale) +</span>
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = width, height = <span style="color: #66D9EF;">Height</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> + 
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Figs/FADC/fadc_mean_riseTime_vs_fallTime_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">.pdf&quot;</span> % suffix,
           width = width, height = height, useTeX = useTeX, standalone = useTeX<span style="color: #AE81FF;">)</span>    

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">fit</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, year: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">DataFrame</span>, <span style="color: #66D9EF;">DataFrame</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span>fname, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fileInfo </span>= h5f.getFileInfo<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">is2017 </span>= year == <span style="font-style: italic;">2017</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">is2018 </span>= year == <span style="font-style: italic;">2018</span>
  <span style="color: #F92672;">if</span> <span style="color: #F92672;">not</span> is2017 <span style="color: #F92672;">and</span> <span style="color: #F92672;">not</span> is2018:
    <span style="color: #F92672;">raise</span> <span style="color: #F92672;">newException</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">IOError</span>, <span style="color: #E6DB74;">&quot;The input file is neither clearly a 2017 nor 2018 calibration file!&quot;</span><span style="color: #AE81FF;">)</span>
  
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">peakPos </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">actThr </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>  
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfProp </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> run <span style="color: #F92672;">in</span> fileInfo.runs:
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= h5f.readRunDsets<span style="color: #AE81FF;">(</span>
      run,
      commonDsets = @<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;fadc/eventNumber&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/baseline&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/riseStart&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/riseTime&quot;</span>,                  
                      <span style="color: #E6DB74;">&quot;fadc/fallStop&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/fallTime&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/minVal&quot;</span>,
                      <span style="color: #E6DB74;">&quot;fadc/argMinval&quot;</span><span style="color: #66D9EF;">]</span>                 
    <span style="color: #AE81FF;">)</span>
    df = df.rename<span style="color: #AE81FF;">(</span>df.getKeys.mapIt<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>it.stripPrefix<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;fadc/&quot;</span><span style="color: #E6DB74;">)</span> &lt;- it<span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;runNumber&quot;</span><span style="color: #AE81FF;">]</span> = run
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= h5f<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span>recoBase<span style="color: #A6E22E;">()</span> &amp; $run / <span style="color: #E6DB74;">&quot;fadc/fadc_data&quot;</span><span style="color: #66D9EF;">)</span>.dset_str<span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fadcData </span>= dset<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.toTensor.reshape<span style="color: #AE81FF;">(</span>dset.shape<span style="color: #AE81FF;">)</span>

    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">feSpec </span>= fitFeSpectrumFadc<span style="color: #AE81FF;">(</span>df<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;minVal&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toSeq1D<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ecData </span>= fitEnergyCalib<span style="color: #AE81FF;">(</span>feSpec, isPixel = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">texts </span>= buildTextForFeSpec<span style="color: #AE81FF;">(</span>feSpec, ecData<span style="color: #AE81FF;">)</span>
    plotFeSpectrum<span style="color: #AE81FF;">(</span>feSpec, run, <span style="font-style: italic;">3</span>, texts = texts, pathPrefix = <span style="color: #E6DB74;">&quot;Figs/FADC/fe55_fits/&quot;</span>, useTeX = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>

    <span style="color: #75715E;"># </span><span style="color: #75715E;">add fit to peak positions</span>
    peakPos.<span style="color: #F92672;">add</span> feSpec.pRes<span style="color: #AE81FF;">[</span>feSpec.idx_kalpha<span style="color: #AE81FF;">]</span>
    
    ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;minVal&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">300</span><span style="color: #AE81FF;">)</span> +
      ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/t/fadc_run_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">_minima.pdf&quot;</span> % $run<span style="color: #AE81FF;">)</span>

    <span style="color: #75715E;"># </span><span style="color: #75715E;">Now get the activation threshold as a function of gridpix energy on center</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">chip. Get GridPix data on center chip...</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfGP </span>= h5f.readRunDsets<span style="color: #AE81FF;">(</span>
      run,
      chipDsets = some<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>chip: <span style="font-style: italic;">3</span>, dsets: @<span style="color: #E6DB74;">[</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span>, <span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #E6DB74;">]</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
    <span style="color: #AE81FF;">)</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">...sum all clusters for each event (for multiple clusters, the FADC sees all)...</span>
    dfGP = dfGP.group_by<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #AE81FF;">)</span>.summarize<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span> -&gt; <span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span> &lt;&lt; sum<span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">... join with FADC DF to only have events left with FADC trigger...</span>
    df = innerJoin<span style="color: #AE81FF;">(</span>dfGP, df.clone<span style="color: #66D9EF;">()</span>, <span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #AE81FF;">)</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">...compute activation threshold as 1-th percentile of data</span>
    actThr.<span style="color: #F92672;">add</span> percentile<span style="color: #AE81FF;">(</span>df<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>, <span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>

    dfProp.<span style="color: #F92672;">add</span> df
  <span style="color: #F92672;">doAssert</span> h5f.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span> &gt;= <span style="font-style: italic;">0</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span> <span style="color: #E6DB74;">&quot;runs&quot;</span> : fileInfo.runs,
                  <span style="color: #E6DB74;">&quot;peaks&quot;</span> : peakPos,
                  <span style="color: #E6DB74;">&quot;actThr&quot;</span> : actThr <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>df, dfProp<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span>path: <span style="color: #66D9EF;">string</span>, year: <span style="color: #66D9EF;">int</span>, fit = <span style="color: #AE81FF;">false</span>, hideText = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">##    - run 101 &lt;2017-11-29 Wed 6:40&gt; was the first with FADC noise</span>
  <span style="color: #E6DB74;">##      significant enough to make me change settings:</span>
  <span style="color: #E6DB74;">##      - Diff: 50 ns -&gt; 20 ns (one to left)</span>
  <span style="color: #E6DB74;">##      - Coarse gain: 6x -&gt; 10x (one to right)</span>
  <span style="color: #E6DB74;">##    - run 112: change FADC settings again due to noise:</span>
  <span style="color: #E6DB74;">##      - integration: 50 ns -&gt; 100 ns</span>
  <span style="color: #E6DB74;">##        This was done at around &lt;2017-12-07 Thu 8:00&gt;</span>
  <span style="color: #E6DB74;">##      - integration: 100 ns -&gt; 50 ns again at around</span>
  <span style="color: #E6DB74;">##        &lt;2017-12-08 Fri 17:50&gt;.</span>
  <span style="color: #E6DB74;">##    - run 121: Jochen set the FADC main amplifier</span>
  <span style="color: #E6DB74;">##      integration time from 50 -&gt; 100 ns again, around</span>
  <span style="color: #E6DB74;">##      &lt;2017-12-15 Fri 10:20&gt;</span>
  
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">is2017 </span>= year == <span style="font-style: italic;">2017</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">yearToRun </span>= <span style="color: #F92672;">if</span> is2017: <span style="font-style: italic;">2</span> <span style="color: #F92672;">else</span>: <span style="font-style: italic;">3</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">suffix </span>= <span style="color: #E6DB74;">&quot;run</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">&quot;</span> % $yearToRun
  
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfProp </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= newDataFrame<span style="color: #AE81FF;">()</span>  
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">peakPos</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">if</span> fit:
    <span style="color: #AE81FF;">(</span>df, dfProp<span style="color: #AE81FF;">)</span> = fit<span style="color: #AE81FF;">(</span>path, year<span style="color: #AE81FF;">)</span>
    dfProp.writeCsv<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;resources/properties_fadc_{suffix}.csv&quot;</span><span style="color: #AE81FF;">)</span>
    df.writeCsv<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;resources/peak_positions_fadc_{suffix}.csv&quot;</span><span style="color: #AE81FF;">)</span>    
  <span style="color: #F92672;">else</span>:
    dfProp = readCsv<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{path}/properties_fadc_{suffix}.csv&quot;</span><span style="color: #AE81FF;">)</span>
    df = readCsv<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{path}/peak_positions_fadc_{suffix}.csv&quot;</span><span style="color: #AE81FF;">)</span>     

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">allRuns </span>= df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;runs&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span>.toSeq1D

  plotFallTimeRiseTime<span style="color: #AE81FF;">(</span>dfProp, suffix, allRuns, hideText<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">block</span> <span style="color: #66D9EF;">Fe55PeakPos</span>:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">outname </span>= <span style="color: #E6DB74;">&quot;Figs/FADC/peak_positions_fadc_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">.pdf&quot;</span> % $suffix
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">plt </span>= ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;runs&quot;</span>, <span style="color: #E6DB74;">&quot;peaks&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">if</span> is2017:
      plt = plt.fadcSettings<span style="color: #AE81FF;">(</span>allRuns, hideText, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">1</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">35</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
    plt + geom_point<span style="color: #AE81FF;">()</span> +
      ylim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">1</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">35</span><span style="color: #AE81FF;">)</span> +
      ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;⁵⁵Fe peak position [V]&quot;</span><span style="color: #AE81FF;">)</span> + xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Run number&quot;</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Peak position of the ⁵⁵Fe runs in the FADC data&quot;</span><span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span>outname, width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, useTeX = useTeX, standalone = useTeX<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">block</span> <span style="color: #66D9EF;">ActivationThreshold</span>:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">outname </span>= <span style="color: #E6DB74;">&quot;Figs/FADC/activation_threshold_gridpix_energy_fadc_</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">.pdf&quot;</span> % $suffix
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">plt </span>= ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;runs&quot;</span>, <span style="color: #E6DB74;">&quot;actThr&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">if</span> is2017:
      plt = plt.fadcSettings<span style="color: #AE81FF;">(</span>allRuns, hideText, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">4</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
    plt + geom_point<span style="color: #AE81FF;">()</span> +
      ylim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">4</span><span style="color: #AE81FF;">)</span> + 
      ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Activation threshold [keV]&quot;</span><span style="color: #AE81FF;">)</span> + xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Run number&quot;</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Activation threshold based on center GridPix energy&quot;</span><span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span>outname, width = <span style="color: #66D9EF;">Width</span>, height = <span style="color: #66D9EF;">Height</span>, useTeX = useTeX, standalone = useTeX<span style="color: #AE81FF;">)</span>
    

<span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">import</span> cligen
  dispatch main
</pre>
</div>

<ul class="org-ul">
<li class="on"><code>[X]</code> <b>REGENERATE FADC DATA IN H5 FILES ON <code>voidRipper</code></b></li>
<li class="on"><code>[X]</code> <b>GENERATE HISTOGRAMS OF MINVALS FOR ALL CALIBRATION RUNS</b></li>
<li class="on"><code>[X]</code> <b>GENERATE PLOT OF ALL FIT TO MINVALS HISTO FIND PEAK FOR ALL
CALIBRATION RUNS</b>
-&gt; start by just computing maximum of the above histogram for each
run as a basis</li>
<li class="off"><code>[ ]</code> <b>ALL THESE PLOTS SHOULD REALLY BE GENERATED WHEN RUNNING
<code>reconstruction --only_fadc</code>! Replace that!</b>
-&gt; Well.. Not today.</li>
<li class="on"><code>[X]</code> <b>GENERATE PLOT OF FADC &amp; GridPix PEAK POSITIONS AGAINST ALL
RUNS</b>
-&gt; Done and in previous section (at least for relevant runs)</li>
</ul>

<p>
Run the code for 2017 calibration data to generate the plot of the
FADC settings (and generate the CSV containing the peak positions by run):
</p>
<div class="org-src-container">
<pre class="src src-sh">./code/fadc_rise_fall_different_settings.nim -p ~/CastData/data/CalibrationRuns2017_Reco.h5 --fit --year 2017
</pre>
</div>
<p>
and now for 2018 to generate the CSV for the peak positions of the run
3 data:
</p>
<div class="org-src-container">
<pre class="src src-sh">./code/fadc_rise_fall_different_settings.nim -p ~/CastData/data/CalibrationRuns2018_Reco.h5 --fit --year 2018
</pre>
</div>

<p>
To generate the final plots we use the generated CSV files (in order
to more quickly change parameters about the size of plots etc):
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">FONT_SCALE</span>=1.2 <span style="color: #FD971F;">R_MARGIN</span>=7.5 <span style="color: #FD971F;">RT_MARGIN</span>=3.0 <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=360 <span style="color: #FD971F;">HEIGHT_RT</span>=420 <span style="color: #E6DB74; font-weight: bold;">\</span>
             code/fadc_rise_fall_different_settings <span style="color: #E6DB74; font-weight: bold;">\</span>
             -p resources <span style="color: #E6DB74; font-weight: bold;">\</span>
             --year 2017 <span style="color: #E6DB74; font-weight: bold;">\</span>
             --hideText
<span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #FD971F;">FONT_SCALE</span>=1.2 <span style="color: #FD971F;">R_MARGIN</span>=7.5 <span style="color: #FD971F;">RT_MARGIN</span>=3.0 <span style="color: #FD971F;">WIDTH</span>=600 <span style="color: #FD971F;">HEIGHT</span>=360 <span style="color: #FD971F;">HEIGHT_RT</span>=420 <span style="color: #E6DB74; font-weight: bold;">\</span>
             code/fadc_rise_fall_different_settings <span style="color: #E6DB74; font-weight: bold;">\</span>
             -p resources <span style="color: #E6DB74; font-weight: bold;">\</span>
             --year 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
             --hideText
</pre>
</div>

<p>
The CSV files are found in:
</p>
<ul class="org-ul">
<li>  <a href="./resources/peak_positions_fadc_run2.csv">./resources/peak_positions_fadc_run2.csv</a></li>
<li>  <a href="./resources/peak_positions_fadc_run3.csv">./resources/peak_positions_fadc_run3.csv</a></li>
<li>  <a href="./resources/properties_fadc_run2.csv">./resources/properties_fadc_run2.csv</a></li>
<li>  <a href="./resources/properties_fadc_run3.csv">./resources/properties_fadc_run3.csv</a></li>
</ul>

<p>
and the plots we generated are all in:
<a href="./Figs/FADC/">./Figs/FADC/</a>
with the \cefe fits in
<a href="./Figs/FADC/fe55_fits/">./Figs/FADC/fe55_fits/</a>
</p>
</div>
</div>
<div id="outline-container-orge896e10" class="outline-5">
<h5 id="orge896e10">  <a href="#orge896e10">  <span class="section-number-5">11.4.2.3.</span> Initial study of activation threshold   <span class="tag">    <span class="extended">extended</span>  </span></a></h5>
<div id="text-11-4-2-3" class="outline-text-5">
<p>
This section was the ideas and code that I initially wrote when I
first thought about including something about the activation threshold
for the FADC. At that point I had never actually tried to quantify
what the threshold was (I obviously had a pretty good idea based on
other aspects).
</p>

<dl class="org-dl">
<dt>How to compute?</dt><dd>The fits we perform for the 55 Fe in one of our
scripts here ideally should be done for each run again… That way
we could compute the energy similar to what we do for GridPix
data. Ideally we could compute it more by using an integral approach
though, as that gives us a better proxy for the amount of charge. Or
at least using a peak finding to detect multiple signals within one
FADC event to sum energies of both.
As an easier approach we can of course compute a lower percentile
(not the total minimum, but maybe 1% of each run and plot that?).</dd>
</dl>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> nimhdf5, ggplotnim
<span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>strutils, os, sequtils<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / <span style="color: #AE81FF;">[</span>tos_helpers, fadc_helpers, ingrid_types, fadc_analysis<span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">fadcSettingRuns</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #FD971F;">result</span> = @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>, <span style="font-style: italic;">101</span>, <span style="font-style: italic;">121</span><span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">stripPrefix</span><span style="color: #AE81FF;">(</span>s, p: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">string</span> =
  <span style="color: #FD971F;">result</span> = s
  <span style="color: #FD971F;">result</span>.removePrefix<span style="color: #AE81FF;">(</span>p<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">minimum</span><span style="color: #AE81FF;">(</span>h5f: <span style="color: #66D9EF;">H5File</span>, runNumber: <span style="color: #66D9EF;">int</span>, percentile: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">float</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= h5f.readRunDsets<span style="color: #AE81FF;">(</span>
    runNumber,
    chipDsets = some<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>chip: <span style="font-style: italic;">3</span>, dsets: @<span style="color: #E6DB74;">[</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span>, <span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #E6DB74;">]</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>
  <span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">sum all energies of all same events to get a combined energy of all</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">clusters on the center chip in each event (to correlate w/ FADC)</span>
  df = df.group_by<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #AE81FF;">)</span>.summarize<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span> -&gt; <span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span> &lt;&lt; sum<span style="color: #A6E22E;">(</span>col<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">run </span>= h5f.readRecoFadc<span style="color: #AE81FF;">(</span>runNumber<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fEvs </span>= h5f.readRunDsets<span style="color: #AE81FF;">(</span>runNumber, fadcDsets = @<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">minVals </span>= run.minVal.toSeq1D
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfFadc </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span> <span style="color: #E6DB74;">&quot;eventNumber&quot;</span> : fEvs<span style="color: #A6E22E;">[</span><span style="color: #E6DB74;">&quot;eventNumber&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">]</span>,
                      <span style="color: #E6DB74;">&quot;minVals&quot;</span> : minVals <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">join both by `</span><span style="color: #AE81FF;">eventNumber</span><span style="color: #75715E;">` (dropping center chip events w/ no FADC)</span>
  df = innerJoin<span style="color: #AE81FF;">(</span>df, dfFadc, <span style="color: #E6DB74;">&quot;eventNumber&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">percentile based on minvals &amp; gridpix energy</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>percentile<span style="color: #66D9EF;">(</span>minVals, <span style="font-style: italic;">100</span> - percentile<span style="color: #66D9EF;">)</span>, percentile<span style="color: #66D9EF;">(</span>df<span style="color: #A6E22E;">[</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">]</span>, percentile<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, percentile: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span>fname, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fileInfo </span>= h5f.getFileInfo<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">echo</span> fileInfo
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">minimaFadc </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">minimaGP </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>  
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">idxs </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">for</span> run <span style="color: #F92672;">in</span> fileInfo.runs:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">idx </span>= lowerBound<span style="color: #AE81FF;">(</span>fadcSettingRuns<span style="color: #66D9EF;">()</span>, run<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;idx &quot;</span>, idx, <span style="color: #E6DB74;">&quot; for run &quot;</span>, run
    <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>minFadc, minEnergy<span style="color: #AE81FF;">)</span> = minimum<span style="color: #AE81FF;">(</span>h5f, run, percentile<span style="color: #AE81FF;">)</span>
    minimaFadc.<span style="color: #F92672;">add</span> minFadc
    minimaGP.<span style="color: #F92672;">add</span> minEnergy
    idxs.<span style="color: #F92672;">add</span> idx

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span>minimaFadc, minimaGP, idxs<span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;minimaFadc&quot;</span>, fill = <span style="color: #E6DB74;">&quot;idxs&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_histogram<span style="color: #AE81FF;">(</span>position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, hdKind = hdOutline<span style="color: #AE81FF;">)</span> +
    xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Pulse amplitude [V]&quot;</span><span style="color: #AE81FF;">)</span> + ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Counts&quot;</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Activation threshold by smallest pulses triggering FADC&quot;</span><span style="color: #AE81FF;">)</span> +
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="font-style: italic;">600</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +
    margin<span style="color: #AE81FF;">(</span>right = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +    
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/FADC/fadc_minima_histo_activation_threshold_mV.pdf&quot;</span>,
           useTeX = <span style="color: #AE81FF;">true</span>, standalone = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>

  ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;minimaGP&quot;</span>, fill = <span style="color: #E6DB74;">&quot;idxs&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_histogram<span style="color: #AE81FF;">(</span>position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, hdKind = hdOutline<span style="color: #AE81FF;">)</span> +
    xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Energy on GridPix [keV]&quot;</span><span style="color: #AE81FF;">)</span> + ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Counts&quot;</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Activation threshold by energy recorded on center GridPix&quot;</span><span style="color: #AE81FF;">)</span> +
    themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="font-style: italic;">600</span>, baseTheme = singlePlot<span style="color: #AE81FF;">)</span> +
    margin<span style="color: #AE81FF;">(</span>right = <span style="font-style: italic;">2</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/FADC/fadc_minima_histo_gridpix_energy.pdf&quot;</span>,
           useTeX = <span style="color: #AE81FF;">true</span>, standalone = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">import</span> cligen
  dispatch main
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">./code/fadc_compute_activation_threshold -f ~/CastData/data/CalibrationRuns2017_Reco.h5 --percentile 1
</pre>
</div>

<p>
The produced fig. <a href="#fig:fadc:activation_threshold_histo_mV_histo_run2">16</a>
of the largest values found for the activation of the
FADC shows us the actual activation thresholds for the FADC in
volt. We can see that generally the threshold remained constant in
terms of milli volt. That&apos;s good to know.
</p>


<figure id="fig:fadc:activation_threshold_histo_mV_histo_run2">
<img alt="fadc_minima_histo_activation_threshold_mV.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadc_minima_histo_activation_threshold_mV.svg" />

<figcaption>Figure 16: <span class="figure-number">Figure 50: </span>Different activation thresholds of the Run-2 data due to different FADC settings, determined based on the 1-th percentile of the data in the \cefe calibration runs, by using the energy of the center GridPix.</figcaption>
</figure>

<p>
The second plot fig. <a href="#fig:fadc:activation_threshold_histo_run2">17</a> shows
the activation in terms of the sum of all clusters energies (for one
event number, to take into account multiple clusters) based on the
GridPix energy. Here we see the &apos;real&apos; activation energy in keV and
can see that unfortunately for the later settings the threshold was
very high. :(
</p>


<figure id="fig:fadc:activation_threshold_histo_run2">
<img alt="fadc_minima_histo_gridpix_energy.svg" class="org-svg" src="./figs/home/basti/phd/Figs/FADC/fadc_minima_histo_gridpix_energy.svg" />

<figcaption>Figure 17: <span class="figure-number">Figure 51: </span>Different activation thresholds of the Run-2 data due to different FADC settings, determined based on the 1-th percentile of the data in the \cefe calibration runs, by using the energy of the center GridPix.</figcaption>
</figure>


<p>
Of course this itself does not imply a difference in activation
threshold of the equivalent physical energy!
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>COMPUTE IN ENERGY INSTEAD OF VOLTAGE</b></li>
</ul>

<p>
<b>NOTE</b>: From the FADC plots here (pure FADC &amp; GridPix energy
correlated) as well as the raw FADC spectra it&apos;s clearly evident that
the actual gain of the FADC went <span class="underline">down</span> instead of up after changing
diff 50-&gt;20ns and coarse gain 6x-&gt;10x and further when going from
50ns-100ns integration time.
To some extent this may make sense: differentiation
</p>

<p>
According to FADC manual the &quot;differentiation&quot; setting adjusts the RC
differentiation time and therefore
</p>
<blockquote>
<p>
DIFFERENTIATE Front panel 6-position switch
selects a differentiation time constant to control the
decay time of the pulse; settings select Out
(equivalent to 150 µs), 20, 50, 100, 200, or 500 ns.
</p>

<p>
INTEGRATE Front panel 6-position switch selects
an integration time constant to control the risetime
of the pulse; settings select 20, 50, 100,
</p>
</blockquote>
<p>
And further:
</p>
<blockquote>
<p>
Generally speaking, the Integrate time constant can
be selected so that the rise time of the output
pulses is normalized at a rate that is slower than
the rise times of the input pulses. This function is of
greatest value when the pulses originate in a large
detector so that they generate a wide variety of rise
times and are difficult to observe for timing
measurements. The Differentiate time constant is
also selectable and determines the total interval
before the pulse returns to the baseline and allows
a new pulse to be observed. The combination of
integration and differentiation time constants also
contributes to the amount of electronic noise that is
seen in the system, so the resulting waveforms
should be considered from each of these points of
view and adjusted for optimum results.
</p>

<p>
When the shaping time constants impose
considerable changes in the input waveform, the
nominal gain, which is the product of the Coarse
and Fine control settings, may be degraded
somewhat. This is not normally a problem, since
the gain is constant even though it may be less
than the nominal settings indicate. 
</p>
</blockquote>

<p>
I.e. this means the differentiation time is responsible for getting
the signal back to baseline. And it&apos;s expected that it has an effect
on the amplitude on the signal!
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>ADD ABOVE AS EXPLANATION FOR THE SEEN BEHAVIOR</b>
-&gt; maybe 4 fold plot:
<ul class="org-ul">
<li>histogram as above for lower percentile energies of min vals &amp;
gridpix energies together with three spectra, one for each setting
combined in one plot?</li>
</ul></li>
</ul>

<p>
All this is effectively good news. This explains also <span class="underline">why</span> the
changes to the integration / differentiation had such an effect on the
noise! They simply reduced the effective gain, ergo made the FADC less
sensitive to the same noise!    
</p>

<p>
Ref:
<a href="https://www.ortec-online.com/-/media/ametekortec/manuals/4/474-mnl.pdf?la=en&amp;revision=07c47ecb-5c63-48ff-a393-ba39e45be57b">https://www.ortec-online.com/-/media/ametekortec/manuals/4/474-mnl.pdf?la=en&amp;revision=07c47ecb-5c63-48ff-a393-ba39e45be57b</a>
from here:
<a href="https://www.ortec-online.com/products/electronics/amplifiers/474">https://www.ortec-online.com/products/electronics/amplifiers/474</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org35589d7" class="outline-4">
<h4 id="org35589d7">  <a href="#org35589d7">  <span class="section-number-4">11.4.3.</span> How to compute an effective charge based on FADC signals? <code>[0/1]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></h4>
<div id="text-11-4-3" class="outline-text-4">
<ul class="org-ul">
<li class="on"><code>[X]</code> The ideas of this section have been merged into the general FADC section</li>
</ul>

<p>
This section should cover our ideas about how we compute an effective
charge (in arbitrary units) based on the FADC signals as a measure
about the effective charge recorded in a signal. To cross correlate
changes in FADC &quot;charge&quot; to GridPix charge.
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> -&gt; is detector behavior over time visible in FADC data?</li>
</ul>

<p>
-&gt; Looking at <img alt="time_vs_55fe_peak_pos_2017.svg" class="org-svg" src="./figs/home/basti/phd/Figs/time_vs_55fe_peak_pos_2017.svg" /> generated via
</p>
<div class="org-src-container">
<pre class="src src-sh">./mapSeptemTempToFePeak ~/CastData/data/CalibrationRuns2017_Reco.h5 --inputs fePixel --inputs feCharge --inputs feFadc
</pre>
</div>
<p>
shows a <span class="underline">very</span> strong correlation between all three kinds of
calibration.
</p>

<p>
Note the strong fall in the FADC data in the &quot;left hump&quot; of points is
the change of the integration / differentiation time during the 2017
data taking (up to Dec 2017). But looking closely even there a strong
correlation is visible inside of each &quot;block&quot;.
</p>

<p>
This puts to rest at least <span class="underline">most</span> theories that the change might <span class="underline">not</span>
be a change in the gas gain, but some other effect like electronics!
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>EXPAND ON THE ABOVE, EXPLAIN THAT IN DETECTOR BEHAVIOR OVER
TIME!</b>
-&gt; given that also temperature is not properly correlated it leaves
charge up effects (changing effective voltage) and gas flow
(unlikely as flow constant &amp; pressure always stable).</li>
</ul>
</div>
</div>
</div>
</div>

<div id="footnotes"><h2 class="footnotes">Footnotes: </h2><div class="footdef"><sup>  <a id="fn.1" href="#fnr.1" class="footnum" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
Note that the term &apos;calibration&apos; is a heavily
loaded term implying very different things depending on context. This can at
times be confusing. I try to be explicit by fully specifying what
calibration is meant when it might be ambiguous. 
</p></div></div>

<div class="footdef"><sup>  <a id="fn.2" href="#fnr.2" class="footnum" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
Once again, in hindsight writing a log file of the
high voltage values would have been valuable, especially as it could
have been done straight from TOS. However, similar to what lead to
losses of the temperature log files, this was simply not prioritized
to implement at the time. The same holds for the gas pressure in the
chamber, which should have been logged using the <code>FlowView</code> software
of the Bronkhorst pressure controller used to control it.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.3" href="#fnr.3" class="footnum" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
From other Iseg HV modules used in lab
course experiments we know that when they <span class="underline">are</span> faulty it is very
evident. We have never experienced a module that reads correct values,
but actually supplies the wrong voltage. In each faulty case the
desired target voltage was simply not correctly held and this was
visible in the read out voltage.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.4" href="#fnr.4" class="footnum" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
Both the gas gain time slicing and the
minimum length for the last slice in a run to be kept as a shorter
slice can be configured from the TPA configuration file, via the
<code>gasGainInterval</code> and <code>minimumGasGainInterval</code> fields, respectively.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.5" href="#fnr.5" class="footnum" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
The frequencies are on the low end in terms of common
radio communication frequencies. The leading assumption has always
been that the source likely points to noise produced by e.g. the
motors moving the CAST magnet and similar.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.6" href="#fnr.6" class="footnum" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
I started with a simple implementation, intending
to replace it later. But it worked well enough that I simply kept it
so far.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.7" href="#fnr.7" class="footnum" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
At least to my memory and notes, which should otherwise
contain that.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.8" href="#fnr.8" class="footnum" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
We use a truncated mean of all data within the \(5^{\text{th}}\)
and \(95^{\text{th}}\) percentile if the rise and fall time values. This is just to
make the numbers less susceptible to extreme outliers. Alternatively,
we could of course also look at the median for example.
</p></div></div>

<div class="footdef"><sup>  <a id="fn.9" href="#fnr.9" class="footnum" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote">  <p class="footpara">
As with everything, this is only an approximation and
completely neglects possible nonlinearities in amplitude vs. integral
and so on. But it works well for its purpose here.
</p></div></div>

</div>
<div class="hint-message">Click on any heading marked '<span class="extended">extended</span>' to open it</div>
</div>
</body>
</html>
