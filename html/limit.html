<!DOCTYPE html>
<html lang="en">
<head>
<!--  2024-06-19 Wed 11:26  -->
<meta charset="utf-8" />
<meta content="width=device-width, initial-scale=1" name="viewport" />
<title>‎</title>
<meta content="Vindaar" name="author" />
<meta content="Org Mode" name="generator" />

<link type="text/css" rel="stylesheet" href="org_html_export.css" />
<script type="text/javascript">

document.addEventListener('DOMContentLoaded', function() {
    // Set the initial width for subfigures and their images
    document.querySelectorAll('figure.subfigure[data-width]').forEach(function(subfigure) {
        subfigure.style.width = subfigure.getAttribute('data-width');
    });

    document.querySelectorAll('figure.subfigure img[data-width]').forEach(function(img) {
        img.style.width = img.getAttribute('data-width');
    });

    // Event listener for images within subfigures
    document.querySelectorAll('figure.subfigure img[data-width]').forEach(function(img) {
        img.addEventListener('click', function() {
            // Determine the .figure-wrapper that contains the clicked image
            let wrapper = this.closest('.figure-wrapper');

            // If found, adjust the sizes of its subfigures
            if (wrapper) {
                let subfigures = wrapper.querySelectorAll('figure.subfigure');
                subfigures.forEach(subfigure => {
                    let width = parseFloat(subfigure.getAttribute('data-width'));
                    if (width < 50) { // Double size if less than 50%
                        subfigure.setAttribute('data-width', (width * 2) + '%');
                        subfigure.style.width = (width * 2) + '%';
                    } else { // Halve size otherwise
                        subfigure.setAttribute('data-width', (width / 2) + '%');
                        subfigure.style.width = (width / 2) + '%';
                    }
                });
            }
        });
    });
});

document.addEventListener('DOMContentLoaded', function () {
    var headers = document.querySelectorAll('h1 .extended, h2 .extended, h3 .extended, h4 .extended, h5 .extended, h6 .extended');

    headers.forEach(function (header) {
        var foldableHeader = header.closest('h1, h2, h3, h4, h5, h6');
        if (foldableHeader) {
            foldableHeader.classList.add('foldable-header');
            var nextElement = foldableHeader.nextElementSibling;
            var contentToFold = [];
            while (nextElement && !nextElement.matches('h1, h2, h3, h4, h5, h6')) {
                contentToFold.push(nextElement);
                nextElement = nextElement.nextElementSibling;
            }
            contentToFold.forEach(function (element) {
                element.classList.add('folded-content');
            });

            foldableHeader.addEventListener('click', function () {
                contentToFold.forEach(function (element) {
                    if (element.style.display === 'none' || element.style.display == '') {
                        element.style.display = 'block';
                    } else {
                        element.style.display = 'none';
                    }
                });
            });
        }
    });
});

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/x-mathjax-config">
<!-- /* --><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js", "[Contrib]/siunitx/siunitx.js", "[Contrib]/mhchem/mhchem.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"], ['$', '$'], ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 1.0,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        },
        TeX: {
              equationNumbers: { autoNumber: 'AMS' },
              Macros: {
                  ccsini: '{\\mathrm{Si}₃\\mathrm{N}₄}',
                  cefe: '{\\ce{^{55}Fe}}',
                  vektor: ['{\\begin{pmatrix}#1\\end{pmatrix}}', 1],
                  mtrix: ['{\\begin{pmatrix}#1\\end{pmatrix}}', 1],
                  cp: '{\\mathrm{CP}}',
                  cpt: '{\\mathrm{CPT}}',
                  dd: '{\\mathop{}\\!{\\mathrm{d}}}',
                  sinc: '{\\mathrm{sinc}}'
              }
        }
    });
/*]]>*///--&gt;
</script>
</head>
<body>
<div id="content" class="content">
<nav role="doc-toc" id="table-of-contents">
<h2>Table of Contents</h2>
<div role="doc-toc" id="text-table-of-contents">
<ul>
<li>  <a href="./errata.html#sec:errata">1. Errata   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./introduction.html#sec:introduction">2. Introduction   <span class="tag">    <span class="Intro">Intro</span>  </span></a></li>
<li><a href="./about_thesis.html#sec:about_thesis">3. About this thesis   <span class="tag">  <span class="Intro">Intro</span></span></a>
<ul>
<li>  <a href="./about_thesis.html#orgc359be8">3.1. Extended notes for the extended thesis <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./about_thesis.html#orgac66ba2">3.2. Why Org mode   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./about_thesis.html#org82d468e">3.3. Notes for future PhD students and IAXO analyses   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./theory.html#sec:theory">4. Theory of axions   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./theory.html#sec:theory:useful_reading_material">4.1. Useful reading material   <span class="tag">    <span class="optional">optional</span>  </span></a></li>
<li>  <a href="./theory.html#sec:theory:illustration_cpt">4.2. Illustration of the \cpt symmetry <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./theory.html#sec:theory:invisible_axion_models">4.3. Invisible axion models and axion couplings</a></li>
<li>  <a href="./theory.html#sec:theory:axion_interactions">4.4. Implications for axion interactions - conversion probability</a></li>
<li>  <a href="./theory.html#sec:theory:solar_axion_flux">4.5. Solar axion flux</a></li>
<li>  <a href="./theory.html#sec:theory:chameleon">4.6. Chameleons</a></li>
<li>  <a href="./theory.html#sec:theory:current_bounds">4.7. Current bounds on coupling constants</a></li>
</ul>
</li>
<li><a href="./helioscopes.html#sec:helioscopes">5. Axion helioscopes   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./helioscopes.html#sec:helioscopes:cast">5.1. CERN Axion Solar Telescope (CAST)</a></li>
<li>  <a href="./helioscopes.html#sec:helioscopes:iaxo">5.2. International AXion Observatory (IAXO)</a></li>
</ul>
</li>
<li><a href="./theory_detector.html#sec:theory_detector">6. X-rays, cosmic muons and gaseous detectors   <span class="tag">  <span class="Theory">Theory</span></span></a>
<ul>
<li>  <a href="./theory_detector.html#sec:theory:particle_int">6.1. Particle interactions with matter</a></li>
<li>  <a href="./theory_detector.html#sec:theory:cosmic_radiation">6.2. Cosmic rays</a></li>
<li>  <a href="./theory_detector.html#sec:theory:gas_fundamentals">6.3. Gaseous detector fundamentals</a></li>
</ul>
</li>
<li><a href="./septemboard.html#sec:septemboard">7. Septemboard detector   <span class="tag">  <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./septemboard.html#sec:detector:micromegas">7.1. Micromegas working principle</a></li>
<li>  <a href="./septemboard.html#sec:detector:timepix">7.2. Timepix ASIC</a></li>
<li>  <a href="./septemboard.html#sec:detector:gridpix">7.3. GridPix</a></li>
<li>  <a href="./septemboard.html#sec:detector:detector_2014_15">7.4. 2014 / 2015 GridPix detector for CAST</a></li>
<li>  <a href="./septemboard.html#sec:detector:detector_overview">7.5. Septemboard detector overview</a></li>
<li>  <a href="./septemboard.html#org0096c08">7.6. Detector readout system</a></li>
<li>  <a href="./septemboard.html#sec:detector:scintillators">7.7. Scintillator vetoes</a></li>
<li>  <a href="./septemboard.html#sec:detector:fadc">7.8. FADC</a></li>
<li>  <a href="./septemboard.html#sec:detector:sin_window">7.9. SiN window</a></li>
<li>  <a href="./septemboard.html#sec:detector:septemboard">7.10. Septemboard - 6 GridPixes around a center one</a></li>
<li>  <a href="./septemboard.html#sec:detector:water_cooling">7.11. Water cooling and temperature readout for the septemboard</a></li>
<li>  <a href="./septemboard.html#sec:septem:efficiency">7.12. Detector efficiency</a></li>
<li>  <a href="./septemboard.html#sec:detector:daq">7.13. Data acquisition and detector monitoring</a></li>
</ul>
</li>
<li><a href="./operation_calibration.html#sec:operation_calibration">8. Detector calibration for operation   <span class="tag">  <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:timepix">8.1. Timepix calibrations</a></li>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:fadc">8.2. FADC calibration</a></li>
<li>  <a href="./operation_calibration.html#sec:operation_calibration:scintillators">8.3. Scintillator calibration</a></li>
</ul>
</li>
<li><a href="./reconstruction.html#sec:reconstruction">9. Data reconstruction   <span class="tag">  <span class="Reconstruction">Reconstruction</span></span></a>
<ul>
<li>  <a href="./reconstruction.html#sec:reco:tpa">9.1. <code>TimepixAnalysis</code> and Nim</a></li>
<li>  <a href="./reconstruction.html#sec:reco:tos_data_parsing">9.2. TOS data parsing</a></li>
<li>  <a href="./reconstruction.html#sec:reco:event_shape">9.3. Expectation of event shapes</a></li>
<li>  <a href="./reconstruction.html#sec:reco:data_reconstruction">9.4. Data reconstruction</a></li>
<li>  <a href="./reconstruction.html#sec:reco:fadc_data">9.5. FADC reconstruction</a></li>
<li>  <a href="./reconstruction.html#sec:reco:scintillator_data">9.6. Scintillator data</a></li>
</ul>
</li>
<li><a href="./cast.html#sec:cast">10. Detector installation &amp; data taking at CAST   <span class="tag">  <span class="CAST">CAST</span></span></a>
<ul>
<li>  <a href="./cast.html#sec:cast:timeline">10.1. Timeline</a></li>
<li>  <a href="./cast.html#sec:cast:alignment">10.2. Alignment</a></li>
<li>  <a href="./cast.html#sec:cast:detector_setup">10.3. Detector setup at CAST</a></li>
<li>  <a href="./cast.html#sec:cast:window_accident">10.4. Window accident</a></li>
<li>  <a href="./cast.html#sec:cast:data_taking_woes">10.5. Data taking woes</a></li>
<li>  <a href="./cast.html#sec:cast:data_taking_campaigns">10.6. Summary of CAST data taking</a></li>
</ul>
</li>
<li><a href="./calibration.html#sec:calibration">11. Data calibration   <span class="tag">  <span class="Calibration">Calibration</span></span></a>
<ul>
<li>  <a href="./calibration.html#sec:calibration:energy">11.1. Energy calibration - in principle</a></li>
<li>  <a href="./calibration.html#sec:calib:detector_behavior_over_time">11.2. Detector behavior over time</a></li>
<li>  <a href="./calibration.html#sec:calib:final_energy_calibration">11.3. Energy calibration dependence on the gas gain</a></li>
<li>  <a href="./calibration.html#sec:calib:fadc">11.4. FADC</a></li>
</ul>
</li>
<li><a href="./background.html#sec:background">12. Finding signal and defining background | Background rate computation   <span class="tag">  <span class="Analysis">Analysis</span></span></a>
<ul>
<li>  <a href="./background.html#sec:background:likelihood_method">12.1. Likelihood method</a></li>
<li>  <a href="./background.html#sec:cdl">12.2. CAST Detector Lab</a></li>
<li>  <a href="./background.html#sec:background:likelihood_cut">12.3. Application of likelihood cut for background rate</a></li>
<li>  <a href="./background.html#sec:background:mlp">12.4. Artificial neural networks as cluster classifiers</a></li>
<li>  <a href="./background.html#sec:background:additional_vetoes">12.5. Additional detector features as vetoes</a></li>
<li>  <a href="./background.html#sec:background:all_vetoes_combined">12.6. Background rates of combined vetoes and efficiencies</a></li>
</ul>
</li>
<li><a href="./limit.html#sec:limit">13. Limit calculation   <span class="tag">  <span class="Limit">Limit</span></span></a>
<ul>
<li>  <a href="./limit.html#sec:limit:method_introduction">13.1. Limit method - introduction</a></li>
<li>  <a href="./limit.html#sec:limit:method_likelihood">13.2. Limit method - likelihood function \(\mathcal{L}\)</a></li>
<li>  <a href="./limit.html#sec:limit:method_computing_L">13.3. Limit method - computing \(\mathcal{L}\)</a></li>
<li>  <a href="./limit.html#sec:limit:method_computing_a_limit">13.4. Limit method - computing a limit</a></li>
<li>  <a href="./limit.html#sec:limit:method_expected_limit">13.5. Limit method - toy candidate sets and expected limits</a></li>
<li>  <a href="./limit.html#sec:limit:method_systematics">13.6. Limit method - extending \(\mathcal{L}\) for systematics</a></li>
<li>  <a href="./limit.html#sec:limit:method_mcmc">13.7. Limit method - evaluating \(\mathcal{L}\) with nuisance parameters</a></li>
<li>  <a href="./limit.html#org3d73a7f">13.8. Note about likelihood integral   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#org610c782">13.9. Derivation of short form of \(\mathcal{L}\) <code>[/]</code>   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#sec:limit:ingredients">13.10. Likelihood ingredients in detail</a></li>
<li>  <a href="./limit.html#sec:limit:systematics">13.11. Systematics</a></li>
<li>  <a href="./limit.html#sec:limit:mcmc_calc_limit">13.12. MCMC to sample the distribution and compute a limit</a></li>
<li>  <a href="./limit.html#sec:limit:expected_limits">13.13. Expected limits of different setups</a></li>
<li>  <a href="./limit.html#sec:limit:candidates">13.14. Solar tracking candidates</a></li>
<li>  <a href="./limit.html#sec:limit:observed_limit">13.15. Observed limit - \(g_{ae}\)</a></li>
<li>  <a href="./limit.html#sec:limit:other_couplings">13.16. Other coupling constants</a></li>
<li>  <a href="./limit.html#org4cc5303">13.17. Comparison to 2013 limit (using their method)   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./limit.html#orgb25e096">13.18. Observed limit for different axion masses   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./outlook.html#sec:outlook">14. Outlook</a></li>
<li>  <a href="./summary.html#sec:summary">15. Summary &amp; conclusion</a></li>
<li>  <a href="./bibliography.html#sec:bibliography">16. Bibliography   <span class="tag">    <span class="html">html</span>  </span></a></li>
<li><a href="./daq.html#sec:daq">17. Data acquisition and detector monitoring   <span class="tag"><span class="Appendix">Appendix</span> <span class="Detector">Detector</span></span></a>
<ul>
<li>  <a href="./daq.html#sec:daq:tof">17.1. Timepix Operating Firmware - TOF</a></li>
<li>  <a href="./daq.html#sec:daq:tos">17.2. Timepix Operating Software - TOS</a></li>
<li>  <a href="./daq.html#sec:daq:septemboard_event_display">17.3. Septemboard event display</a></li>
</ul>
</li>
<li><a href="./configuration.html#sec:appendix:configuration">18. Configuration and TOS / TOF versions   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./configuration.html#sec:appendix:configuration:tos_config">18.1. TOS configuration file</a></li>
<li>  <a href="./configuration.html#sec:appendix:configuration:tos_tof_versions">18.2. TOS and TOF versions used at CAST</a></li>
</ul>
</li>
<li><a href="./calibration.html#sec:appendix:calibration">19. Calibrations   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./calibration.html#sec:appendix:calibration:timepix">19.1. Timepix calibrations</a></li>
<li>  <a href="./calibration.html#sec:appendix:septemboard_calibrations">19.2. Septemboard calibration</a></li>
<li>  <a href="./calibration.html#sec:appendix:scintillator_calibration_notes">19.3. Calibration measurements of the veto scintillator paddle   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./cast_operations.html#sec:appendix:cast_operations">20. CAST operation procedures   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./cast_operations.html#sec:appendix:cast_operations:terminology">20.1. CAST terminology</a></li>
<li>  <a href="./cast_operations.html#sec:cast:high_voltage">20.2. High voltage supply</a></li>
<li>  <a href="./cast_operations.html#sec:cast:vacuum_system">20.3. Vacuum system</a></li>
<li>  <a href="./cast_operations.html#sec:cast:watercooling_gas">20.4. Watercooling system &amp; gas supply</a></li>
<li>  <a href="./cast_operations.html#sec:cast:interlock_systems">20.5. Interlock systems</a></li>
<li>  <a href="./cast_operations.html#sec:appendix:cast_log_files">20.6. CAST log files</a></li>
</ul>
</li>
<li><a href="./cast_run_list.html#sec:appendix:cast_run_list">21. CAST data taking run list   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./cast_run_list.html#orgc11ae90">21.1. Full version   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./cast_data_taking_notes.html#sec:appendix:cast_data_taking_notes">22. CAST data taking notes <code>[0/1]</code>   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./cast_data_taking_notes.html#org2ea44b9">22.1. Run table</a></li>
<li>  <a href="./cast_data_taking_notes.html#org75873aa">22.2. Data runs</a></li>
<li>  <a href="./cast_data_taking_notes.html#orgb2ec9bf">22.3. Calibration runs</a></li>
<li>  <a href="./cast_data_taking_notes.html#org0c72862">22.4. Automatically generated run list</a></li>
<li>  <a href="./cast_data_taking_notes.html#orgc3bfa76">22.5. Automatically calculated total run times</a></li>
<li>  <a href="./cast_data_taking_notes.html#org5a16ca1">22.6. InGrid temperature from shift forms</a></li>
</ul>
</li>
<li><a href="./cabling_and_softwar_setup.html#sec:appendix:cabling_and_softwar_setup">23. Cabling &amp; software setup <code>[/]</code>   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./cabling_and_softwar_setup.html#org4372a46">23.1. Virtex V6 cabling</a></li>
<li>  <a href="./cabling_and_softwar_setup.html#orgf86aaea">23.2. Detector cabling</a></li>
<li>  <a href="./cabling_and_softwar_setup.html#orgf53b0c9">23.3. Vivado / ISE on void linux &amp; flashing Virtex V6</a></li>
<li>  <a href="./cabling_and_softwar_setup.html#org81478cb">23.4. Setting up the chips in TOS</a></li>
</ul>
</li>
<li><a href="./vacuum_contamination.html#sec:appendix:vacuum_contamination">24. Window rupture and vacuum contamination   <span class="tag"><span class="Appendix">Appendix</span> <span class="extended">extended</span></span></a>
<ul>
<li>  <a href="./vacuum_contamination.html#org02275e2">24.1. Calculation of vacuum volume</a></li>
<li>  <a href="./vacuum_contamination.html#org9a5504b">24.2. Calculation of potential influx of gas</a></li>
<li>  <a href="./vacuum_contamination.html#org8ccdd0b">24.3. Consider pumping of pumps</a></li>
<li>  <a href="./vacuum_contamination.html#orgd31456f">24.4. Calculation of possible contamination</a></li>
</ul>
</li>
<li><a href="./detector_time_behavior.html#sec:appendix:detector_time_behavior">25. Detector behavior over time   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./detector_time_behavior.html#sec:appendix:choice_gas_gain_binning">25.1. Choice of gas gain binning time interval</a></li>
<li>  <a href="./detector_time_behavior.html#sec:appendix:correlation_gas_gain_ambient_temp">25.2. Correlation of gas gain and ambient CAST temperature</a></li>
</ul>
</li>
<li><a href="./cast_detector_lab.html#sec:appendix:cast_detector_lab">26. CAST Detector Lab data   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./cast_detector_lab.html#org2624c8d">26.1. Generate all spectrum plots split by run   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./cast_detector_lab.html#sec:appendix:cdl_spectra_by_run">26.2. All spectra split by run</a></li>
<li>  <a href="./cast_detector_lab.html#sec:appendix:cdl:all_spectra_fits">26.3. All CDL spectra with line fits   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./cast_detector_lab.html#sec:appendix:cdl:all_spectra_fits_by_run">26.4. All CDL spectra with line fits by run</a></li>
</ul>
</li>
<li><a href="./fit_by_run_justification.html#sec:appendix:fit_by_run_justification">27. CAST Detector Lab variations and fitting by run   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./fit_by_run_justification.html#sec:appendix:fit_by_run:gas_gain_var_cluster_prop">27.1. Influence of gas gain variations on cluster properties</a></li>
</ul>
</li>
<li><a href="./morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra">28. Morphing of CDL reference spectra   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./morphing_cdl_spectra.html#org22e9c8f">28.1. Generate all morphing / tile related plots   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./morphing_cdl_spectra.html#orgaaa4791">28.2. Generate plot comparing likelihood behavior   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:tilemaps">28.3. Tilemap of each likelihood dataset</a></li>
<li>  <a href="./morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:interpolation_raster">28.4. Interpolation of each likelihood dataset</a></li>
<li>  <a href="./morphing_cdl_spectra.html#sec:appendix:morphing_cdl_spectra:binwise_linear">28.5. Binwise linear interpolations for each likelihood dataset</a></li>
<li>  <a href="./morphing_cdl_spectra.html#orgf6be01a">28.6. Notes on CDL morphing development   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./occupancy.html#sec:appendix:occupancy">29. Occupancy maps   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./occupancy.html#org191530b">29.1. Run-2</a></li>
<li>  <a href="./occupancy.html#org99ae2cf">29.2. Run-3</a></li>
<li>  <a href="./occupancy.html#org799bce2">29.3. Generate occupancy map plots   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./fadc.html#sec:appendix:fadc">30. FADC   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./fadc.html#sec:appendix:fadc:rise_fall">30.1. FADC rise and fall time</a></li>
<li>  <a href="./fadc.html#sec:appendix:background:fadc">30.2. FADC veto</a></li>
<li>  <a href="./fadc.html#org693f919">30.3. Generate plot of rise time vs skewness   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./fadc.html#sec:appendix:fadc_veto_empirical_cluster_length">30.4. Expected cluster size</a></li>
</ul>
</li>
<li><a href="./background_rates.html#sec:appendix:background_rates">31. Raw data and background rates   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./background_rates.html#sec:appendix:background_rates:full_chip">31.1. Background rates over full chip</a></li>
<li>  <a href="./background_rates.html#orgbe37dfd">31.2. Generate rate without any vetoes over full chip   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./background_rates.html#orgf9b0799">31.3. Generate background rates over full chip   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./background_rates.html#org38c0b26">31.4. Generate table of background rates for all setups   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./background_interpolation_chip_area.html#sec:appendix:background_interpolation_chip_area">32. Background interpolation chip cutout correction   <span class="tag">    <span class="Appendix">Appendix</span>  </span></a></li>
<li><a href="./limit_additional.html#sec:appendix:limit_additional">33. Additional limit information   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./limit_additional.html#sec:appendix:conversion_probability">33.1. Conversion probability as a function of mass   <span class="tag">    <span class="Appendix">Appendix</span>  </span></a></li>
<li>  <a href="./limit_additional.html#sec:appendix:exp_limit_percentiles">33.2. Expected limit table with percentiles</a></li>
<li>  <a href="./limit_additional.html#sec:appendix:limit_additional:axion_photon">33.3. Observed limit - axion photon \(g_{aγ}\)</a></li>
<li>  <a href="./limit_additional.html#sec:appendix:limit_additional:chameleon">33.4. Observed limit - chameleon \(β_γ\)</a></li>
</ul>
</li>
<li><a href="./software.html#sec:appendix:software">34. Software   <span class="tag"><span class="Software">Software</span> <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./software.html#org18652e4">34.1. Why did I start writing my own analysis framework?   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./software.html#org9261c73">34.2. Nim   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./software.html#sec:appendix:timepix_analysis">34.3. TimepixAnalysis</a></li>
<li>  <a href="./software.html#org2a1a7b6">34.4. Other libraries relevant for TimepixAnalysis</a></li>
</ul>
</li>
<li><a href="./full_data_reconstruction.html#sec:appendix:full_data_reconstruction">35. Full data reconstruction   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./full_data_reconstruction.html#org600a2b7">35.1. Raw data parsing and reconstruction</a></li>
<li>  <a href="./full_data_reconstruction.html#org068d1d3">35.2. Parse and reconstruct the CDL data</a></li>
<li>  <a href="./full_data_reconstruction.html#org4119bc9">35.3. Add tracking information to background files</a></li>
<li>  <a href="./full_data_reconstruction.html#orgda24f14">35.4. Using <code>runAnalysisChain</code></a></li>
<li>  <a href="./full_data_reconstruction.html#orgb9b0fde">35.5. Applying a classifier</a></li>
<li>  <a href="./full_data_reconstruction.html#org5c1c524">35.6. Computing limits</a></li>
</ul>
</li>
<li><a href="./average_depth_xrays_argon.html#sec:appendix:average_depth_xrays_argon">36. Average distance X-rays travel in argon at CAST conditions   <span class="tag">  <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./average_depth_xrays_argon.html#orgbb9fd00">36.1. Reference to original document   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./average_depth_xrays_argon.html#org0a39e33">36.2. Calculate conversion point numerically</a></li>
<li>  <a href="./average_depth_xrays_argon.html#orgbbe3e69">36.3. Compiling and running the code   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li><a href="./raytracing.html#sec:appendix:raytracing">37. Raytracing   <span class="tag"><span class="Software">Software</span> <span class="Appendix">Appendix</span></span></a>
<ul>
<li>  <a href="./raytracing.html#sec:appendix:raytracing:traxer">37.1. TrAXer - An interactive axion raytracer</a></li>
<li>  <a href="./raytracing.html#sec:appendix:raytracing:llnl_telescope">37.2. A few more details about the LLNL telescope</a></li>
<li>  <a href="./raytracing.html#sec:appendix:raytracing:panter">37.3. Comparison of TrAXer results with PANTER measurements</a></li>
<li>  <a href="./raytracing.html#sec:appendix:raytracing:axion_image">37.4. Computing an axion image with TrAXer</a></li>
<li>  <a href="./raytracing.html#orgdaf5883">37.5. Reproducing an X-ray finger run with TrAXer   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
<li>  <a href="./raytracing.html#orgd48c982">37.6. Figure error development notes   <span class="tag">    <span class="extended">extended</span>  </span></a></li>
</ul>
</li>
<li>  <a href="./acknowledgments.html#sec:appendix:acknowledgments">38. Acknowledgments   <span class="tag">    <span class="Ack">Ack</span>  </span></a></li>
</ul>
</div>
</nav>
<div class="outline-2" id="outline-container-sec:limit">
<h2 id="sec:limit"><span class="section-number-2">13.</span> Limit calculation   <span class="tag">  <span class="Limit">Limit</span></span></h2>
<div class="outline-text-2" id="text-sec:limit">
<p>
In this chapter we will introduce a generic limit calculation method,
which can be used to compute limits on different axion or ALP coupling
constants.
</p>

<p>
The first part of this chapter focuses on the more theoretical and
conceptual aspects of our limit calculation methods. The second half
discusses our inputs in detail and shows our expected and observed limits.
</p>

<p>
We will start with an introduction of the method itself, a Bayesian
extended likelihood approach,
sec. <a href="./limit.html#sec:limit:method_introduction">13.1</a>. Step by step we will introduce
the likelihood function we use (sec. <a href="./limit.html#sec:limit:method_likelihood">13.2</a>),
what the individual pieces are and how likelihood values are computed
(sec. <a href="./limit.html#sec:limit:method_computing_L">13.3</a>) and how a limit is computed from
such a likelihood function,
sec. <a href="./limit.html#sec:limit:method_computing_a_limit">13.4</a>. Then we introduce our
approach to compute an expected limit by sampling toy
candidates <sup>  <a role="doc-backlink" class="footref" id="fnr.1" href="#fn.1">1</a></sup>, sec. <a href="./limit.html#sec:limit:method_expected_limit">13.5</a>. After
this we will extend our approach in sec. <a href="./limit.html#sec:limit:method_systematics">13.6</a>
to include systematic uncertainties. Due to added complexity in
evaluating the thus produced likelihood function, we discuss our
Markov Chain Monte Carlo (MCMC) approach to evaluate the likelihood
function in sec. <a href="./limit.html#sec:limit:method_mcmc">13.7</a>. This concludes the first half
of the chapter. Please look into Lista&apos;s book (<a href="./bibliography.html#citeproc_bib_item_145">Lista 2023</a>)
if you would like more details about Bayesian limit calculations
involving nuisance parameters. Barlow (<a href="./bibliography.html#citeproc_bib_item_36">Barlow 1993</a>) and
Cowan (<a href="./bibliography.html#citeproc_bib_item_68">Cowan 1998</a>) are also recommended for general
statistics concepts.
</p>

<p>
From here we introduce all ingredients entering the likelihood
function in detail, sec. <a href="./limit.html#sec:limit:ingredients">13.10</a>. Next we discuss our
systematics, sec. <a href="./limit.html#sec:limit:systematics">13.11</a>, after which we explain our
MCMC approach in more detail (number of chains, parameters bounds,
starting parameters etc.), sec. <a href="./limit.html#sec:limit:mcmc_calc_limit">13.12</a>.
</p>

<p>
At this point we can finally tie everything together and discuss the
expected limits obtained for a variety of different classifier and
veto choices, sec. <a href="./limit.html#sec:limit:expected_limits">13.13</a>. For the best performing
setup – the one yielding the best expected limit – we present our
axion candidates, <a href="./limit.html#sec:limit:candidates">13.14</a>. Based on these we 
present our observed limit in
sec. <a href="./limit.html#sec:limit:observed_limit">13.15</a>. Finally, in
sec. <a href="./limit.html#sec:limit:other_couplings">13.16</a> we briefly consider two other coupling
constants, the axion-photon coupling \(g_{aγ}\) and the chameleon
coupling \(β_γ\).
</p>
</div>

<div class="outline-3" id="outline-container-sec:limit:method_introduction">
<h3 id="sec:limit:method_introduction"><span class="section-number-3">13.1.</span> Limit method - introduction</h3>
<div class="outline-text-3" id="text-sec:limit:method_introduction">
<p>
We start with a few words on the terminology we use and what we have
in mind when we talk about &apos;limits&apos;. 
</p>

<dl class="org-dl">
<dt>Context and terminology</dt><dd><p>
An experiment tries to detect a new
phenomenon of the kind where you expect very little signal compared
to background sources. We have a dataset in which the experiment is
<i>sensitive</i> to the phenomenon, another dataset in which it is <i>not
sensitive</i> and finally a theoretical model of our <i>expected signal</i>.
</p>

<p>
Any data entry (after cleaning) in the sensitive dataset is a
<i>candidate</i>. Each candidate is drawn from a distribution of the
present background plus the expected signal contribution (\(c = s +
  b\)). Any entry in the non sensitive dataset is <i>background</i> only.
</p></dd>

<dt>Goal</dt><dd>Compute the value of a parameter (coupling constant) such
that there is \(\SI{95}{\%}\) confidence that the combined hypothesis
of signal and background sources are compatible with the background
only hypothesis.</dd>

<dt>Condition</dt><dd><p>
Our experiment should be such that the data in some
&quot;channels&quot; of our choice can be modeled by a Poisson distribution
</p>

<p>
\[
  P_{\text{Pois}}(k; λ) = \frac{λ^k e^{-λ}}{k!}.
  \]
</p>

<p>
Each such channel with an expectation value of \(λ\) counts has
probability \(P_{\text{Pois}}(k; λ)\) to measure \(k\) counts. Because
the Poisson distribution (as written here) is a probability density
function, multiple different channels can be combined to a
&quot;likelihood&quot; for an experiment outcome by taking the product of each
channel&apos;s Poisson probability
</p>

<p>
\[
  \mathcal{L}(λ) = \prod_i P_{i, \text{Pois}}(k; λ) = \prod_i \frac{λ_i^{k_i} e^{-λ_i}}{k_i!}.
  \]
</p>

<p>
Given a set of \(k_i\) recorded counts for all different channels \(i\)
with expectation value \(λ_i\) the &quot;likelihood&quot; gives us the literal
likelihood to record exactly that experimental outcome. Note that
the parameter of the likelihood function is the mean \(λ\) and not the
recorded data \(k\)! The likelihood function describes the likelihood
for a <b>fixed set of data</b> (our real measured counts) for different
parameters (our signal &amp; background models, where the background
model is constant as well).
</p>

<p>
In addition, the method described in the next section is valid under
the assumption that our experiment did not have a statistically
significant detection in the signal sensitive dataset compared to
the background dataset.
</p></dd>
</dl>
</div>
</div>

<div class="outline-3" id="outline-container-sec:limit:method_likelihood">
<h3 id="sec:limit:method_likelihood"><span class="section-number-3">13.2.</span> Limit method - likelihood function \(\mathcal{L}\)</h3>
<div class="outline-text-3" id="text-sec:limit:method_likelihood">
<p>
The likelihood function as described in the previous section is not
optimal to compute a limit for the usage with different datasets as
described before. <sup>  <a role="doc-backlink" class="footref" id="fnr.2" href="#fn.2">2</a></sup> For that case we want to have some kind of a &quot;test
statistic&quot; that relates the sensitive dataset with its seen candidates
to the background dataset. For practical purposes we prefer to define
a statistic, which is monotonically increasing in the number of
candidates (see for example (<a href="./bibliography.html#citeproc_bib_item_127">Junk 1999</a>)). There are different choices
possible, but the one we use is
</p>

<p>
\[
\mathcal{L}(s, b) = \prod_i \frac{P_{\text{pois}}(c_i; s_i + b_i)}{P_{\text{pois}}(c_i; b_i)},
\]
</p>

<p>
so the ratio of the signal plus background over the pure background
hypothesis. The number \(c_i\) is the real number of measured
<b>candidates</b>. So the numerator gives the probability to measure \(c_i\)
counts in each channel \(i\) given the signal plus background
hypothesis. On the other hand the denominator measures the probability
to measure \(c_i\) counts in each channel \(i\) assuming only the
background hypothesis.
</p>

<blockquote>
<p>
Note: For each channel \(i\) the ratio of probabilities itself is not strictly
speaking a probability density function, because the integral
</p>

<p>
\[
\int_{-∞}^{∞}Q\, \mathrm{d}x = N \neq 1,
\]
</p>

<p>
with \(Q\) an arbitrary distribution. \(N\) can be interpreted as a
hypothetical number of total number of counts measured in the
experiment. A PDF requires this integral to be 1.
</p>

<p>
As a result the full construct \(\mathcal{L}\) of the product of these ratios is
technically not a likelihood function either. It is usually referred
to as an &quot;extended likelihood function&quot;.
</p>

<p>
For all practical purposes though we will continue to treat is as a
likelihood function and call it \(\mathcal{L}\) as usual.
</p>
</blockquote>

<p>
Note the important fact that \(\mathcal{L}\) really is only a function of our
signal hypothesis \(s\) and our background model \(b\). Each experimental
outcome <b>has its own</b> \(\mathcal{L}\). This is precisely why the likelihood
function describes everything about an experimental outcome (at least
if the signal and background models are reasonably understood) and
thus different experiments can be combined by combining them in
&quot;likelihood space&quot; (multiplying their \(\mathcal{L}\) or adding \(\ln \mathcal{L}\) values)
to get a combined likelihood to compute a limit for.
</p>

<dl class="org-dl">
<dt>Deriving a practical version of \(\mathcal{L}\)</dt><dd><p>
The version of \(\mathcal{L}\) presented above is still quite impractical to use
and the ratio of exponentials of the Poisson distributions can be
simplified significantly:
</p>
\begin{align*}
  \mathcal{L} &amp;= \prod_i \frac{P(c_i, s_i + b_i)}{P(c_i, b_i)} =
      \prod_i \frac{ \frac{(s_i + b_i)^{n_i}}{n_i!} e^{-(s_i + b_i)} }{ \frac{b_i^{n_i}}{n_i!} e^{-b_i}} \\
    &amp;= \prod_i \frac{e^{-s_i} (s_i + b_i)^{c_i}}{b_i^{c_i}} =
      e^{-s_\text{tot}} \prod_i \frac{(s_i + b_i)^{c_i}}{b_i^{c_i}} \\
    &amp;= e^{-s_\text{tot}} \prod_i \left(1 + \frac{s_i}{b_i} \right)^{c_i}         
\end{align*}
<p>
This really is the heart of computing a limit with a number of
\(s_{\text{tot}}\) expected events from the signal hypothesis
(depending on the parameter to be studied, the coupling constant),
\(c_i\) measured counts in each channel and \(s_i\) expected signal
events and \(b_i\) expected background events in that channel.
</p>

<p>
As mentioned previously though, the choice of what a channel is, is
completely up to us! One such choice might be binning the candidates
in energy. However, there is one choice that is particularly simple
and is often referred to as the &quot;unbinned likelihood&quot;. Namely, we
create channels in <span class="underline">time</span> such that each &quot;time bin&quot; is so short as
to either have 0 entries (most channels) or 1 entry. This means we
have a large number of channels, but because of our definition of
\(\mathcal{L}\) this does not matter. All channels with 0 candidates do not
contribute to \(\mathcal{L}\) (they are \(\left(1 + \frac{s_i}{b_i}\right)^0 = 1\)). As a
result our expression of \(\mathcal{L}\) simplifies further to:
</p>

<p>
\[
  \mathcal{L} = e^{-s_\text{tot}} \prod_i \left(1 + \frac{s_i}{b_i}\right)
  \]
</p>

<p>
where \(i\) is now all channels where a candidate is contained (\(c_i =
  1\)).
</p></dd>
</dl>
</div>

<div class="outline-4" id="outline-container-orgc4a8f99">
<h4 id="orgc4a8f99"><span class="section-number-4">13.2.1.</span> Notes on more explanations   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-2-1">
<p>
For more explanations on this, I really recommend to read Thomas Junk 1999
paper about <code>mclimit</code>, (<a href="./bibliography.html#citeproc_bib_item_127">Junk 1999</a>). While it only covers
binned limit approaches, it is anyhow very clear in its explanations.
</p>

<p>
In general I recommend the following resources on statistics and limit
calculations. Roughly in the order in which I would recommend them.
</p>
<ul class="org-ul">
<li>Luca Lista&apos;s book on statistics, (<a href="./bibliography.html#citeproc_bib_item_145">Lista 2023</a>)
-&gt; If you log in to a CERN account, you can just download it
directly from Springer (I think that&apos;s the reason it works for me)</li>
<li>Luca List also uploaded a &apos;shortened version&apos; if you will to arxiv
(<a href="./bibliography.html#citeproc_bib_item_144">Lista 2016</a>).</li>
<li>Barlow&apos;s book on statistics is still a good book, but from 1989,
(<a href="./bibliography.html#citeproc_bib_item_36">Barlow 1993</a>)</li>
<li>Barlow also wrote a paper for the arxiv recently
(<a href="./bibliography.html#citeproc_bib_item_37">Barlow 2019</a>)</li>
<li>Cowan&apos;s book on statistics, (<a href="./bibliography.html#citeproc_bib_item_68">Cowan 1998</a>)</li>
</ul>

<p>
Cowan&apos;s and Barlow&apos;s books are good to check both. They mostly cover
the same topics, but reading in each can be helpful. Luca Lista is my
personal preference though, because it seems clearer to me. Also it&apos;s
more up to date with modern methods.
</p>

<p>
For the topic here in particular, maybe also see my own notes from a
few years back trying to better understand the maths behind CL<sub>S</sub> and
CL<sub>s</sub>+b:
<a href="./../org/Doc/StatusAndProgress.html">./../org/Doc/StatusAndProgress.html</a>
</p>
</div>
</div>
</div>



<div class="outline-3" id="outline-container-sec:limit:method_computing_L">
<h3 id="sec:limit:method_computing_L"><span class="section-number-3">13.3.</span> Limit method - computing \(\mathcal{L}\)</h3>
<div class="outline-text-3" id="text-sec:limit:method_computing_L">
<p>
Our simplified version of \(\mathcal{L}\) using very short time bins now allows
to explicitly compute the likelihood for a set of parameters. Let&apos;s
now look at each of the constituents \(s_{\text{tot}}\), \(s_i\) and
\(b_i\) and discuss how they are computed. We will focus on the
explicit case of an X-ray detector behind a telescope at CAST.
</p>

<p>
Here it is important to note that the signal hypothesis depends on
the coupling constant we wish to compute a limit for, we will just
call it \(g\) in the remainder (it may be \(g_{aγ}\) or \(g_{ae}\) or any
other coupling constant). This is the actual parameter of \(\mathcal{L}\).
</p>

<p>
First of all the signal contribution in each channel \(s_i\). It is
effectively a number of counts that one would expect within the time
window of the channel \(i\). While this seems tricky given that we
have not explicitly defined such a window we can:
</p>
<ul class="org-ul">
<li>either assume our time interval to be infinitesimally small and
give a <span class="underline">signal rate</span> (i.e. per second)</li>
<li>or make use of the neat property that our expression only contains
<b>the ratio</b> of \(s_i\) and \(b_i\). What this means is that we can
choose our units ourselves, <span class="underline">as long as we use the same units for
\(s_i\) as for \(b_i\)</span>!</li>
</ul>
<p>
We will use the second case and scale each candidate&apos;s signal and
background contribution to the total tracking time (signal sensitive
dataset length).
Each parameter with a subscript \(i\) is the corresponding value that
the candidate has we are currently looking at (e.g. \(E_i\) is the energy
of the recorded candidate \(i\) used to compute the expected signal).
</p>
\begin{equation}
\label{eq:limit_method_signal_si}
s_i(g²) = f(g², E_i) · A · t · P_{a \rightarrow γ}(g²_{aγ}) · ε(E_i) · r(x_i, y_i)
\end{equation}
<p>
where:
</p>
<ul class="org-ul">
<li>\(f(g, E_i)\) is the axion flux at energy \(E_i\) in units of
\(\si{keV^{-1}.cm^{-2}.s^{-1}}\) as a function of \(g²\), sec. <a href="./limit.html#sec:limit:ingredients:solar_axion_flux">13.10.2</a>,</li>
<li>\(A\) is the area of the magnet bore in \(\si{cm²}\), sec. <a href="./limit.html#sec:limit:ingredients:magnet_tracking">13.10.1</a>,</li>
<li>\(t\) is the tracking time in \(\si{s}\), also sec. <a href="./limit.html#sec:limit:ingredients:magnet_tracking">13.10.1</a>,</li>
<li>\(P_{a \rightarrow γ}\) is the conversion probability of the axion
converting into a photon computed via
\[
  P_{a \rightarrow γ}(g²_{aγ}) = \left( \frac{g_{aγ} B L}{2} \right)²
  \]
written in <i>natural units</i> (meaning we need to convert \(B\) and \(L\)
into values expressed in powers of \(\si{eV}\), as discussed in sec. <a href="./theory.html#sec:theory:axion_interactions">4.4</a>),
sec. <a href="./limit.html#sec:limit:ingredients:conversion_probability">13.10.3</a>,</li>
<li>\(ε(E_i)\) is the combined detection efficiency, i.e. the
combination of X-ray telescope effective area, the transparency of
the detector window and the absorption probability of an X-ray in
the gas, sec. <a href="./limit.html#sec:limit:ingredients:detection_eff">13.10.4</a>,</li>
<li>\(r(x_i, y_i)\) is the expected amount of flux from solar axions after
it is focused by the X-ray telescope in the readout plane of the
detector at the candidate&apos;s position \((x_i, y_i)\) (this requires a
raytracing model). It should be expressed as a fractional value in
units of \(\si{cm^{-2}}\). See sec. <a href="./limit.html#sec:limit:ingredients:raytracing">13.10.6</a>.</li>
</ul>
<p>
As a result the units of \(s_i\) are then given in
\(\si{keV^{-1}.cm^{-2}}\) with the tracking time integrated out.  If one
computes a limit for \(g_{aγ}\) then \(f\) and \(P\) both depend on the
coupling of interest, making \(s_i\) a function of \(g⁴_{aγ}\). In case of
e.g. an axion-electron coupling limit \(g_{ae}\), the conversion
probability can be treated as constant (with a fixed \(g_{aγ}\)).
</p>

<p>
Secondly, the background hypothesis \(b_i\) for each channel. Its value
depends on whether we assume a constant background model, an energy
dependent one or even an energy plus position dependent model. In
either case the main point is to evaluate that background model at the
position \((x_i, y_i)\) of the candidate and energy \(E_i\) of the
candidate. The value should then be scaled to the same units of as
\(s_i\), namely \(\si{keV^{-1}.cm^{-2}}\). Depending on how the model is
defined this might just be a multiplication by the total tracking time
in seconds. We discuss this in detail in
sec. <a href="./limit.html#sec:limit:ingredients:background">13.10.8</a>.
</p>

<p>
The final piece is the total signal \(s_{\text{tot}}\), corresponding
to the total number of counts expected from our signal hypothesis
for the given dataset. This is nothing else as the integration of
\(s_i\) over the entire energy range and detection area. However,
because \(s_i\) implies the signal for candidate \(i\), we write \(s(E,
x, y)\)  to mean the equivalent signal as if we had a candidate at
\((E, x, y)\)
</p>

<p>
\[
s_{\text{tot}} = ∫_0^{E_{\text{max}}} ∫_A s(E, x, y)\, \mathrm{d}E\, \mathrm{d}x\, \mathrm{d}y
\]
</p>

<p>
where \(A\) simply implies integrating the full area in which \((x, y)\)
is defined. The axion flux is bounded within a region much smaller
than the active detection area and hence all contributions outside
are 0.
</p>
</div>
</div>

<div class="outline-3" id="outline-container-sec:limit:method_computing_a_limit">
<h3 id="sec:limit:method_computing_a_limit"><span class="section-number-3">13.4.</span> Limit method - computing a limit</h3>
<div class="outline-text-3" id="text-sec:limit:method_computing_a_limit">
<p>
With the above we are now able to evaluate \(\mathcal{L}\) for a set of
candidates \({c_i(E_i, x_i, y_i)}\). As mentioned before it is
important to realize that \(\mathcal{L}\) is a function of the coupling constant
\(g\), \(\mathcal{L}(g)\) with all other parameters effectively constant in the
context of &quot;one experiment&quot;. \(g\) is a placeholder for the parameter,
in which \(\mathcal{L}\) is linear, i.e. \(g²_{ae}\) for axion-electron or
\(g⁴_{aγ}\) and \(β⁴_γ\) for axion-photon and chameleon, respectively.
</p>

<p>
With this in mind the &apos;limit&apos; is defined as the 95-th percentile of
\(\mathcal{L}(g)\) <i>within the physical region of \(g\)</i>. The region \(g &lt; 0\) is
explicitly ignored, as a coupling constant cannot be negative! This
can be rigorously justified in Bayesian statistics by saying the
prior \(π(g)\) is 0 for \(g &lt; 0\). 
</p>

<p>
We can define the limit implicitly as <sup>  <a role="doc-backlink" class="footref" id="fnr.3" href="#fn.3">3</a></sup>
</p>
\begin{equation}
\label{eq:limit_method:limit_def}
0.95 = \frac{∫_0^{g&apos;} \mathcal{L}(g)\, \mathrm{d}g}{∫_0^∞ \mathcal{L}(g)\, \mathrm{d}g}
\end{equation}

<p>
In practice the integral cannot be evaluated until
infinity. Fortunately, our choice of \(\mathcal{L}\) in the first place
means that the function converges to \(0\) quickly for large values of
\(g\). Therefore, we only need to compute values to a &quot;large enough&quot;
value of \(g\) to get the shape of \(\mathcal{L}(g)\). From there we can
use any numerical approach (via an empirical cumulative distribution
function for example) to determine the coupling constant \(g&apos;\) that
corresponds to the 95-th percentile of \(\mathcal{L}(g)\).
</p>

<p>
In an intuitive sense the limit means the following:
\(\SI{95}{\percent}\) of all coupling constants that reproduce the
data we measured – given our signal and background hypotheses – are
smaller than \(g&apos;\).
</p>

<p>
Fig. <a href="#fig:limit_method:example_limit_95th_perc">1</a> shows an example of a
likelihood function of some coupling constant. The blue area is the
lower \(\SI{95}{\%}\) of the parameter space and the red area is the
upper \(\SI{5}{\%}\). Therefore, the limit in this particular set of toy
candidates is at the intersection of the two colors.
</p>


<figure id="fig:limit_method:example_limit_95th_perc">
<img src="./figs/home/basti/phd/Figs/limit/simple_likelihood_limit_example.svg" class="org-svg" alt="simple_likelihood_limit_example.svg" />

<figcaption>Figure 1: <span class="figure-number">Figure 81: </span>Example likelihood function for a set of toy candidates. Blue is the lower 95-th percentile of the integral over the likelihood function and red the upper 5-th. The limit is at the intersection.</figcaption>
</figure>
</div>

<div class="outline-4" id="outline-container-orge183897">
<h4 id="orge183897"><span class="section-number-4">13.4.1.</span> Implementing a basic limit calculation method <code>[/]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-4-1">
<p>
The following are two examples for a basic limit calculation in
code. This is to showcase the basic idea without getting lost in too
many details. In terms of the main thesis, we use the first example to
produce a plot to illustrate how the limit is computed via the 95% percentile.
</p>

<p>
The real code we use for the limit is found here:
<a href="https://github.com/Vindaar/TimepixAnalysis/blob/master/Analysis/ingrid/mcmc_limit_calculation.nim">https://github.com/Vindaar/TimepixAnalysis/blob/master/Analysis/ingrid/mcmc_limit_calculation.nim</a>
</p>

<p>
Simplest implementation:
</p>
<ul class="org-ul">
<li>single channel</li>
<li>no detection efficiencies etc., just a flux that scales with \(g²\)</li>
<li>constant background (due to single channel)</li>
<li>no telescope, i.e. area for signal flux is the same as for
background (due to no focusing)</li>
</ul>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
<span style="color: #E6DB74;">## Assumptions:</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">totalTime </span>= <span style="font-style: italic;">100</span>.<span style="font-style: italic;">0</span>.h <span style="color: #75715E;"># </span><span style="color: #75715E;">100 of &quot;tracking time&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">totalArea </span>= <span style="font-style: italic;">10</span>.cm² <span style="color: #75715E;"># </span><span style="color: #75715E;">assume 10 cm² area (magnet bore and chip! This case has no telescope)</span>
defUnit<span style="color: #AE81FF;">(</span>cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">flux</span><span style="color: #AE81FF;">(</span>g²: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: cm⁻²•s⁻¹ =
  <span style="color: #E6DB74;">## Dummy flux. Just the coupling constant squared · 1e-6</span>
  <span style="color: #FD971F;">result</span> = 1e-<span style="font-style: italic;">6</span> * <span style="color: #AE81FF;">(</span>g²<span style="color: #AE81FF;">)</span>.cm⁻²•s⁻¹

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">totalFlux</span><span style="color: #AE81FF;">(</span>g²: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #E6DB74;">## Flux integrated to total time and area</span>
  <span style="color: #FD971F;">result</span> = flux<span style="color: #AE81FF;">(</span>g²<span style="color: #AE81FF;">)</span> * totalTime.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Second</span><span style="color: #AE81FF;">)</span> * totalArea

<span style="color: #E6DB74;">## Assume signal and background in counts of the single channel!</span>
<span style="color: #E6DB74;">## (Yes, `</span><span style="color: #AE81FF;">signal</span><span style="color: #E6DB74;">` is the same as `</span><span style="color: #AE81FF;">totalFlux</span><span style="color: #E6DB74;">` in this case)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">signal</span><span style="color: #AE81FF;">(</span>g²: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> = flux<span style="color: #AE81FF;">(</span>g²<span style="color: #AE81FF;">)</span> * totalTime * totalArea <span style="color: #E6DB74;">## Signal only depends on coupling in this simple model</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">background</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">float</span> = 1e-<span style="font-style: italic;">6</span>.cm⁻²•s⁻¹ * totalTime * totalArea <span style="color: #E6DB74;">## Single channel, i.e. constant background</span>
  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">likelihood</span><span style="color: #AE81FF;">(</span>g²: <span style="color: #66D9EF;">float</span>, cs: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> = <span style="color: #E6DB74;">## `</span><span style="color: #AE81FF;">cs</span><span style="color: #E6DB74;">` = number of candidates in the single channel</span>
  <span style="color: #FD971F;">result</span> = exp<span style="color: #AE81FF;">(</span>-totalFlux<span style="color: #66D9EF;">(</span>g²<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">e^{-s_tot}</span><span style="color: #75715E;">`</span>
  <span style="color: #FD971F;">result</span> *= pow<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span> + signal<span style="color: #66D9EF;">(</span>g²<span style="color: #66D9EF;">)</span> / background<span style="color: #66D9EF;">()</span>, cs.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">poisson</span><span style="color: #AE81FF;">(</span>k: <span style="color: #66D9EF;">int</span>, λ: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> = λ^k * exp<span style="color: #AE81FF;">(</span>-λ<span style="color: #AE81FF;">)</span> / <span style="color: #AE81FF;">(</span>fac<span style="color: #66D9EF;">(</span>k<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Background counts = &quot;</span>, background<span style="color: #AE81FF;">()</span>, <span style="color: #E6DB74;">&quot;. Probabilty to measure 4 counts given background: &quot;</span>, poisson<span style="color: #AE81FF;">(</span><span style="font-style: italic;">4</span>, background<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;equal to signal counts at g = 1: &quot;</span>, signal<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Likelihood at g = 1 for 4 candidates = &quot;</span>, likelihood<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">4</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## Let&apos;s plot it from 0 to 3 assuming 4 candidates</span>
<span style="color: #F92672;">import</span> ggplotnim
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">xs </span>= linspace<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">100</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ys </span>= xs.map_inline<span style="color: #AE81FF;">(</span>likelihood<span style="color: #66D9EF;">(</span>x, <span style="font-style: italic;">4</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## Compute limit, CDF@95%</span>
<span style="color: #F92672;">import</span> algorithm
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yCumSum </span>= ys.cumSum<span style="color: #AE81FF;">()</span>                    <span style="color: #75715E;"># </span><span style="color: #75715E;">cumulative sum</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yMax </span>= yCumSum.<span style="color: #F92672;">max</span>                       <span style="color: #75715E;"># </span><span style="color: #75715E;">maximum of the cumulative sum</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yCdf </span>= yCumSum.map_inline<span style="color: #AE81FF;">(</span>x / yMax<span style="color: #AE81FF;">)</span>      <span style="color: #75715E;"># </span><span style="color: #75715E;">normalize to get (empirical) CDF</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">limitIdx </span>= yCdf.toSeq1D.lowerBound<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">95</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">limit at 95% of the CDF</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Limit at : &quot;</span>, xs<span style="color: #AE81FF;">[</span>limitIdx<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">L_atLimit</span> = ys<span style="color: #AE81FF;">[</span>limitIdx<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span>xs, ys<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfLimit </span>= df.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: `xs` &gt;= xs<span style="color: #A6E22E;">[</span>limitIdx<span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> dfLimit
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;xs&quot;</span>, <span style="color: #E6DB74;">&quot;ys&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Coupling constant&quot;</span><span style="color: #AE81FF;">)</span> + ylab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Likelihood&quot;</span><span style="color: #AE81FF;">)</span> + 
  geom_line<span style="color: #AE81FF;">(</span>fillColor = <span style="color: #E6DB74;">&quot;blue&quot;</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">4</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">(</span>data = dfLimit, fillColor = <span style="color: #E6DB74;">&quot;red&quot;</span><span style="color: #AE81FF;">)</span> + 
  <span style="color: #75715E;">#</span><span style="color: #75715E;">geom_linerange(aes = aes(x = xs[limitIdx], yMin = 0.0, yMax = L_atLimit), ) + </span>
  annotate<span style="color: #AE81FF;">(</span>x = xs<span style="color: #66D9EF;">[</span>limitIdx<span style="color: #66D9EF;">]</span>, y = <span style="color: #66D9EF;">L_atLimit</span> + <span style="font-style: italic;">0</span>.<span style="font-style: italic;">1</span>, text = <span style="color: #E6DB74;">&quot;Limit at 95% area&quot;</span><span style="color: #AE81FF;">)</span> +
  ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Example likelihood and limit&quot;</span><span style="color: #AE81FF;">)</span> +
  themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9</span>, width = <span style="font-style: italic;">600</span>, baseTheme = singlePlot, useTeX = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span> + 
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/phd/Figs/limit/simple_likelihood_limit_example.pdf&quot;</span>, width = <span style="font-style: italic;">600</span>, height = <span style="font-style: italic;">380</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
Background counts = 3.6. Probabilty to measure 4 counts given background: 0.1912223391751322
equal to signal counts at g = 1: 3.6
Likelihood at g = 1 for 4 candidates = 0.4371795591566811
Limit at : 1.666666666666665
DataFrame with 2 columns and 45 rows:
     Idx           xs           ys
  dtype:        float        float
       0        1.667       0.1253
       1        1.697       0.1176
       2        1.727       0.1103
       3        1.758       0.1033
       4        1.788      0.09679
       5        1.818      0.09062
       6        1.848      0.08481
       7        1.879      0.07933
       8        1.909      0.07417
       9        1.939      0.06932
      10         1.97      0.06476
      11            2      0.06047
      12         2.03      0.05645
      13        2.061      0.05267
      14        2.091      0.04912
      15        2.121       0.0458
      16        2.152      0.04268
      17        2.182      0.03977
      18        2.212      0.03703
      19        2.242      0.03448
</p>

<p>
[INFO]: No plot ratio given, using golden ratio.
[INFO] TeXDaemon ready for input.
shellCmd: command -v lualatex
shellCmd: lualatex -output-directory /home/basti/phd/Figs/limit /home/basti/phd/Figs/limit/simple<sub>likelihood</sub><sub>limit</sub><sub>example.tex</sub>
Generated: /home/basti/phd/Figs/limit/simple<sub>likelihood</sub><sub>limit</sub><sub>example.pdf</sub>
</p>

<p>
More realistic implementation, above plus:
</p>
<ul class="org-ul">
<li>real solar axion flux</li>
<li>TODO: (detection efficiency) (could just use fixed efficiency)</li>
<li>X-ray telescope without usage of local flux information</li>
<li>multiple channels in energy</li>
</ul>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math, seqmath, sequtils, algorithm
<span style="color: #E6DB74;">## Assumptions:</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">totalTime </span>= <span style="font-style: italic;">100</span>.<span style="font-style: italic;">0</span>.h <span style="color: #75715E;"># </span><span style="color: #75715E;">100 of &quot;tracking time&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">areaBore </span>= π * <span style="color: #AE81FF;">(</span><span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span> * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span><span style="color: #AE81FF;">)</span>.cm²
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">chipArea </span>= <span style="font-style: italic;">5</span>.mm * <span style="font-style: italic;">5</span>.mm <span style="color: #75715E;"># </span><span style="color: #75715E;">assume all flux is focused into an area of 5x5 mm²</span>
                             <span style="color: #75715E;"># </span><span style="color: #75715E;">on the detector. Relevant area for background!</span>
defUnit<span style="color: #AE81FF;">(</span>GeV⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## Constants defining the channels and background info</span>
<span style="color: #F92672;">const</span>
  <span style="color: #66D9EF;">Energies</span> =   @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">2</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">3</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">4</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">5</span>.<span style="font-style: italic;">5</span>,     <span style="font-style: italic;">6</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">7</span>.<span style="font-style: italic;">5</span>,  <span style="font-style: italic;">8</span>.<span style="font-style: italic;">5</span>,    <span style="font-style: italic;">9</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">]</span>.mapIt<span style="color: #AE81FF;">(</span>it.keV<span style="color: #AE81FF;">)</span>
  <span style="color: #66D9EF;">Background</span> = @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.5e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">2</span>.5e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">4</span>.5e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">4</span>.0e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">1</span>.0e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">0</span>.75e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">0</span>.8e-<span style="font-style: italic;">5</span>, 3e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">3</span>.5e-<span style="font-style: italic;">5</span>, <span style="font-style: italic;">2</span>.0e-<span style="font-style: italic;">5</span><span style="color: #AE81FF;">]</span>
    .mapIt<span style="color: #AE81FF;">(</span>it.keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">convert to a rate</span>
  <span style="color: #E6DB74;">## A possible set of candidates from `</span><span style="color: #AE81FF;">Background · chipArea · totalTime · 1 keV</span><span style="color: #E6DB74;">`</span>
  <span style="color: #E6DB74;">## (1e-5 · 5x5mm² · 100h = 0.9 counts)</span>
  <span style="color: #66D9EF;">Candidates</span> = @<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>,      <span style="font-style: italic;">2</span>,      <span style="font-style: italic;">7</span>,     <span style="font-style: italic;">3</span>,      <span style="font-style: italic;">1</span>,      <span style="font-style: italic;">0</span>,       <span style="font-style: italic;">1</span>,      <span style="font-style: italic;">4</span>,    <span style="font-style: italic;">3</span>,      <span style="font-style: italic;">2</span><span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">solarAxionFlux</span><span style="color: #AE81FF;">(</span>ω: keV, g_aγ: GeV⁻¹<span style="color: #AE81FF;">)</span>: keV⁻¹•cm⁻²•s⁻¹ =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">axion flux produced by the Primakoff effect in solar core</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">in units of keV⁻¹•m⁻²•yr⁻¹</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">flux </span>= <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> * 1e18.keV⁻¹•m⁻²•yr⁻¹ * <span style="color: #AE81FF;">(</span>g_aγ / 1e-<span style="font-style: italic;">12</span>.GeV⁻¹<span style="color: #AE81FF;">)</span>^<span style="font-style: italic;">2</span> * pow<span style="color: #AE81FF;">(</span>ω / <span style="font-style: italic;">1</span>.keV, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">450</span><span style="color: #AE81FF;">)</span> * exp<span style="color: #AE81FF;">(</span>-<span style="font-style: italic;">0</span>.<span style="font-style: italic;">829</span> * ω / <span style="font-style: italic;">1</span>.keV<span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">convert flux to correct units</span>
  <span style="color: #FD971F;">result</span> = flux.to<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">func</span> <span style="color: #A6E22E;">conversionProbability</span><span style="color: #AE81FF;">(</span>g_aγ: GeV⁻¹<span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #E6DB74;">## the conversion probability in the CAST magnet (depends on g_aγ)</span>
  <span style="color: #E6DB74;">## simplified vacuum conversion prob. for small masses</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">B</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">0</span>.<span style="color: #66D9EF;">T</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">L</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m
  <span style="color: #FD971F;">result</span> = pow<span style="color: #AE81FF;">(</span> <span style="color: #66D9EF;">(</span>g_aγ * <span style="color: #66D9EF;">B</span>.toNaturalUnit * <span style="color: #66D9EF;">L</span>.toNaturalUnit / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">from</span> numericalnim <span style="color: #F92672;">import</span> simpson <span style="color: #75715E;"># </span><span style="color: #75715E;">simpson numerical integration routine  </span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">totalFlux</span><span style="color: #AE81FF;">(</span>g_aγ: GeV⁻¹<span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #E6DB74;">## Flux integrated to total time, energy and area</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">1. integrate the solar flux</span>
  <span style="color: #E6DB74;">## NOTE: in practice this integration must not be done in this proc! Only perform once!</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xs </span>= linspace<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">10</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">100</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fl </span>= xs.mapIt<span style="color: #AE81FF;">(</span>solarAxionFlux<span style="color: #66D9EF;">(</span>it.keV, g_aγ<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">integral </span>= simpson<span style="color: #AE81FF;">(</span>fl.mapIt<span style="color: #66D9EF;">(</span>it.<span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">convert units to float for compatibility</span>
                         xs<span style="color: #AE81FF;">)</span>.cm⁻²•s⁻¹ <span style="color: #75715E;"># </span><span style="color: #75715E;">convert back to units (integrated out `</span><span style="color: #AE81FF;">keV⁻¹</span><span style="color: #75715E;">`!)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">2. compute final flux by &quot;integrating&quot; out the time and area</span>
  <span style="color: #FD971F;">result</span> = integral * totalTime * areaBore * conversionProbability<span style="color: #AE81FF;">(</span>g_aγ<span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## NOTE: only important that signal and background have the same units!  </span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">signal</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span>: keV, g_aγ: GeV⁻¹<span style="color: #AE81FF;">)</span>: keV⁻¹ =
  <span style="color: #E6DB74;">## Returns the axion flux based on `</span><span style="color: #AE81FF;">g</span><span style="color: #E6DB74;">` and energy `</span><span style="color: #AE81FF;">E</span><span style="color: #E6DB74;">`</span>
  <span style="color: #FD971F;">result</span> = solarAxionFlux<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span>, g_aγ<span style="color: #AE81FF;">)</span> * totalTime.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Second</span><span style="color: #AE81FF;">)</span> * areaBore * conversionProbability<span style="color: #AE81FF;">(</span>g_aγ<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">background</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span>: keV<span style="color: #AE81FF;">)</span>: keV⁻¹ =
  <span style="color: #E6DB74;">## Compute an interpolation of energies and background</span>
  <span style="color: #E6DB74;">## NOTE: For simplicity we only evaluate at the channel energies anyway. In practice</span>
  <span style="color: #E6DB74;">## one likely wants interpolation to handle all energies in the allowed range correctly!</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">idx </span>= <span style="color: #66D9EF;">Energies</span>.lowerBound<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">get idx of this energy</span>
  <span style="color: #E6DB74;">## Note: area of interest is the region on the chip, in which the signal is focused!</span>
  <span style="color: #E6DB74;">## This also allows us to see that the &quot;closer&quot; we cut to the expected axion signal on the</span>
  <span style="color: #E6DB74;">## detector, the less background we have compared to the *fixed* signal flux!</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Background</span><span style="color: #66D9EF;">[</span>idx<span style="color: #66D9EF;">]</span> * totalTime * chipArea<span style="color: #AE81FF;">)</span>.to<span style="color: #AE81FF;">(</span>keV⁻¹<span style="color: #AE81FF;">)</span>
  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">likelihood</span><span style="color: #AE81FF;">(</span>g_aγ: GeV⁻¹, energies: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span>keV<span style="color: #66D9EF;">]</span>, cs: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #E6DB74;">## `</span><span style="color: #AE81FF;">energies</span><span style="color: #E6DB74;">` = energies corresponding to each channel</span>
  <span style="color: #E6DB74;">## `</span><span style="color: #AE81FF;">cs</span><span style="color: #E6DB74;">` = each element is number of counts in that energy channel</span>
  <span style="color: #FD971F;">result</span> = exp<span style="color: #AE81FF;">(</span>-totalFlux<span style="color: #66D9EF;">(</span>g_aγ<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">e^{-s_tot}</span><span style="color: #75715E;">`</span>
  <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; cs.<span style="color: #F92672;">len</span>:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">c </span>= cs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>       <span style="color: #75715E;"># </span><span style="color: #75715E;">number of candidates in this channel</span>
    <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">E</span> = energies<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">energy of this channel</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">s </span>= signal<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span>, g_aγ<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">b </span>= background<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">E</span><span style="color: #AE81FF;">)</span>
    <span style="color: #FD971F;">result</span> *= pow<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span> + signal<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">E</span>, g_aγ<span style="color: #66D9EF;">)</span> / background<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">E</span><span style="color: #66D9EF;">)</span>, c.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## Let&apos;s plot it from 0 to 3 assuming 4 candidates</span>
<span style="color: #F92672;">import</span> ggplotnim
<span style="color: #75715E;"># </span><span style="color: #75715E;">define coupling constants</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">xs </span>= logspace<span style="color: #AE81FF;">(</span>-<span style="font-style: italic;">13</span>, -<span style="font-style: italic;">10</span>, <span style="font-style: italic;">300</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span>it.GeV⁻¹<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">logspace 1e-13 GeV⁻¹ to 1e-8 GeV⁻¹</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ys </span>= xs.mapIt<span style="color: #AE81FF;">(</span>likelihood<span style="color: #66D9EF;">(</span>it, <span style="color: #66D9EF;">Energies</span>, <span style="color: #66D9EF;">Candidates</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;xs&quot;</span> : xs.mapIt<span style="color: #A6E22E;">(</span>it.<span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>, ys<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;xs&quot;</span>, <span style="color: #E6DB74;">&quot;ys&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/energy_bins_likelihood.pdf&quot;</span><span style="color: #AE81FF;">)</span>

<span style="color: #E6DB74;">## Compute limit, CDF@95%</span>
<span style="color: #F92672;">import</span> algorithm
<span style="color: #75715E;"># </span><span style="color: #75715E;">limit needs non logspace x &amp; y data! (at least if computed in this simple way)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">xLin </span>= linspace<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, 1e-<span style="font-style: italic;">10</span>, <span style="font-style: italic;">1000</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span>it.GeV⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yLin </span>= xLin.mapIt<span style="color: #AE81FF;">(</span>likelihood<span style="color: #66D9EF;">(</span>it, <span style="color: #66D9EF;">Energies</span>, <span style="color: #66D9EF;">Candidates</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yCumSum </span>= yLin.cumSum<span style="color: #AE81FF;">()</span>          <span style="color: #75715E;"># </span><span style="color: #75715E;">cumulative sum</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yMax </span>= yCumSum.<span style="color: #F92672;">max</span>               <span style="color: #75715E;"># </span><span style="color: #75715E;">maximum of the cumulative sum</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">yCdf </span>= yCumSum.mapIt<span style="color: #AE81FF;">(</span>it / yMax<span style="color: #AE81FF;">)</span>  <span style="color: #75715E;"># </span><span style="color: #75715E;">normalize to get (empirical) CDF</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">limitIdx </span>= yCdf.lowerBound<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">95</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">limit at 95% of the CDF</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Limit at : &quot;</span>, xLin<span style="color: #AE81FF;">[</span>limitIdx<span style="color: #AE81FF;">]</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">Code outputs:</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">Limit at : 6.44645e-11 GeV⁻¹</span>
</pre>
</div>

<p>
Limit at : 6.44645e-11 GeV⁻¹
</p>
</div>
</div>
</div>

<div class="outline-3" id="outline-container-sec:limit:method_expected_limit">
<h3 id="sec:limit:method_expected_limit"><span class="section-number-3">13.5.</span> Limit method - toy candidate sets and expected limits</h3>
<div class="outline-text-3" id="text-sec:limit:method_expected_limit">
<p>
Assuming a constant background over some chip area with only an energy
dependence, the background hypothesis can be used to draw toy
candidates that can be used in place for the real candidates to
compute limits. In this situation the background hypothesis can be
modeled as follows:
</p>

<p>
\[
B = \{ P_{\text{Pois}}(k; λ = b_i) \: | \: \text{for all energy bins } E_i \},
\]
</p>

<p>
that is, the background is the set of all energy bins \(E_i\), where
each bin content is described by a Poisson distribution with a mean
and expectation value of \(λ = b_i\) counts.
</p>

<p>
To compute a set of toy candidates then, we simply iterate over all
energy bins and draw a number from each Poisson distribution. This
is the number of candidates in that bin for the toy. Given that we
assumed a constant background over the chip area, we finally need to
draw the \((x_i, y_i)\) positions for each toy candidate from a
uniform distribution. <sup>  <a role="doc-backlink" class="footref" id="fnr.4" href="#fn.4">4</a></sup>
</p>

<p>
These sets of toy candidates can be used to compute an &quot;expected
limit&quot;. The term expected limit is usually understood to mean the
median of many limits computed based on representative toy candidate
sets. If \(L_{t_i}\) is the limit of the toy candidate set \(t_i\), the
expected limit \(⟨L⟩\) is defined as
</p>

<p>
\[
⟨L⟩ = \mathrm{median}( \{ L_{t_i} \} )
\]
</p>

<p>
If the number of toy candidate sets is large enough, the expected
limit should prove accurate. The real limit will then be below or
above with \(\SI{50}{\%}\) chance each.
</p>
</div>
</div>

<div class="outline-3" id="outline-container-sec:limit:method_systematics">
<h3 id="sec:limit:method_systematics"><span class="section-number-3">13.6.</span> Limit method - extending \(\mathcal{L}\) for systematics</h3>
<div class="outline-text-3" id="text-sec:limit:method_systematics">
<p>
The aforementioned likelihood ratio assumes perfect knowledge of the
inputs for the signal and background hypotheses. In practice neither
of these is known perfectly though. Each input typically has
associated a small systematic uncertainty (e.g. the width of the
detector window is only known up to N nanometers, the pressure in
the chamber only up to M millibar, magnet length only up to C
centimeters etc.). These all affect the &quot;real&quot; numbers one should
actually calculate with. So how does one treat these uncertainties?
</p>

<p>
The basic starting point is realizing that the values we use are our
&quot;best guess&quot; of the real value. <span class="underline">Usually</span> it is a reasonable
approximation that the real value will likely be within some
standard deviation around that best guess, following a normal
distribution. Further, it is a good idea to identify all systematic
uncertainties and classify them by which aspect of \(s_i\), \(b_i\) or
\((x_i, y_i)\) they affect (amount of signal, background or the
position <sup>  <a role="doc-backlink" class="footref" id="fnr.5" href="#fn.5">5</a></sup> ). Another
reasonable assumption is to combine different uncertainties of the
same type by
</p>

<p>
\[
Δx = \sqrt{ \sum_{i=1}^N Δx²_i },
\]
</p>

<p>
i.e. computing the euclidean radius in N dimensions, for N
uncertainties of the same type.
</p>

<p>
The above explanation can be followed to encode these uncertainties
into the limit calculation. For a value corresponding to our &quot;best
guess&quot; we want to recover the likelihood function \(\mathcal{L}\) from
before. The further we get away from our &quot;best guess&quot;, the more the
likelihood function should be &quot;penalized&quot;, meaning the actual
likelihood of that parameter given our data should be <b>lower</b>. The
initial likelihood \(\mathcal{L}\) will be modified by multiplying with
additional normal distributions, one for each uncertainty (4 in total
in our case, signal, background, and two position uncertainties). Each
adds an additional parameter, a &apos;nuisance parameter&apos;.
</p>

<p>
To illustrate the details, let&apos;s look at the case of adding a single
nuisance parameter. In particular we&apos;ll look at the nuisance parameter
for the signal as it requires more care. The idea is to express our
uncertainty of a parameter – in this case the signal – by
introducing an additional parameter \(s_i&apos;\). In contrast to \(s_i\) it
describes a possible <span class="underline">other</span> value of \(s_i\) due to our systematic
uncertainty. For simplicity we rewrite our likelihood \(\mathcal{L}\) as
\(\mathcal{L}&apos;(s_i, s_i&apos;, b_i)\):
</p>

<p>
\[
\mathcal{L}&apos; = e^{-s&apos;_\text{tot}} \prod_i \left(1 + \frac{s_i&apos;}{b_i}\right) · \exp\left[-\frac{1}{2} \left(\frac{s_i&apos; - s_i}{σ_s&apos;}\right)² \right]
\]
</p>

<p>
where \(s_i&apos;\) takes the place of the \(s_i\). The added gaussian then
provides a penalty for any deviation from \(s_i\). The standard
deviation of the gaussian \(σ_s&apos;\) is the actual systematic
uncertainty on our parameter \(s_i\) in units of \(s_i\).
</p>

<p>
This form of adding a secondary parameter \(s_i&apos;\) of the same units
as \(s_i\) is not the most practical, but maybe provides the best
explanation as to how the name &apos;penalty term&apos; arises for the added
gaussian. If \(s_i = s_i&apos;\) then the exponential term is \(1\) meaning
the likelihood remains unchanged. For any other value the
exponential is \(&lt; 1\), <span class="underline">decreasing</span> the likelihood \(\mathcal{L}&apos;\).
</p>

<p>
By a change of variables we can replace the &quot;unitful&quot; parameter
\(s_i&apos;\) by a unitless number \(ϑ_s\). We would like the exponential to
be \(\exp(-ϑ_s²/(2 σ_s²))\) to only express deviation from our
best guess \(s_i\). \(ϑ_s = 0\) means no deviation and \(|ϑ_s| = 1\)
implies \(s_i = -s_i&apos;\). Note that the standard deviation of this is
now \(σ_s\) and <b>not</b> \(σ_s&apos;\) as seen in the expression above. This
\(σ_s\) corresponds to our systematic uncertainty on the signal as a
percentage.
</p>

<p>
To arrive at this expression:
</p>

\begin{align*}
\frac{s_i&apos; - s_i}{σ_s&apos;} &amp;= \frac{ϑ_s}{σ_s} \\
\Rightarrow s_i&apos; &amp;= \frac{σ_s&apos;}{σ_s} ϑ_s + s_i \\
\text{with } s_i &amp;= \frac{σ_s&apos;}{σ_s} \\
s_i&apos; &amp;= s_i + s_i ϑ_s \\
\Rightarrow s_i&apos; &amp;= s_i (1 + ϑ_s) \\
\end{align*}

<p>
where we made use of the fact that the two standard deviations are
related by the signal \(s_i\) (which can be seen by defining \(ϑ_s\) as
the normalized difference \(ϑ_s = \frac{s&apos;_i - s_i}{s_i}\)).
</p>

<p>
This results in the following final (single nuisance parameter)
likelihood \(\mathcal{L}&apos;\):
</p>

<p>
\[
\mathcal{L}&apos; = e^{-s&apos;_\text{tot}} \prod_i \left(1 + \frac{s_i&apos;}{b_i}\right) · \exp\left[-\frac{1}{2} \left(\frac{ϑ_s}{σ_s}\right)² \right]
\]
</p>

<p>
where \(s_i&apos; = s_i (1 + ϑ_s)\) and similarly \(s_{\text{tot}}&apos; =
s_{\text{tot}} ( 1 + ϑ_s )\) (the latter just follows because \(1 +
ϑ_s\) is a constant under the different channels \(i\)).
</p>

<p>
The same approach is used to encode the background systematic
uncertainty. The position uncertainty is generally handled the same,
but the \(x\) and \(y\) coordinates are treated separately.
</p>

<p>
As shown in eq. \eqref{eq:limit_method_signal_si} the signal \(s_i\) actually
depends on the positions \((x_i, y_i)\) of each candidate via the
raytracing image \(r\). With this we can introduce the nuisance
parameters by replacing \(r\) by an \(r&apos;\) such that \[ r&apos; ↦ r(x_i - x&apos;_i,
y_i - y&apos;_i) \] which effectively moves the center position by \((x&apos;_i,
y&apos;_i)\). In addition we need to add penalty terms for each of these
introduced parameters:
</p>

<p>
\[
\mathcal{L}&apos; = \exp[-s] \cdot \prod_i \left(1 + \frac{s&apos;_i}{b_i}\right) \cdot
  \exp\left[-\left(\frac{x_i - x&apos;_i}{\sqrt{2}σ} \right)² \right] \cdot \exp\left[-\left(\frac{y_i - y&apos;_i}{\sqrt{2}σ} \right)² \right]
\]
</p>

<p>
where \(s&apos;_i\) is now the modification from above using \(r&apos;\) instead
of \(r\). Now we perform the same substitution as we do for \(ϑ_b\) and
\(ϑ_s\)  to arrive at:
</p>

<p>
\[
\mathcal{L}&apos; = \exp[-s] \cdot \prod_i \left(1 + \frac{s&apos;_i}{b_i}\right) \cdot
  \exp\left[-\left(\frac{ϑ_x}{\sqrt{2}σ_x} \right)² \right] \cdot \exp\left[-\left(\frac{ϑ_y}{\sqrt{2}σ_y} \right)² \right]
\]
</p>

<p>
The substitution for \(r&apos;\) means the following for the parameters:
\[
r&apos; = r\left(x (1 + ϑ_x), y (1 + ϑ_y)\right)
\]
where essentially a deviation of \(|ϑ| = 1\) means we move the center of
the axion image to the edge of the chip.
</p>

<p>
Putting all these four nuisance parameters together we have
</p>

\begin{align}
\label{eq:limit_method:likelihood_function_def}
\mathcal{L}&apos; &amp;= \left(\prod_i \frac{P_{\text{pois}}(n_i; s_i + b_i)}{P_{\text{pois}}(n_i; b_i)}\right) \cdot \mathcal{N}(ϑ_s, σ_s)
\cdot \mathcal{N}(ϑ_b, σ_b) \cdot \mathcal{N}(ϑ_x, σ_x) \cdot \mathcal{N}(ϑ_y, σ_y) \\
\mathcal{L}&apos;(g, ϑ_s, ϑ_b, ϑ_x, ϑ_y) &amp;= e^{-s&apos;_\text{tot}} \prod_i \left(1 + \frac{s_i&apos;&apos;}{b_i&apos;} \right) ·
  \exp\left[-\frac{1}{2} \left(\frac{ϑ_s}{σ_s}\right)² 
    -\frac{1}{2} \left(\frac{ϑ_b}{σ_b}\right)² 
    -\frac{1}{2} \left(\frac{ϑ_x}{σ_x}\right)² 
    -\frac{1}{2} \left(\frac{ϑ_y}{σ_y}\right)² \right]
\end{align}

<p>
where here the doubly primed \(s_i&apos;&apos;\) refers to modification for the
signal nuisance parameter <span class="underline">as well as</span> for the position uncertainty
via \(r&apos;\).
</p>

<p>
An example of the impact of the nuisance parameters on the likelihood
space as well as on the parameters (\(s, b, x, y\)) is shown in
fig. <a href="#fig:limit:method_systematics:example">2</a>. First,
fig. <a href="#fig:limit:method_systematics:example_theta_0.6">2(a)</a> shows how the
axion image moves when \(ϑ_{x,y}\) change, in this example \(ϑ_{x,y} =
0.6\) moves the image center to the bottom left (\(ϑ_{x,y} = 1\) would
move the center into the corner). Note that the window strongback is
not tied to the axion image, but remains fixed (the cut out diagonal
lines). Fig. <a href="#fig:limit:method_systematics:example_sigma_0.05">2(b)</a> and
<a href="#fig:limit:method_systematics:example_sigma_0.25">2(c)</a> show the impact
of the nuisance parameters on the likelihood space. The larger the
standard deviation \(σ_{x,y}\) is, the more of the \(ϑ_{x,y}\) space
contributes meaningfully to \(\mathcal{L}_M\). In the former example –
a realistic uncertainty – only small regions around the center are
allowed to contribute. Regions further outside receive too large of a
penalty. However, at large uncertainties significant regions of the
parameter space play an important role. Given that each point on the
figures <a href="#fig:limit:method_systematics:example_sigma_0.05">2(b)</a> and
<a href="#fig:limit:method_systematics:example_sigma_0.25">2(c)</a> describes one
axion image like <a href="#fig:limit:method_systematics:example_theta_0.6">2(a)</a>,
brighter regions imply positions where the axion image is moved to
parts that provide a larger \(s/b\) in the center portion of the axion
image, while still only having a small enough penalty. For the
realistic uncertainty, \(σ = 0.05\), roughly the inner \(-0.1 &lt; ϑ &lt; 0.1\)
space contributes. This corresponds to a range of \(\SI{-0.7}{mm} &lt; x &lt;
\SI{0.7}{mm}\) around the center in
fig. <a href="#fig:limit:method_systematics:example_theta_0.6">2(a)</a>.
</p>

<figure class="figure-wrapper" id="fig:limit:method_systematics:example">
<figure class="subfigure" id="fig:limit:method_systematics:example_theta_0.6" data-width="32%">  <img src="./figs/~/phd/Figs/limit/sanity/fWidth0.3/axion_image_limit_calc_theta_0_6.svg" data-width="99%" />  <figcaption>Figure 2(a): Axion image at $ϑ_{x,y} = 0.6$</figcaption></figure> <figure class="subfigure" id="fig:limit:method_systematics:example_sigma_0.05" data-width="32%">  <img src="./figs/~/phd/Figs/limit/sanity/fWidth0.3/likelihood_sigma_0.05_manyϑx_ϑy.svg" data-width="99%" />  <figcaption>Figure 2(b): $σ_{x,y} = 0.05$</figcaption></figure> <figure class="subfigure" id="fig:limit:method_systematics:example_sigma_0.25" data-width="32%">  <img src="./figs/~/phd/Figs/limit/sanity/fWidth0.3/likelihood_sigma_0.25_manyϑx_ϑy.svg" data-width="99%" />  <figcaption>Figure 2(c): $σ_{x,y} = 0.25$</figcaption></figure>
<figcaption>Figure 2: <a href="#fig:limit:method_systematics:example_theta_0.6">2(a)</a>: Impact of the position nuisance parameter on the axion image.
          A value of $ϑ_{x,y} = 0.6$ is shown, moving the center of the image to the bottom left corner. <a href="#fig:limit:method_systematics:example_sigma_0.05">2(b)</a> shows the impact on the likelihood itself for varying $ϑ_{x,y}$ values given a standard deviation of $σ_{x,y} = 0.05$. Small variations of the position still yield contributions to $\mathcal{L}_M$. <a href="#fig:limit:method_systematics:example_sigma_0.25">2(c)</a> the same for $σ_{x,y} = 0.25$. At this value large regions
           of the $ϑ_{x,y}$ parameter space contribute to $\mathcal{L}_M$ , generally regions of larger $s/b$.</figcaption>
</figure>
</div>

<div class="outline-4" id="outline-container-orgd6460f3">
<h4 id="orgd6460f3"><span class="section-number-4">13.6.1.</span> Example for systematics   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-6-1">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>THINK ABOUT IF THIS IN THESIS!</b></li>
</ul>

<p>
For example assuming we had these systematics (expressed as
relative numbers from the best guess):
</p>
<ul class="org-ul">
<li>signal uncertainties:
<ul class="org-ul">
<li>magnet length: \(\SI{0.2}{\%}\)</li>
<li>magnet bore diameter: \(\SI{2.3}{\%}\)</li>
<li>window thickness: \(\SI{0.6}{\%}\)</li>
</ul></li>
<li>position uncertainty (of where the axion image is projected):
<ul class="org-ul">
<li>detector alignment: \(\SI{5}{\%}\)</li>
</ul></li>
<li>background uncertainty:
<ul class="org-ul">
<li>A: \(\SI{0.5}{\%}\) (whatever it may be, all real ones of mine are
very specific)</li>
</ul></li>
</ul>

<p>
From here we compute 3 combined systematics:
</p>
<ul class="org-ul">
<li>\(σ_s = \sqrt{ 0.2² + 2.3² + 0.6²} = \SI{2.38}{\%}\)</li>
<li>\(σ_p = \SI{5}{\%}\)</li>
<li>\(σ_b = \SI{0.5}{\%}\)</li>
</ul>
</div>
</div>

<div class="outline-4" id="outline-container-orgd62af2f">
<h4 id="orgd62af2f"><span class="section-number-4">13.6.2.</span> Generate plots of systematic   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-6-2">
<p>
The left most image in fig. <a href="#fig:limit:method_systematics:example">2</a>
is created as part of the <code>--raytracing</code> sanity check. The other two
are part of the <code>likelihoodSystematics</code> sanity check (from the
<code>plotLikelihoodCurves</code> proc via <code>calcPosition</code> for either the &quot;few&quot; or
&quot;many&quot; candidates case.
</p>

<p>
We place these into a separate directory, because for this particular
set of plots we wish to produce them with a target width of
<code>0.3333\textwidth</code>.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.33333333333 <span style="color: #FD971F;">DEBUG_TEX</span>=true <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
                      mcmc_limit_calculation sanity <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --sanityPath ~/phd/Figs/limit/sanity/fWidth0.3/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --likelihoodSystematics <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --raytracing <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --rombergIntegrationDepth 3
</pre>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-orgf47d50a">
<h4 id="orgf47d50a"><span class="section-number-4">13.6.3.</span> \(s&apos;\) is equivalent to \(s_i&apos;\) ?   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-6-3">
\begin{align*}
s &amp;= Σ_i s_i \\
s_i&apos; &amp;= s_i (1 + θ_s) \\
s&apos; &amp;= Σ_i s_i&apos; \\
   &amp;= Σ_i s_i (1 + θ_s) \\
   &amp;\text{as }(1 + θ_s)\text{ is constant} \\
   &amp;= (1 + θ_s) Σ_i s_i \\
   &amp;= (1 + θ_s) s \\
s&apos; &amp;= s (1 + θ_s) \\
\end{align*}
<p>
so indeed, this is perfectly valid.
</p>
</div>
</div>
</div>


<div class="outline-3" id="outline-container-sec:limit:method_mcmc">
<h3 id="sec:limit:method_mcmc"><span class="section-number-3">13.7.</span> Limit method - evaluating \(\mathcal{L}\) with nuisance parameters</h3>
<div class="outline-text-3" id="text-sec:limit:method_mcmc">
<p>
The likelihood function we started with \(\mathcal{L}\) was only a
function of the coupling constant \(g\) we want to compute a limit
for. With the inclusion of the four nuisance parameters however,
\(\mathcal{L}&apos;\) is now a function of 5 parameters, \(\mathcal{L}&apos;(g,
ϑ_s, ϑ_b, ϑ_x, ϑ_y)\). Following our definition of a limit via a fixed
percentile of the integral over the coupling constant,
eq. \eqref{eq:limit_method:limit_def}, leads to a problem for
\(\mathcal{L}&apos;\). If anything, one could define a contour describing the
95-th percentile of the &quot;integral volume&quot;, but this would lead to
infinitely many values of \(g\) that describe said contour.
</p>

<p>
As a result, to still define a sane limit value, the concept of the
marginal likelihood function \(\mathcal{L}&apos;_M\) is introduced. The idea is to
integrate out the nuisance parameters
</p>

\begin{equation}
\label{eq:limit:method_mcmc:L_integral}
\mathcal{L}&apos;_M(g) = \iiiint_{-∞}^∞ \mathcal{L}&apos;(g, ϑ_s, ϑ_b,ϑ_x,ϑ_y)\, \dd ϑ_s \dd ϑ_b \dd ϑ_x \dd ϑ_y.
\end{equation}

<p>
Depending on the exact definition of \(\mathcal{L}&apos;\) in use, these integrals
may be analytically computable. In many cases however they are not
and numerical techniques to evaluate the integral must be utilized.
</p>

<p>
Aside from the technical aspects about how to evaluate \(\mathcal{L}&apos;_M(g)\) at
a specific \(g\), the limit calculation continues exactly as for the
case without nuisance parameters once \(\mathcal{L}&apos;_M(g)\) is defined as such.
</p>

<dl class="org-dl">
<dt>Practical calculation of \(\mathcal{L}&apos;_M(g)\) in our case</dt><dd><p>
In case of our explicit likelihood function
eq. \eqref{eq:limit_method:likelihood_function_def} there is already one
particular case that makes the marginal likelihood not analytically
integrable because the \(b_i&apos; = b_i(1 + ϑ_b)\) term introduces a
singularity for \(ϑ_b = -1\). For practical purposes this is not too
relevant, as values approaching \(ϑ_b = -1\) would imply having zero
background and within a reasonable systematic uncertainty the
penalty term makes contributions in this limit so small such that
this area does not physically contribute to the integral.
</p>

<p>
Using standard numerical integration routines (simpson, adaptive
Gauss-Kronrod etc.) are all too expensive to compute such a
four-fold integration under the context of computing many toy limits for
an expected limit. For this reason Monte Carlo approaches are used,
in particular the Metropolis-Hastings
(<a href="./bibliography.html#citeproc_bib_item_158">Metropolis et al. 1953</a>; <a href="./bibliography.html#citeproc_bib_item_105">Hastings 1970</a>) (MH) Markov Chain Monte Carlo
(MCMC). The basic idea of general Monte Carlo integration routines
is to evaluate the function at random points and computing the
integral based on the function evaluation at these points (by
scaling the evaluations correctly). Unless the function is very
&apos;spiky&apos; in the integration space, Monte Carlo approaches provide
good accuracy at a fraction of the computational effort as normal
numerical algorithms even in higher dimensions. However, we can do
better than relying on <span class="underline">fully</span> random points in the integration
space. The Metropolis-Hastings algorithm tries to evaluate the
function more often in those points where the contributions are
large. The basic idea is the following:
</p>

<p>
Pick a random point in the integration space as a starting
point \(p_0\). Next, pick another random point \(p_1\) within the vicinity of
\(p_0\). If the function \(f\) evaluates to a larger value at \(p_1\), accept
it as the new current position. If it is smaller, accept it with a
probability of \(\frac{f(p_i)}{f(p_{i-1})}\) (i.e. if the new
value is close to the old one we accept it with a high probability
and if the new one is much lower accept it rarely). This guarantees 
to pick values inching closer to the most contributing areas of the
integral in the integration space, while still allowing to get out
of local maxima due to the random acceptance of &quot;worse&quot;
positions. However, this also implies that regions of constant
\(\mathcal{L}\) (regions where the values are close to 0, but also
generally &apos;flat&apos; regions) produce a pure random walk from the
algorithm, because \(\frac{f(p_i)}{f(p_{i-1})} \approx 1\) in those
regions. This needs to be taken into account.
</p>

<p>
If a new point is accepted and becomes the current position, the
&quot;chain&quot; of points is extended (hence &quot;Markov Chain&quot;). If a point is
rejected, extend the chain by duplicating the last point. By
creating a chain of reasonable length, the integration space is
sampled well. Because the initial point is completely random (up to
some possible prior) the first \(N\) links of the chain are in a
region of low interest (and depending on the interpretation of the
chain &quot;wrong&quot;). For that reason one defines a cutoff \(N_b\) of the
first elements that are thrown away as &quot;burn-in&quot; before using the
chain to evaluate the integral or parameters.
</p>

<p>
In addition it can be valuable to not only start a single Markov
Chain from one random point, but instead start <i>multiple</i> chains
from different points in the integration space. This increases the
chance to cover different regions of interest even in the presence
of multiple peaks separated too far away to likely &quot;jump over&quot; via
the probabilistic acceptance. As such it reduces bias from the
starting sampling.
</p>

<p>
To summarize the algorithm:
</p>
<ol class="org-ol">
<li>let \(\vec{p}\) be a random vector in the integration space and
\(f(\vec{p})\) the function to evaluate,</li>
<li>pick new point \(\vec{p}&apos;\) in vicinity of \(\vec{p}\),</li>
<li>sample from random uniform in \([0, 1]\): \(u\),</li>
<li>accept \(\vec{p}&apos;\) if \(u &lt; \frac{f(\vec{p}&apos;)}{f(\vec{p})}\), add
\(\vec{p}&apos;\) to chain and iterate (if \(f(\vec{p}&apos;) &gt; f(\vec{p})\) every
 new link accepted!). If rejected, add \(\vec{p}\) again,</li>
<li>generate a long enough chain to sample the integration space well,</li>
<li>throw away first N elements as &quot;burn in&quot;,</li>
<li>generate multiple chains to be less dependent on starting position.</li>
</ol>

<p>
Applied to eq. \eqref{eq:limit:method_mcmc:L_integral}, we obtain
\(\mathcal{L}_M(g)\) by computing the histogram of all sampled \(g\)
values, which are one component of the vector \(\vec{p}\). More on
that in sec. <a href="./limit.html#sec:limit:mcmc_calc_limit">13.12</a>.
</p></dd>
</dl>
</div>
</div>

<div class="outline-3" id="outline-container-org3d73a7f">
<h3 id="org3d73a7f"><span class="section-number-3">13.8.</span> Note about likelihood integral   <span class="tag">  <span class="extended">extended</span></span></h3>
<div class="outline-text-3" id="text-13-8">
<p>
The likelihood is a product of probability density functions. However,
it is important to note that the likelihood is a function of the
<b>parameter</b> and not the data. As such integrating over all parameters
does not necessarily equate to 1!
</p>
</div>
</div>


<div class="outline-3" id="outline-container-org610c782">
<h3 id="org610c782"><span class="section-number-3">13.9.</span> Derivation of short form of \(\mathcal{L}\) <code>[/]</code>   <span class="tag">  <span class="extended">extended</span></span></h3>
<div class="outline-text-3" id="text-13-9">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>WRITE THE NON LOG FORM</b></li>
</ul>

<p>
This uses the logarithm form, but the non log form is even easier actually.
</p>

\begin{align*}
\ln \mathcal{\mathcal{L}} &amp;= \ln \prod_i \frac{ \frac{(s_i + b_i)^{n_i}}{n_i!} e^{-(s_i + b_i)}  }{ \frac{b_i^{n_i}}{n_i!} e^{-b_i} } \\
  &amp;= \sum_i \ln \frac{ \frac{(s_i + b_i)^{n_i}}{n_i!} e^{-(s_i + b_i)}  }{ \frac{b_i^{n_i}}{n_i!} e^{-b_i} } \\
  &amp;= \sum_i \ln \frac{(s_i + b_i)^{n_i}}{n_i!} e^{-(s_i + b_i)}  - \ln \frac{b_i^{n_i}}{n_i!} e^{-b_i}  \\
  &amp;= \sum_i n_i \ln (s_i + b_i) - \ln n_i! - (s_i + b_i) - (n_i \ln b_i - \ln n_i! -b_i)  \\
  &amp;= \sum_i n_i \ln (s_i + b_i) - (s_i + b_i) - n_i \ln b_i + b_i  \\
  &amp;= \sum_i n_i \ln (s_i + b_i) - (s_i + b_i - b_i) - n_i \ln b_i  \\
  &amp;= \sum_i n_i \ln \left(\frac{s_i + b_i}{b_i}\right) - s_i  \\
  &amp;= -s_{\text{tot}} + \sum_i n_i \ln \left(\frac{s_i + b_i}{b_i} \right) \\
  &amp;\text{or alternatively} \\
  &amp;= -s_{\text{tot}} + \sum_i n_i \ln \left(1 + \frac{s_i}{b_i} \right) \\
\end{align*}
</div>
</div>


<div class="outline-3" id="outline-container-sec:limit:ingredients">
<h3 id="sec:limit:ingredients"><span class="section-number-3">13.10.</span> Likelihood ingredients in detail</h3>
<div class="outline-text-3" id="text-sec:limit:ingredients">
<p>
To reiterate, the likelihood function we finally evaluate using MCMC,
with explicit dependency on the coupling constant we intend to
(mainly) consider – the axion-electron coupling \(g_{ae}\) – can be
written as
</p>

<p>
\[
\mathcal{L&apos;}_{M}(g²_{ae}) = \iiiint_{-∞}^∞ e^{-s&apos;_{\text{tot}}(g²_{ae})} ·
  \prod_i \left(1 +\frac{s_i&apos;&apos;(g²_{ae})}{b_i&apos;}\right) ·
  \exp\left[
     -\frac{ϑ_b²}{2 σ_b²}
     -\frac{ϑ_s²}{2 σ_s²}
     -\frac{ϑ_x²}{2σ_x²}
     -\frac{ϑ_y²}{2 σ_y²}
     \right] \, \dd ϑ_b \dd ϑ_s \dd ϑ_x \dd ϑ_y,
\]
</p>

<p>
where \(i\) runs over all candidates. We alluded to the general make up
of both the signal terms \(s_{\text{tot}}\) and \(s_i\) as well as the
background \(b_i\) in sec. <a href="./limit.html#sec:limit:method_computing_L">13.3</a>. Let us now
look at what goes into each of these explicitly and how they are
calculated, starting with each of the signal contributions in
</p>

<p>
\[
s_i(g²_{ae}) = f(g²_{ae}, E_i) · A · t · P_{a \rightarrow γ}(g²_{aγ}) · ε(E_i) · r(x_i, y_i),
\]
</p>

<p>
sec. <a href="./limit.html#sec:limit:ingredients:magnet_tracking">13.10.1</a> to
sec. <a href="./limit.html#sec:limit:ingredients:total_signal">13.10.7</a> and the background in
sec. <a href="./limit.html#sec:limit:ingredients:background">13.10.8</a>. Finally,
sec. <a href="./limit.html#sec:limit:ingredients:candidates">13.10.9</a> explains how we sample toy
candidate sets.
</p>
</div>

<div class="outline-4" id="outline-container-sec:limit:ingredients:magnet_tracking">
<h4 id="sec:limit:ingredients:magnet_tracking"><span class="section-number-4">13.10.1.</span> Magnet bore and solar tracking time - \(A\), \(t\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:magnet_tracking">
<p>
Starting with the simplest inputs to the signal, the magnet bore area
and the solar tracking time. The CAST magnet has a bore diameter of
\(d_{\text{bore}} = \SI{43}{mm}\), as introduced in
sec. <a href="./helioscopes.html#sec:helioscopes:cast">5.1</a>. The relevant area for the solar axion flux
is the entire magnet bore, because the X-ray telescope covers the full
area. As such, \(A\) is a constant of:
</p>

<p>
\[
A = π (\SI{21.5}{mm})² = \SI{1452.2}{mm²}.
\]
</p>

<p>
The time of interest is the total solar tracking duration, in which
the detector was sensitive (i.e. removing the dead time due to
readout). As given in the CAST data taking overview,
sec. <a href="./cast.html#sec:cast:data_taking_campaigns">10.6</a>, the amount of active solar
tracking time is
</p>

<p>
\[
t = \SI{160.38}{h}.
\]
</p>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:ingredients:solar_axion_flux">
<h4 id="sec:limit:ingredients:solar_axion_flux"><span class="section-number-4">13.10.2.</span> Solar axion flux - \(f(g, E_i)\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:solar_axion_flux">
<p>
The solar axion flux is based on the calculations by J. Redondo
(<a href="./bibliography.html#citeproc_bib_item_183">Redondo 2013</a>) as already introduced in
sec. <a href="./theory.html#sec:theory:solar_axion_flux">4.5</a>. The \(f(g², E_i)\) term of the signal
refers to the differential solar axion flux. The flux,
fig. <a href="#fig:limit:ingredients:solar_axion_flux">3(a)</a>, is computed for a
specific axion model and coupling constant, in this case
\(g_{\text{ref}} = g_{ae} = \num{1e-13}\) and \(g_{aγ} =
\SI{1e-12}{GeV^{-1}}\). As the flux scales by the coupling constant
squared, it is rescaled to a new coupling constant \(g²_{ae}\) by
</p>

<p>
\[
f(g²_{ae}, E_i) = f(g²_{ae, \text{ref}}, E_i) · \frac{g²_{ae}}{g²_{\text{ref}, ae}}.
\]
</p>

<p>
\(g_{aγ}\) is kept constant. At this ratio of the two coupling
constants, the axion-photon flux is negligible.
</p>

<p>
The shown differential flux is computed using a Sun to Earth distance of
\(d_{S⇔E} = \SI{0.989}{AU}\) due to the times of the year in which solar
trackings were taken at
CAST. Fig. <a href="#fig:limit:ingredients:distance_sun_earth">3(b)</a> shows the distance
between Sun and Earth during the entire data taking period, with the
solar trackings marked in green. The data for the distance is
obtained using the JPL Horizons API (<a href="./bibliography.html#citeproc_bib_item_124">“JLP Horizons” 2023</a>).
</p>

<p>
The code used to calculate the differential flux,
(<a href="./bibliography.html#citeproc_bib_item_163">Von Oy 2023</a>) <sup>  <a role="doc-backlink" class="footref" id="fnr.6" href="#fn.6">6</a></sup>, can also be used
to compute the flux for other axion models, for example a pure
axion-photon coupling model.
</p>


<figure class="figure-wrapper" id="fig:limit:ingredients:flux_distance">
<figure class="subfigure" id="fig:limit:ingredients:solar_axion_flux" data-width="49%">  <img src="./figs/~/phd/Figs/axions/differential_solar_axion_flux_by_type.svg" data-width="99%" />  <figcaption>Figure 3(a): Solar axion flux</figcaption></figure> <figure class="subfigure" id="fig:limit:ingredients:distance_sun_earth" data-width="49%">  <img src="./figs/~/phd/Figs/systematics/sun_earth_distance_cast_solar_tracking.svg" data-width="99%" />  <figcaption>Figure 3(b): Distance Sun-Earth</figcaption></figure>
<figcaption>Figure 3: <a href="#fig:limit:ingredients:solar_axion_flux">3(a)</a>: Differential solar axion flux assuming a distance to the Sun of $\SI{0.989}{AU}$ based on <a href="#fig:limit:ingredients:distance_sun_earth">3(b)</a>.</figcaption>
</figure>
</div>

<div class="outline-5" id="outline-container-sec:limit:ingredients:solar_axion_flux:gen_flux_distance_sun">
<h5 id="sec:limit:ingredients:solar_axion_flux:gen_flux_distance_sun"><span class="section-number-5">13.10.2.1.</span> Generate solar axion flux plot and distance Sun-Earth   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-sec:limit:ingredients:solar_axion_flux:gen_flux_distance_sun">
<p>
Differential flux:
-&gt; <code>readOpacityFiles</code>
-&gt; See sec. <a href="./theory.html#sec:theory:gen_solar_axion_flux_plots">4.5.2</a> and sec. <a href="./raytracing.html#sec:appendix:raytracing:generate_axion_image">37.4.3</a>
</p>
</div>

<ol class="org-ol">
<li><a id="orgcd09ce9"> </a>Use Horizons API to download data for distance during CAST data taking<br />
<div class="outline-text-6" id="text-13-10-2-1-1">
<p>
See <a href="./../org/journal.html">./../org/journal.html</a>
-&gt; notes about writing the below code.
See <a href="./../org/journal.html">./../org/journal.html</a>
-&gt; notes on development of the <code>horizonsapi</code> Nim library that we use
below.
</p>

<p>
First we download the distance between the Sun and Earth during the
data taking campaign at CAST (between Jan 2017 and Dec 2019; we could
be more strict, but well).
</p>

<p>
This is done using <a href="https://github.com/SciNim/horizonsAPI">https://github.com/SciNim/horizonsAPI</a>, a simple
library to interface with JPL&apos;s Horizons API. An API that allows to
access all sorts of data about the solar system.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> horizonsapi, datamancer, times

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">startDate </span>= initDateTime<span style="color: #AE81FF;">(</span><span style="font-style: italic;">01</span>, mJan, <span style="font-style: italic;">2017</span>, <span style="font-style: italic;">00</span>, <span style="font-style: italic;">00</span>, <span style="font-style: italic;">00</span>, <span style="font-style: italic;">00</span>, local<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">stopDate </span>= initDateTime<span style="color: #AE81FF;">(</span><span style="font-style: italic;">31</span>, mDec, <span style="font-style: italic;">2019</span>, <span style="font-style: italic;">23</span>, <span style="font-style: italic;">59</span>, <span style="font-style: italic;">59</span>, <span style="font-style: italic;">00</span>, local<span style="color: #66D9EF;">()</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">nMins </span>= <span style="color: #AE81FF;">(</span>stopDate - startDate<span style="color: #AE81FF;">)</span>.inMinutes<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">blockSize </span>= <span style="font-style: italic;">85_000</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">max line number somewhere above 90k. Do less to have some buffer</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">numBlocks </span>= ceil<span style="color: #AE81FF;">(</span>nMins.<span style="color: #66D9EF;">float</span> / blockSize.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">int</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">we end up at a later date than `</span><span style="color: #AE81FF;">stopDate</span><span style="color: #75715E;">`, but that&apos;s fine</span>
<span style="color: #F92672;">echo</span> numBlocks
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">blockDur </span>= initDuration<span style="color: #AE81FF;">(</span>minutes = blockSize<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">comOpt </span>= <span style="color: #AE81FF;">{</span> <span style="color: #75715E;">#</span><span style="color: #75715E;">coFormat : &quot;json&quot;, # data returned as &quot;fake&quot; JSON </span>
               coMakeEphem : <span style="color: #E6DB74;">&quot;YES&quot;</span>, 
               coCommand : <span style="color: #E6DB74;">&quot;10&quot;</span>,  <span style="color: #75715E;"># </span><span style="color: #75715E;">our target is the Sun, index 10</span>
               coEphemType : <span style="color: #E6DB74;">&quot;OBSERVER&quot;</span> <span style="color: #AE81FF;">}</span>.toTable <span style="color: #75715E;"># </span><span style="color: #75715E;">observational parameters</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">ephOpt </span>= <span style="color: #AE81FF;">{</span> eoCenter : <span style="color: #E6DB74;">&quot;coord@399&quot;</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">observational point is a coordinate on Earth (Earth idx 399)</span>
               eoStartTime : startDate.format<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;yyyy-MM-dd&quot;</span><span style="color: #66D9EF;">)</span>,
               eoStopTime : <span style="color: #66D9EF;">(</span>startDate + blockDur<span style="color: #66D9EF;">)</span>.format<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;yyyy-MM-dd&quot;</span><span style="color: #66D9EF;">)</span>,
               eoStepSize : <span style="color: #E6DB74;">&quot;1 MIN&quot;</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">in 1 min steps</span>
               eoCoordType : <span style="color: #E6DB74;">&quot;GEODETIC&quot;</span>, 
               eoSiteCoord : <span style="color: #E6DB74;">&quot;+6.06670,+46.23330,0&quot;</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">Geneva</span>
               eoCSVFormat : <span style="color: #E6DB74;">&quot;YES&quot;</span> <span style="color: #AE81FF;">}</span>.toTable <span style="color: #75715E;"># </span><span style="color: #75715E;">data as CSV within the JSON (yes, really)</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">q</span>: <span style="color: #66D9EF;">Quantities</span>
q.<span style="color: #F92672;">incl</span> <span style="font-style: italic;">20</span> <span style="color: #E6DB74;">## Observer range! In this case range between our coordinates on Earth and target</span>

<span style="color: #F92672;">var</span> <span style="color: #FD971F;">reqs </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">HorizonsRequest</span><span style="color: #AE81FF;">]()</span>
<span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; numBlocks:
  <span style="color: #75715E;"># </span><span style="color: #75715E;">modify the start and end dates</span>
  ephOpt<span style="color: #AE81FF;">[</span>eoStartTime<span style="color: #AE81FF;">]</span> = <span style="color: #AE81FF;">(</span>startDate + i * blockDur<span style="color: #AE81FF;">)</span>.format<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;yyyy-MM-dd&quot;</span><span style="color: #AE81FF;">)</span>
  ephOpt<span style="color: #AE81FF;">[</span>eoStopTime<span style="color: #AE81FF;">]</span> = <span style="color: #AE81FF;">(</span>startDate + <span style="color: #66D9EF;">(</span>i+<span style="font-style: italic;">1</span><span style="color: #66D9EF;">)</span> * blockDur<span style="color: #AE81FF;">)</span>.format<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;yyyy-MM-dd&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;From : &quot;</span>, ephOpt<span style="color: #AE81FF;">[</span>eoStartTime<span style="color: #AE81FF;">]</span>, <span style="color: #E6DB74;">&quot; to &quot;</span>, ephOpt<span style="color: #AE81FF;">[</span>eoStopTime<span style="color: #AE81FF;">]</span>
  reqs.<span style="color: #F92672;">add</span> initHorizonsRequest<span style="color: #AE81FF;">(</span>comOpt, ephOpt, q<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">res </span>= getResponsesSync<span style="color: #AE81FF;">(</span>reqs<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">convertToDf</span><span style="color: #AE81FF;">(</span>res: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">HorizonsResponse</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> r <span style="color: #F92672;">in</span> res:
    <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> parseCsvString<span style="color: #AE81FF;">(</span>r.csvData<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= res.convertToDf<span style="color: #AE81FF;">()</span>.unique<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Date__(UT)__HR:MN&quot;</span><span style="color: #AE81FF;">)</span>
  .select<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Date__(UT)__HR:MN&quot;</span>, <span style="color: #E6DB74;">&quot;delta&quot;</span>, <span style="color: #E6DB74;">&quot;deldot&quot;</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> df

df.writeCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/phd/resources/sun_earth_distance_cast_datataking.csv&quot;</span>,
            precision = <span style="font-style: italic;">16</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="orgf0a60c8"> </a>Generate plot of distance with CAST trackings marked<br />
<div class="outline-text-6" id="text-13-10-2-1-2">
<p>
See again <a href="./../org/journal.html">./../org/journal.html</a>
</p>

<p>
With the CSV file produced in the previous section we can now plot the
CAST trackings (from the TimepixAnalysis <code>resources</code> directory)
against it.
</p>

<p>
Note: We need to use the same plot height as for the differential
axion flux produced in
sec. <a href="./theory.html#sec:theory:gen_solar_axion_flux_plots">4.5.2</a>. Height not defined, width
600 (golden ratio).
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim, sequtils, times, strutils, strformat
<span style="color: #75715E;"># </span><span style="color: #75715E;">2017-Jan-01 00:00</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">Format</span> = <span style="color: #E6DB74;">&quot;yyyy-MMM-dd HH:mm&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">OrgFormat</span> = <span style="color: #E6DB74;">&quot;&apos;&lt;&apos;yyyy-MM-dd ddd H:mm&apos;&gt;&apos;&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">p2017 </span>= <span style="color: #E6DB74;">&quot;~/CastData/ExternCode/TimepixAnalysis/resources/DataRuns2017_Reco_tracking_times.csv&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">p2018 </span>= <span style="color: #E6DB74;">&quot;~/CastData/ExternCode/TimepixAnalysis/resources/DataRuns2018_Reco_tracking_times.csv&quot;</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/resources/sun_earth_distance_cast_datataking.csv&quot;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">int</span>: <span style="color: #E6DB74;">&quot;Timestamp&quot;</span> ~ parseTime<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Date__(UT)__HR:MN&quot;</span><span style="color: #E6DB74;">)</span>.strip, <span style="color: #66D9EF;">Format</span>, local<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>.toUnix.<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readRuns</span><span style="color: #AE81FF;">(</span>f: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = readCsv<span style="color: #AE81FF;">(</span>f<span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">int</span>: <span style="color: #E6DB74;">&quot;TimestampStart&quot;</span> ~ parseTime<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Tracking start&quot;</span><span style="color: #E6DB74;">)</span>, <span style="color: #66D9EF;">OrgFormat</span>, local<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>.toUnix.<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span> -&gt; <span style="color: #66D9EF;">int</span>: <span style="color: #E6DB74;">&quot;TimestampStop&quot;</span> ~ parseTime<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Tracking stop&quot;</span><span style="color: #E6DB74;">)</span>, <span style="color: #66D9EF;">OrgFormat</span>, local<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span>.toUnix.<span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfR </span>= readRuns<span style="color: #AE81FF;">(</span>p2017<span style="color: #AE81FF;">)</span>  
dfR.<span style="color: #F92672;">add</span> readRuns<span style="color: #AE81FF;">(</span>p2018<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfHT </span>= newDataFrame<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">for</span> tracking <span style="color: #F92672;">in</span> dfR:
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">start </span>= tracking<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;TimestampStart&quot;</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">toInt</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">stop </span>= tracking<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;TimestampStop&quot;</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">toInt</span>
  dfHT.<span style="color: #F92672;">add</span> df.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">int</span>: `<span style="color: #66D9EF;">Timestamp</span>` &gt;= start <span style="color: #F92672;">and</span> `<span style="color: #66D9EF;">Timestamp</span>` &lt;= stop<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

dfHT<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #AE81FF;">]</span> = <span style="color: #E6DB74;">&quot;Trackings&quot;</span>
df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #AE81FF;">]</span> = <span style="color: #E6DB74;">&quot;HorizonsAPI&quot;</span>
df.<span style="color: #F92672;">add</span> dfHT

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">deltas </span>= dfHT<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;delta&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">meanD </span>= deltas.mean
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">varD </span>= deltas.variance
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">stdD </span>= deltas.std
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Mean distance during trackings = &quot;</span>, meanD
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Variance of distance during trackings = &quot;</span>, varD
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Std of distance during trackings = &quot;</span>, stdD
<span style="color: #75715E;"># </span><span style="color: #75715E;">and write back the DF of the tracking positions</span>
<span style="color: #75715E;">#</span><span style="color: #75715E;">dfHT.writeCsv(&quot;~/phd/resources/sun_earth_distance_cast_solar_trackings.csv&quot;)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">texts </span>= @<span style="color: #AE81FF;">[</span>r<span style="color: #E6DB74;">&quot;$μ_{\text{distance}} = &quot;</span> &amp; &amp;<span style="color: #E6DB74;">&quot;{meanD:.4f}$&quot;</span>,
              <span style="color: #75715E;">#</span><span style="color: #75715E;">r&quot;$\text{Variance} = &quot; &amp; &amp;&quot;{varD:.4g}$&quot;,</span>
              r<span style="color: #E6DB74;">&quot;$σ_{\text{distance}} = &quot;</span> &amp; &amp;<span style="color: #E6DB74;">&quot;{stdD:.4f}$&quot;</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">annot </span>= texts.join<span style="color: #AE81FF;">(</span>r<span style="color: #E6DB74;">&quot;\\&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Annot: &quot;</span>, annot

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">thm</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">Theme</span> =
  <span style="color: #FD971F;">result</span> = sideBySide<span style="color: #AE81FF;">()</span>
  <span style="color: #FD971F;">result</span>.annotationFont = some<span style="color: #AE81FF;">(</span>font<span style="color: #66D9EF;">(</span><span style="font-style: italic;">7</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">we don&apos;t want monospace font!</span>

ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Timestamp&quot;</span>, <span style="color: #E6DB74;">&quot;delta&quot;</span>, color = <span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">(</span>data = df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;HorizonsAPI&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_point<span style="color: #AE81FF;">(</span>data = df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;Trackings&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, size = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  scale_x_date<span style="color: #AE81FF;">(</span>isTimestamp = <span style="color: #AE81FF;">true</span>,
               formatString = <span style="color: #E6DB74;">&quot;yyyy-MM&quot;</span>,
               dateSpacing = initDuration<span style="color: #66D9EF;">(</span>days = <span style="font-style: italic;">90</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Date&quot;</span>, rotate = -<span style="font-style: italic;">45</span>.<span style="font-style: italic;">0</span>, alignTo = <span style="color: #E6DB74;">&quot;right&quot;</span>, margin = <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> +
  annotate<span style="color: #AE81FF;">(</span>text = annot, x = <span style="font-style: italic;">1</span>.5975e9, y = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0075</span><span style="color: #AE81FF;">)</span> + 
  ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Distance in AU Sun ⇔ Earth&quot;</span><span style="color: #AE81FF;">)</span> +
  legendPosition<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">7</span>, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">2</span><span style="color: #AE81FF;">)</span> + 
  themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, width = <span style="font-style: italic;">600</span>, baseTheme = thm, useTeX = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span> +
  margin<span style="color: #AE81FF;">(</span>left = <span style="font-style: italic;">3</span>.<span style="font-style: italic;">5</span>, bottom = <span style="font-style: italic;">3</span>.<span style="font-style: italic;">75</span><span style="color: #AE81FF;">)</span> + 
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/systematics/sun_earth_distance_cast_solar_tracking.pdf&quot;</span>, width = <span style="font-style: italic;">600</span>, height = <span style="font-style: italic;">360</span>, dataAsBitmap = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</li>
</ol>
</div>
</div>


<div class="outline-4" id="outline-container-sec:limit:ingredients:conversion_probability">
<h4 id="sec:limit:ingredients:conversion_probability"><span class="section-number-4">13.10.3.</span> Conversion probability - \(P_{aγ}(g²_{aγ})\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:conversion_probability">
<p>
The conversion probability of the arriving axions is simply a constant
factor, depending on \(g_{aγ}\), see section
<a href="./theory.html#sec:theory:axion_interactions">4.4</a> for the derivation from the general
formula. The simplified expression for coherent
conversion <sup>  <a role="doc-backlink" class="footref" id="fnr.7" href="#fn.7">7</a></sup> in a constant magnetic
field <sup>  <a role="doc-backlink" class="footref" id="fnr.8" href="#fn.8">8</a></sup> is
</p>

<p>
\[
P(g²_{aγ}, B, L) = \left(\frac{g_{aγ} \cdot B \cdot L}{2}\right)^2
\]
where the relevant numbers for the CAST magnet are:
</p>

\begin{align*}
B &amp;= \SI{8.8}{T} &amp;↦ B_{\text{natural}} &amp;= \SI{1719.1}{eV^2} \\
L &amp;= \SI{9.26}{m} &amp;↦ L_{\text{natural}} &amp;= \SI{4.69272e7}{eV^{-1}}. 
\end{align*}

<p>
The magnetic field is taken from the CAST slow control log files and
matches the values used in the paper of CAST CAPP
(<a href="./bibliography.html#citeproc_bib_item_2">Adair et al. 2022</a>) (in contrast to some older papers which assumed
\(\SI{9}{T}\), based on when the magnet was still intended to be run at
above \(\SI{13000}{A}\)).
</p>

<p>
Assuming a fixed axion-photon coupling of \(g_{aγ} =
\SI{1e-12}{GeV^{-1}}\) the conversion probability comes out to:
</p>
\begin{align*}
P(g²_{aγ}, B, L) &amp;= \left(\frac{g_{aγ} \cdot B \cdot L}{2}\right)^2 \\
                &amp;= \left(\frac{\SI{1e-12}{GeV^{-1}} \cdot \SI{1719.1}{eV^2} \cdot \SI{4.693e7}{eV^{-1}}}{2}\right)^2 \\
                &amp;= \num{1.627e-21}
\end{align*}
</div>

<div class="outline-5" id="outline-container-org9a648f4">
<h5 id="org9a648f4"><span class="section-number-5">13.10.3.1.</span> Computing conversion factors and comparing natural to SI eq.   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-10-3-1">
<p>
The conversion factors from Tesla and meter to natural units are as follows:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Conversion factor Tesla: &quot;</span>, <span style="font-style: italic;">1</span>.<span style="color: #66D9EF;">T</span>.toNaturalUnit<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Conversion factor Meter: &quot;</span>, <span style="font-style: italic;">1</span>.m.toNaturalUnit<span style="color: #AE81FF;">()</span>
</pre>
</div>
<p>
Conversion factor Tesla: 195.353 ElectronVolt²
Conversion factor Meter: 5.06773e+06 ElectronVolt⁻¹
</p>

<p>
<b>TODO</b>: Move this out of the thesis and just show the numbers in text?
Keep the &quot;derivation / computation&quot; for the &quot;full&quot; version (:noexport:
?).
</p>

<p>
As such, the resulting conversion probability ends up as:
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;8.8 T  = &quot;</span>, <span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span>.toNaturalUnit<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;9.26 m = &quot;</span>, <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m.toNaturalUnit<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;P      = &quot;</span>, pow<span style="color: #AE81FF;">(</span> 1e-<span style="font-style: italic;">12</span>.GeV⁻¹ * <span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span>.toNaturalUnit<span style="color: #66D9EF;">()</span> * <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m.toNaturalUnit<span style="color: #66D9EF;">()</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
<p>
8.8 T  = 1719.1 eV²
9.26 m = 4.69272e+07 eV⁻¹
P      = 1.627022264358953e-21
</p>

\begin{align*}
P(g_{aγ}, B, L) &amp;= \left(\frac{g_{aγ} \cdot B \cdot L}{2}\right)^2 \\
               &amp;= \left(\frac{\SI{1e-12}{\per GeV} \cdot \SI{1719.1}{eV^2} \cdot \SI{4.693e7}{eV}}{2}\right)^2 \\
               &amp;= \num{1.627e-21}
\end{align*}

<p>
Note that this is of the same (inverse) order of magnitude as the flux
of solar axions (\(\sim10^{21}\) in some sensible unit of time), meaning
the experiment expects \(\mathcal{O}(1)\) counts, which is sensible.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;8.8 T  = &quot;</span>, <span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span>.toNaturalUnit<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;9.26 m = &quot;</span>, <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m.toNaturalUnit<span style="color: #AE81FF;">()</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;P(natural) = &quot;</span>, pow<span style="color: #AE81FF;">(</span> 1e-<span style="font-style: italic;">12</span>.GeV⁻¹ * <span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span>.toNaturalUnit<span style="color: #66D9EF;">()</span> * <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m.toNaturalUnit<span style="color: #66D9EF;">()</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;P(SI)      = &quot;</span>, ε0 * <span style="color: #AE81FF;">(</span>hp / <span style="color: #66D9EF;">(</span><span style="font-style: italic;">2</span>*π<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> * <span style="color: #AE81FF;">(</span>c^<span style="font-style: italic;">3</span><span style="color: #AE81FF;">)</span> * <span style="color: #AE81FF;">(</span>1e-<span style="font-style: italic;">12</span>.GeV⁻¹ * <span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span> * <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>^<span style="font-style: italic;">2</span>
</pre>
</div>

<p>
As we can see, both approaches yield the same numbers, meaning the
additional conversion factors are correct.
</p>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:ingredients:detection_eff">
<h4 id="sec:limit:ingredients:detection_eff"><span class="section-number-4">13.10.4.</span> Detection efficiency - \(ε(E_i)\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:detection_eff">
<p>
The detection efficiency \(ε(E_i)\) includes multiple aspects of the
full setup. It can be further decomposed into the telescope
efficiency, window transparency, gas absorption, software efficiency
of the classifier and veto efficiency,
</p>

<p>
\[
ε(E_i) = ε_{\text{telescope}}(E_i) · ε_{\text{window}}(E_i) · ε_{\text{gas}}(E_i) · ε_{\text{software eff.}} · ε_{\text{veto eff.}}.
\]
</p>

<p>
The first three are energy dependent and the latter two constants, but
dependent on the classifier and veto setup for which we compute limits.
</p>
</div>

<div class="outline-5" id="outline-container-org591ca50">
<h5 id="org591ca50"><span class="section-number-5">13.10.4.1.</span> Telescope efficiency - \(ε_{\text{telescope}}(E_i)\)</h5>
<div class="outline-text-5" id="text-13-10-4-1">
<p>
The X-ray telescope further has a direct impact not only on the shape
of the axion signal on the readout, but also the total number of
X-rays transmitted. The effective transmission of an X-ray telescope
is significantly lower than in the optical range. This is typically
quoted using the term &quot;effective area&quot;. In section
<a href="./helioscopes.html#sec:helioscopes:cast:xray_optics">5.1.3</a> the effective area of the two X-ray
optics used at CAST is shown. The term effective area refers to the
equivalent area a perfect X-ray telescope (\(\SI{100}{\%}\)
transmission) would cover. As such, the real efficiency
\(ε_{\text{tel}}\) can be computed by the ratio of the effective area
\(A_{\text{eff}}\) and the total area of the optic \(A_{\text{tel}}\)
exposed to light.
</p>

<p>
\[
ε_{\text{tel}}(E) = \frac{A_{\text{eff}}(E)}{A_{\text{tel}}}
\]
</p>

<p>
where the effective area \(A_{\text{eff}}\) depends on the
energy. <sup>  <a role="doc-backlink" class="footref" id="fnr.9" href="#fn.9">9</a></sup> In case of CAST the relevant total
area is not actually the cross-sectional area of the optic itself, but
rather the exposed area due to the diameter of the magnet
coldbore. With a coldbore diameter of \(d_{\text{bore}} = \SI{43}{mm}\)
the effective area can be converted to \(ε_{\text{tel}}\).
</p>

<p>
The resulting effective area is shown in
fig. <a href="#fig:limit:limit_method:combined_detection_eff">4</a> in the next section
together with the window transmission and gas absorption.
</p>

<blockquote>
<p>
Note: all publicly available effective areas for the LLNL telescope,
meaning (<a href="./bibliography.html#citeproc_bib_item_123">Jakobsen 2015</a>) and (<a href="./bibliography.html#citeproc_bib_item_28">Aznar et al. 2015</a>),
are either inapplicable, outdated or unfortunately wrong. Jaime Ruz
sent me the simulation results used for the CAST Nature paper
(<a href="./bibliography.html#citeproc_bib_item_66">Collaboration and others 2017</a>), which include the effective area. These numbers are
used in the figure below and our limit calculation.
</p>
</blockquote>
</div>

<ol class="org-ol">
<li><a id="orgb2bea3c"> </a>Notes on the effective area   <span class="tag">  <span class="extended">extended</span></span><br />
<div class="outline-text-6" id="text-13-10-4-1-1">
<p>
Some might say people working with X-ray telescopes prefer the
&apos;effective area&apos; as a measure of efficiency to hide the fact how
inefficient X-ray telescopes are, whoops.
</p>

<p>
Anyway, the effective area of the LLNL telescope is still the biggest
mystery to me. If you haven&apos;t read the raytracing appendix
<a href="./raytracing.html#sec:appendix:raytracing">37</a>, in particular the section about the LLNL
telescope, sec. <a href="./raytracing.html#sec:appendix:raytracing:llnl_telescope">37.2</a>, the public
information available about the LLNL telescope is either outdated,
contradictory or plain wrong.
</p>

<p>
The PhD thesis of Anders Jakobsen (<a href="./bibliography.html#citeproc_bib_item_123">Jakobsen 2015</a>) contains a plot of
the effective area (fig. 4.13 on page 64, 87 of PDF), which peaks near
~10 cm². However, it is unclear what the numbers are actually based
on. Likely they describe parallel incoming light. In addition they
likely include the initial telescope design of 14 instead of the final
13 shells. Both means the result is an overestimate.
</p>

<p>
Then, (<a href="./bibliography.html#citeproc_bib_item_28">Aznar et al. 2015</a>), the paper about the
telescope at CAST, contains another effective area plot peaking at
about 8.2 cm². It is stated the numbers are for an HPD (half power
diameter) of 75 arc seconds using a solar axion emission from a 3
arcmin disc size. And yet, apparently these numbers are still an
overestimate.
</p>

<p>
As mentioned in the main text above, I was sent the simulations used for
the CAST Nature paper (<a href="./bibliography.html#citeproc_bib_item_66">Collaboration and others 2017</a>) by Jaime Ruz, which contain
the axion image and effective area. These numbers peak at only about
7.3 cm²! At the very least this roughly matches the slides from the
CAST collaboration meeting on <span class="timestamp-wrapper">  <span class="timestamp">&lt;2017-01-23 Mon&gt;</span></span>, on slide 36. If one
looks at those slides, one might notice that the results on slide 35
for the best model actually peak closer to the aforementioned
8.2 cm². According to Jaime the reason for this is that the higher
numbers are based on the <i>full</i> telescope area and the lower numbers
only the size of CAST&apos;s magnet bore.
</p>

<p>
This may very well all be true. My personal skepticism is due to two
things:
</p>
<ol class="org-ol">
<li>my general feeling that the numbers are exceptionally
low. Essentially the telescope is mostly <i>worse</i> than the ABRIXAS
telescope, which just surprises me. But I&apos;m obviously not an X-ray
telescope expert.</li>
<li>more importantly, every attempt of mine to compute the effective
area based on the reflectivities of the shells with parallel or
realistic solar axion emission yielded numbers quite a bit higher
than the data sent to me by Jaime.</li>
</ol>

<p>
<b>One note though</b>: I still need to repeat the effective area
calculations for the &apos;realistic&apos; solar axion emission after fixing a
random sampling bug. It may very well affect the result, even though
it would surprise me if that explained the difference I saw.
</p>

<p>
The most likely reason is that simply my simulation is off. Possibly
the – mentioned in the slides of the CCM – contamination of
hydrcarbons affect the reflectivity so much as to explain the
difference. 
</p>
</div>
</li>
</ol>
</div>

<div class="outline-5" id="outline-container-org84fffd5">
<h5 id="org84fffd5"><span class="section-number-5">13.10.4.2.</span> Window transmission and argon gas absorption - \(ε_{\text{window}}(E_i), ε_{\text{gas}}(E_i)\)</h5>
<div class="outline-text-5" id="text-13-10-4-2">
<p>
The detector entrance window is the next point affecting the possible
signal to be detected. The windows, as explained in section
<a href="./septemboard.html#sec:detector:sin_window">7.9</a> are made from \(\SI{300}{nm}\) thick silicon
nitride with a \(\SI{20}{nm}\) thick aluminium coating. Its transmission
is very good down to about \(\SI{1}{keV}\) below which it also starts to
degrade rapidly.
</p>

<p>
While the window also has four \(\SI{500}{μm}\) thick strongbacks which in
total occlude about \(\SI{22.2}{\%}\) of the center region, these are
<i>not</i> taken into account into the combined detection
efficiency. Instead they are handled together with the axion image
\(r(x_i, y_i)\) in sec. <a href="./limit.html#sec:limit:ingredients:raytracing">13.10.6</a>.
</p>
</div>
</div>

<div class="outline-5" id="outline-container-org959fc62">
<h5 id="org959fc62"><span class="section-number-5">13.10.4.3.</span> Software efficiency and veto efficiency - \(ε_{\text{software eff.}} · ε_{\text{veto eff.}}\)</h5>
<div class="outline-text-5" id="text-13-10-4-3">
<p>
The software efficiency \(ε_{\text{software eff.}}\) of course depends
on the specific setting which is used. Its value will range from
somewhere between \SIrange{80}{97}{\%}.  The veto efficiencies in
principle can also vary significantly depending on the choice of
parameters (e.g. whether the &apos;line veto&apos; uses an eccentricity cutoff
or not), but as explained in
sec. <a href="./background.html#sec:background:estimate_veto_efficiency">12.5.5</a> the septem and line
vetoes are just considered as either yes or no. The FADC veto has also
been fixed to a \(1^{\text{st}}\) to \(99^{\text{th}}\) percentile cut on
the signal rise time, see sec. <a href="./background.html#sec:background:fadc_veto">12.5.2</a>. 
</p>

<p>
As such the relevant veto efficiencies are:
</p>

\begin{align*}
ε_{\text{FADC}} &amp;= \SI{98}{\%} \\
ε_{\text{septem}} &amp;= \SI{83.11}{\%} \\
ε_{\text{line}} &amp;= \SI{85.39}{\%} \\
ε_{\text{septem+line}} &amp;= \SI{78.63}{\%} 
\end{align*}

<p>
where the last one corresponds to using both the septem and the line
veto at the same time. Considering for example the case of using these
vetoes together with a software efficiency of \(\SI{80}{\%}\) we see
that the combined efficiency is already only about \(\SI{61.6}{\%}\),
which is an extreme loss in sensitivity.
</p>
</div>
</div>


<div class="outline-5" id="outline-container-orgedafff7">
<h5 id="orgedafff7"><span class="section-number-5">13.10.4.4.</span> Combined detection efficiency - \(ε(E_i)\)</h5>
<div class="outline-text-5" id="text-13-10-4-4">
<p>
The previous sections cover aspects which affect the detection
efficiency of the detector and thus impact the amount of signal
available. Combined they yield a detection efficiency as shown in
fig. <a href="#fig:limit:limit_method:combined_detection_eff">4</a>. As can be seen,
the combined detection efficiency maxes out at about \(\sim\SI{46}{\%}\)
around \(\SI{1.5}{keV}\) without taking into account the software and
veto efficiencies. If one combines this with using all vetoes at a
software efficiency of \(\SI{80}{\%}\), the total detection efficiency
of the detector would peak at only \(\SI{28.4}{\%}\) at that energy.
</p>


<figure id="fig:limit:limit_method:combined_detection_eff">
<img src="./figs/home/basti/phd/Figs/limit/detection_efficiency.svg" class="org-svg" alt="detection_efficiency.svg" />

<figcaption>Figure 4: <span class="figure-number">Figure 82: </span>The combined detection efficiency of the detector, taking into account the telescope efficiency via the effective area, the window absorption probability and the absorption probability in the detector gas.</figcaption>
</figure>
</div>


<ol class="org-ol">
<li><a id="sec:limit:ingredients:gen_detection_eff"> </a>Generate plot of detection efficiency <code>[/]</code>   <span class="tag">  <span class="extended">extended</span></span><br />
<div class="outline-text-6" id="text-sec:limit:ingredients:gen_detection_eff">
<p>
<b>NOTE</b>: We also have
<a href="./../CastData/ExternCode/TimepixAnalysis/Tools/septemboardDetectionEff/septemboardDetectionEff.nim">./../CastData/ExternCode/TimepixAnalysis/Tools/septemboardDetectionEff/septemboardDetectionEff.nim</a>
nowadays for the limit calculation (to produce the CSV file including
LLNL effective area).
</p>

<p>
<b>UPDATE</b>: <span class="timestamp-wrapper">  <span class="timestamp">&lt;2024-05-10 Fri 17:36&gt;</span></span>
Updated the code of <code>septemboardDetectionEff</code> to not include a mention
of the &apos;software eff.&apos; in the title, as that is plain wrong.
</p>

<p>
To produce the CSV file
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">USE_TEX</span>=true ./septemboardDetectionEff <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/resources/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotPath ~/phd/Figs/limit/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --llnlEff ~/org/resources/llnl_cast_nature_jaime_data/2016_DEC_Final_CAST_XRT/EffectiveArea.txt <span style="color: #E6DB74; font-weight: bold;">\</span>
    --sep <span style="color: #E6DB74;">&apos; &apos;</span>
</pre>
</div>
<p>
note the usage of the &quot;correct&quot; effective area file. 
</p>

<ul class="org-ul">
<li class="on"><code>[X]</code> Well, do we need the ingredients separately? Not really right?
-&gt; No.</li>
</ul>

<p>
We need the effective area (ideally we would compute it! but of course
currently we cannot reproduce it :( ).
</p>

<p>
So just read the extended LLNL file.
</p>

<ul class="org-ul">
<li class="on"><code>[X]</code> Need densities of Aluminium, …
-&gt; 2.7 g•cm⁻³</li>
<li class="on"><code>[X]</code> Need to update xrayAttenuation to create the plot!
-&gt; Done.</li>
<li class="on"><code>[X]</code> NEED TO update numericalnim for interpolation!</li>
<li class="on"><code>[X]</code> NEED TO update seqmath for linspace fixes</li>

<li class="on"><code>[X]</code> <b>USE 2016 FINAL EFFECTIVE AREA</b></li>
</ul>
</div>
</li>
</ol>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:median_absorption_depth">
<h4 id="sec:limit:median_absorption_depth"><span class="section-number-4">13.10.5.</span> Average absorption depth of X-rays</h4>
<div class="outline-text-4" id="text-sec:limit:median_absorption_depth">
<p>
In order to compute a realistic axion image based on raytracing, the
plane at which to compute the image needs to be known, as the focal
spot size changes significantly depending on the distance to the focal
point of the X-ray optics. The beamline behind the telescope is
designed such that the focal spot is \(\SI{1}{cm}\) behind the entrance
window. <sup>  <a role="doc-backlink" class="footref" id="fnr.10" href="#fn.10">10</a></sup>
</p>

<p>
This is of particular importance for a gaseous detector, as the
raytracing only makes sense up to the generation of a photoelectron,
after which the produced primary electrons undergo
diffusion. Therefore, one needs to compute the typical absorption
depth of X-rays in the relevant energy ranges for the used gas mixture
of the detector. This is easiest done based on a Monte Carlo
simulation taking into account the incoming X-ray flux distribution
(given the solar axion flux we consider) \(f(E)\), the telescope
effective area \(ε_{\text{LLNL}}(E)\) and window transmission, \(ε_{\ce{Si3 N4}}(E), ε_{\ce{Al}}(E)\),
</p>

<p>
\[
I(E) = f(E) · ε_{\text{LLNL}}(E) · ε_{\ce{Si3 N4}}(E) · ε_{\ce{Al}}(E).
\]
</p>

<p>
\(I(E)\) yields the correct energy distribution of expected signal
X-rays. For each sampled X-ray we can then draw a conversion point
based on the attenuation length and the Beer-Lambert law for its
energy introduced in sec. <a href="./theory_detector.html#sec:theory:xray_matter_gas">6.1.1</a>. Computing the
median of all conversion points is then an estimator for the point at
which to compute the axion image.
</p>

<p>
Performing this calculation leads to a median conversion point of
\(⟨d⟩ = \SI{0.2928}{cm}\) behind the detector window, with a standard deviation
of \(\SI{0.4247}{cm}\) due to a long tail from higher energy X-rays. It
may be worthwhile to perform this calculation for distinct energies to
then compute different axion images for different energies with each
their own effective &apos;depth&apos; behind the window, however for the time
being we do not.
</p>

<p>
For the calculation of these numbers, see appendix <a href="./average_depth_xrays_argon.html#sec:appendix:average_depth_xrays_argon">36</a>.
</p>
</div>
</div>



<div class="outline-4" id="outline-container-sec:limit:ingredients:raytracing">
<h4 id="sec:limit:ingredients:raytracing"><span class="section-number-4">13.10.6.</span> Raytracing axion image - \(r(x_i, y_i)\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:raytracing">
<p>
The axion image is computed based on a raytracing Monte Carlo
simulation, using TrAXer (<a href="./bibliography.html#citeproc_bib_item_197">Schmidt 2023</a>), written as part of this
thesis. Appendix <a href="./raytracing.html#sec:appendix:raytracing">37</a> contains an introduction to
raytracing techniques, details about the LLNL telescope, verification
of the raytracing results using PANTER measurements of the real
telescope and details about the calculation of the axion image.
</p>

<p>
Fig. <a href="#fig:limit:ingredients:axion_image">5</a> shows the image, computed for
a Sun-Earth distance of \(\SI{0.989}{AU}\) and a distance of
\(\SI{0.2928}{cm}\) behind the detector window. So it is
\(\SI{0.7072}{cm}\) <span class="underline">in front</span> of the focal point. Hence, the image is
very slightly asymmetric along the long axis.
</p>

<p>
Instead of using the raytracing image to fully characterize the axion
flux including efficiency losses, we <i>only</i> use it to define the
spatial distribution <sup>  <a role="doc-backlink" class="footref" id="fnr.11" href="#fn.11">11</a></sup>. This means we rescale the full axion flux
distribution – before taking the window strongback into account – such
that it represents the fractional X-ray flux per square
centimeter. That way, when we multiply it with the rest of the
expression in the signal calculation eq. \eqref{eq:limit_method_signal_si},
the result is the expected number of counts at the given position and
energy per \(\si{cm²}\).
</p>

<p>
The window strongback is not part of the simulation, because for the
position uncertainty, we need to move the axion image without moving
the strongback. As such the strongback is added as part of the limit
calculation based on the physical position on the chip of a given candidate.
</p>


<figure id="fig:limit:ingredients:axion_image">
<img src="./figs/home/basti/phd/Figs/limit/sanity/axion_image_limit_calc_no_theta.svg" class="org-svg" alt="axion_image_limit_calc_no_theta.svg" />

<figcaption>Figure 5: <span class="figure-number">Figure 83: </span>Axion image as computed using raytracing for the AGSS09 <a href="agss09_chemical,agss09_new_solar">agss09_chemical,agss09_new_solar</a> solar model and under the assumption that the axion-electron coupling constant \(g_{ae} = \num{1e-13}\) dominates over the axion-photon coupling \(g_{aγ} = \SI{1e-12}{GeV^{-1}}\). The diagonal lines with missing flux are the detector window strongbacks. It is very slightly asymmetric, because of being \(\SI{0.7}{cm}\) in front of the focal point.</figcaption>
</figure>
</div>

<div class="outline-5" id="outline-container-org803f4a8">
<h5 id="org803f4a8"><span class="section-number-5">13.10.6.1.</span> Generate the axion image plot with strongback   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-10-6-1">
<p>
In the raytracing appendix we only compute the axion image without the
strongback (even though we support placing the strongback into the
simulation).
</p>

<p>
We could either produce the plot based on <code>plotBinary</code>, part of the
TrAXer repository, after running <i>with</i> the strongback in the
simulation, or alternatively as part of the limit calculation sanity
checks. The latter is the cleaner approach, because it directly shows
us the strongback is added correctly in the code where it matters.
</p>

<p>
We produce it by running the <code>sanity</code> subcommand of
<code>mcmc_limit_calculation</code>, in particular the <code>raytracing</code> argument.
Note that we don&apos;t need any input files, the default ones are fine,
because we don&apos;t run any input related sanity checks.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.9 <span style="color: #FD971F;">DEBUG_TEX</span>=true <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
                      mcmc_limit_calculation sanity <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --sanityPath ~/phd/Figs/limit/sanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --raytracing
</pre>
</div>
</div>
</div>
</div>


<div class="outline-4" id="outline-container-sec:limit:ingredients:total_signal">
<h4 id="sec:limit:ingredients:total_signal"><span class="section-number-4">13.10.7.</span> Computing the total signal - \(s_{\text{tot}}\)</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:total_signal">
<p>
As mentioned in sec. <a href="./limit.html#sec:limit:method_computing_L">13.3</a> in principle we
need to integrate the signal function \(s(E, x, y)\) over the entire
chip area and all energies. However, we do not actually need to
perform that integration, because we know the efficiency of our
telescope and detector setup as well as the amount of flux entering
the telescope.
</p>

<p>
Therefore we compute \(s_{\text{tot}}\) via
</p>

<p>
\[
s_{\text{tot}}(g²_{ae}) = ∫_0^{E_{\text{max}}} f(g²_{ae}, E) · A · t · P_{a ↦ γ}(g²_{aγ}) · ε(E) \, \dd E,
\]
</p>

<p>
making use of the fact that the position dependent function \(r(x, y)\)
integrates to \(\num{1}\)  over the entire axion image. This allows us
to precompute the integral and only rescale the result for the current
coupling constant \(g²_{ae}\) via
</p>

<p>
\[
s_{\text{tot}}(g²_{ae}) = s_{\text{tot}}(g²_{ae,\text{ref}}) · \frac{g²_{ae}}{g²_{ae, \text{ref}}},
\]
</p>

<p>
where \(g²_{ae, \text{ref}}\) is the reference coupling constant for which
the integral is computed initially. Similar rescaling needs to be done
for the axion-photon coupling or chameleon coupling, when computing a
limit for either.
</p>
</div>

<div class="outline-5" id="outline-container-org2ed501c">
<h5 id="org2ed501c"><span class="section-number-5">13.10.7.1.</span> Code for the calculation of the total signal   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-10-7-1">
<p>
This is the implementation of the <code>totalSignal</code> in code. We simply
circumvent the integration when calculating limits by precomputing the
integral in the initialization (into <code>integralBase</code>), taking into
account the detection efficiency. From there it is just a
multiplication of magnet bore, tracking time and conversion probability.
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">totalSignal</span><span style="color: #AE81FF;">(</span>ctx: <span style="color: #66D9EF;">Context</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #E6DB74;">## Computes the total signal expected in the detector, by integrating the</span>
  <span style="color: #E6DB74;">## axion flux arriving over the total magnet bore, total tracking time.</span>
  <span style="color: #E6DB74;">##</span>
  <span style="color: #E6DB74;">## The `</span><span style="color: #AE81FF;">integralBase</span><span style="color: #E6DB74;">` is the integral over the axion flux multiplied by the detection</span>
  <span style="color: #E6DB74;">## efficiency (window, gas and telescope).</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">areaBore </span>= π * <span style="color: #AE81FF;">(</span><span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span> * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span><span style="color: #AE81FF;">)</span>.cm²
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">integral </span>= ctx.integralBase.rescale<span style="color: #AE81FF;">(</span>ctx<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = integral.cm⁻²•s⁻¹ * areaBore * ctx.totalTrackingTime.to<span style="color: #AE81FF;">(</span>s<span style="color: #AE81FF;">)</span> * conversionProbability<span style="color: #AE81FF;">(</span>ctx<span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:ingredients:background">
<h4 id="sec:limit:ingredients:background"><span class="section-number-4">13.10.8.</span> Background</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:background">
<p>
The background must be evaluated at the position and energy of each
cluster candidate. As the background is not constant in energy or
position on the chip (see sec. <a href="./background.html#sec:background:all_vetoes_combined">12.6</a>),
we need a continuous description in those dimensions of the background
rate.
</p>

<p>
In order to obtain such a thing, we start from all X-ray like clusters
remaining after background rejection, see for example
fig. <a href="#fig:background:cluster_center_comparison">#fig:background:cluster_center_comparison</a>, and construct a
background interpolation. We define \(b_i\) as a function of candidate
position \(x_i, y_i\) and energy \(E_i\),
</p>

<p>
\[
b_i(x_i, y_i, E_i) = \frac{I(x_i, y_i, E_i)}{W(x_i, y_i, E_i)}.
\]
</p>

<p>
where \(I\) is an intensity defined over clusters within a range \(R\) and
a normalization weight \(W\). From here on we will drop the candidate
suffix \(i\). The arguments will be combined to vectors
</p>

<p>
\[
\mathbf{x} = \vektor{ \vec{x} \\ E } = \vektor{ x \\ y \\ E }.
\] 
</p>

<p>
The intensity \(I\) is given by
</p>

<p>
\[
I(\mathbf{x}) = \sum_{b ∈ \{ \mathcal{D}(\mathbf{x}_b, \mathbf{x}) \leq R \}}\mathcal{M}(\mathbf{x}_b, \mathbf{x})
  = \sum_{b ∈ \{ \mathcal{D}(\mathbf{x}_b, \mathbf{x}) \leq R \} } \exp \left[ -\frac{1}{2} \mathcal{D}² / σ² \right], 
\]
</p>

<p>
where we introduce \(\mathcal{M}\) to refer to a normal
distribution-like measure and \(\mathcal{D}\) to a custom metric (for
clarity without arguments). All background clusters \(\mathbf{x}_b\)
within some &apos;radius&apos; \(R\) contribute to the intensity \(I\), weighted by
their distance to the point of interest \(\mathbf{x}\). The metric is
given by
</p>

\begin{equation*}
\mathcal{D}( \mathbf{x}_1, \mathbf{x}_2) =
\mathcal{D}( (\vec{x}_1, E_1), (\vec{x}_2, E_2)) =
  \begin{cases}
    (\vec{x}_1 - \vec{x}_2)² \text{ if } |E_1 - E_2| \leq R \\
    ∞ \text{ if } (\vec{x}_1 - \vec{x}_2)² &gt; R² \\
    ∞ \text{ if } |E_1 - E_2| &gt; R
  \end{cases}
\end{equation*}

<p>
with \(\vec{x} = \vektor{x \\ y}\).  Note first of all that this
effectively describes a cylinder. Any point inside \(| \vec{x}_1 -
\vec{x}_2 | \leq R\) simply yields a euclidean distance, as long as
their energy is smaller than \(R\). Further note, that the distance is
only dependent on the distance in the x-y plane, <i>not</i> their energy
difference. Finally, this requires rescaling the energy as a common
number \(R\), but in practice the implementation of this custom metric
simply compares energies directly, with the &apos;height&apos; in energy of the
cylinder expressed as \(ΔE\).
</p>

<p>
The commonly used value for the radius \(R\) in the x-y plane are
\(R = \SI{40}{pixel}\) and in energy \(ΔE = ± \SI{0.3}{keV}\). The
standard deviation of the normal distribution for the weighting in the
measure \(σ\) is set to \(\frac{R}{3}\).  The basic idea of the measure is
simply to provide the highest weight to those clusters close to the
point we evaluate and approach 0 at the edge of \(R\) to avoid
discontinuities in the resulting interpolation.
</p>

<p>
Finally, the normalization weight \(W\) is required to convert the sum
of \(I\) into a background rate. It is the &apos;volume&apos; of our measure
within the boundaries set by our metric \(\mathcal{D}\):
</p>

\begin{align*}
W(x&apos;, y&apos;, E&apos;) &amp;= t_B ∫_{E&apos; - E_c}^{E&apos; + E_c} ∫_{\mathcal{D}(\vec{x&apos;}, \vec{x}) \leq R} \mathcal{M}(x&apos;, y&apos;) \, \dd x\, \dd y\, \dd  E \\
  &amp;= t_B ∫_{E&apos; - E_c}^{E&apos; + E_c} ∫_{\mathcal{D}(\vec{x&apos;}, \vec{x}) \leq R} \exp\left[ -\frac{1}{2} \mathcal{D}² / σ² \right] \, \dd x \, \dd y \, \dd  E \\
  &amp;= t_B ∫_{E&apos; - E_c}^{E&apos; + E_c} ∫_0^R ∫_0^{2π} r \exp\left[ -\frac{1}{2} \frac{\mathcal{D}² }{σ²} \right] \, \dd r\, \dd φ\, \dd  E \\
  &amp;= t_B ∫_{E&apos; - E_c}^{E&apos; + E_c} -2 π \left( σ²  \exp\left[ -\frac{1}{2} \frac{R²}{σ^2} \right] - σ² \right) \, \dd E \\
  &amp;= -4 π t_B E_c \left( σ² \exp\left[ -\frac{1}{2} \frac{R²}{σ^2} \right] - σ² \right), \\
\end{align*}

<p>
where we made use of the fact that within the region of interest
\(\mathcal{D}&apos;\) is effectively just a radius \(r\) around the point we
evaluate. \(t_B\) is the total active background data taking time. If
our measure was \(\mathcal{M} = 1\), meaning we would count the
clusters in \(\mathcal{D}(\vec{x}, \vec{x}&apos;) \leq R\), the
normalization \(W\) would simply be the volume of the cylinder.
</p>

<p>
This yields a smooth and continuous interpolation of the background
over the entire chip. However, towards the edges of the chip it
underestimates the background rate, because once part of the cylinder
is not contained within the chip, fewer clusters contribute. For that
reason we correct for the chip edges by upscaling the value within the
chip by the missing area. See appendix <a href="./background_interpolation_chip_area.html#sec:appendix:background_interpolation_chip_area">32</a>.
</p>

<p>
Fig. <a href="#fig:limit:background_interpolation">6</a> shows an example of the background
interpolation centered at \(\SI{3}{keV}\), with all clusters within a
radius of \(\num{40}\) pixels and in an energy range from
\(\SIrange{2.7}{3.3}{keV}\). Fig. <a href="#fig:limit:interpolation_clusters">6(a)</a>
shows the initial step of the interpolation, with all colored points
inside the circle being clusters that are contained in \(\mathcal{D}
\leq R\). Their color represents the weight based on the measure
\(\mathcal{M}\). After normalization and calculation for each point on
the chip, we get the interpolation shown in
fig. <a href="#fig:limit:background_interpolation_example">6(b)</a>.
</p>

<p>
Implementation wise, as the lookup of the closest neighbors in general
is an \(N²\) operation for \(N\) clusters, all clusters are stored in a
\(k\text{-d}\) tree, for fast querying of clusters close to the point to be
evaluated. Furthermore, because the likelihood \(\mathcal{L}\) is
evaluated many times for a given set of candidates to compute a limit,
we perform caching of the background interpolation values for each
candidate. That way we only compute the interpolation once for each
candidate.
</p>


<figure class="figure-wrapper" id="fig:limit:background_interpolation">
<figure class="subfigure" id="fig:limit:interpolation_clusters" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/interpolation_clusters_E_3.0_keV_x_110_y_80.svg" data-width="99%" />  <figcaption>Figure 6(a): Intensity at a point</figcaption></figure> <figure class="subfigure" id="fig:limit:background_interpolation_example" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/normalized_interpolation_at_3.0keV_ymax_5e-05.svg" data-width="99%" />  <figcaption>Figure 6(b): Interpolation</figcaption></figure>
<figcaption>Figure 6: <a href="#fig:limit:interpolation_clusters">6(a)</a>: Calculation of intensity $I$ at the center of the red circle. Black crosses indicate all
          background clusters. The red circle indicates cutoff $R$ in the x-y plane. Only clusters with colored dots inside the circle
          are within $\SIrange{2.70}{3.3}{keV}$. Their color is the weight based on the gaussian measure $\mathcal{M}$. <a href="#fig:limit:background_interpolation_example">6(b)</a>: Example of the resulting background interpolation at $\SI{3}{keV}$ computed over the entire chip. A smooth, correctly normalized interpolation is obtained.</figcaption>
</figure>
</div>



<div class="outline-5" id="outline-container-org018bf5b">
<h5 id="org018bf5b"><span class="section-number-5">13.10.8.1.</span> Generate the interpolation figure   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-10-8-1">
<p>
Sanity check for background interpolation:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">DEBUG_TEX</span>=true <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
                      mcmc_limit_calculation sanity <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --sanityPath ~/phd/Figs/limit/sanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --backgroundInterp
</pre>
</div>
</div>
</div>


<div class="outline-5" id="outline-container-sec:correct_inter_cutoff">
<h5 id="sec:correct_inter_cutoff"><span class="section-number-5">13.10.8.2.</span> <span class="todo STARTED">STARTED</span> Homogeneous background for energies &gt; 2 keV <code>[/]</code>   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-sec:correct_inter_cutoff">
<ul class="org-ul">
<li class="off"><code>[ ]</code> finish the final explanation part!!</li>
<li class="off"><code>[ ]</code> Remove nowadays understood aspects of below!</li>
</ul>


<p>
The issue with energies larger than 2 keV and performing the
interpolation of all events larger than 2 in a reasonably large
radius, has one specific problem.
</p>

<p>
The plot in fig. <a href="#fig:background_interpolation_larger_2keV">7</a> shows what
the interpolation for &gt; 2 keV looks like for a radius of 80 pixels.
</p>

<p>
It is very evident that the background <b>appears</b> higher in the center
area than in the edges / corners of the chip.
</p>

<p>
The reason for this is pretty obvious once one thinks about it
deeper. Namely, an event with a significant energy that went through
decent amounts of diffusion, cannot have its cluster center (given
that it&apos;s X-ray like here) actually close to the edge / corner of the
detector. On average its center will be half the diffusion radius
<b>away</b> from the edges. If we then interpolate based on the cluster
center information, we end up at a typical boundary problem, i.e. they
are underrepresented.
</p>


<figure id="fig:background_interpolation_larger_2keV">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/background_interp_larger_2keV_radius_80.svg" class="org-svg" alt="background_interp_larger_2keV_radius_80.svg" />

<figcaption>Figure 7: <span class="figure-number">Figure 84: </span>Background interpolation for 2017/18 X-ray like data for all clusters above \SI{2}{keV} using a radius of 80 pixels. It is evident that the background in the center appears higher than at the edges, despite expecting either the opposite or constant background. Reason is cutoff at edges, so no contributions can come from outside + diffusion causing cluster centers to always be a distance away from the edges.</figcaption>
</figure>

<p>
Now, what is a good solution for this problem?
</p>

<p>
In principle we can just say &quot;background is constant over the chip at
this energy above 2 keV&quot; and neglect the whole interpolation here,
i.e. set it constant.
</p>

<p>
If we wish to keep an interpolation around, we will have to modify the
data that we use to create the actual 2D interpolator.
</p>

<p>
Of course the same issue is present in the &lt; 2 keV dataset to an
extent. The question there is: does it matter? Essentially, the
statement about having <b>less</b> background there is factually true. But
only to the extent of diffusion putting the centers away from the
edges, <b>not</b> from just picking up nothing from the area within the
search radius that lies outside the chip (where thus no data can be
found).
</p>

<p>
Ideally, we correct for this by scaling all points that contain data
outside the chip by the fraction of area that is within the radius
divided by the total area. That way we pretend that there is an
&apos;equal&apos; amount of background found in this area in the full radius
around the point.
</p>

<p>
How?
</p>

<p>
Trigonometry for that isn&apos;t fully trivial, but also not super hard.
</p>

<p>
Keep in mind the area of a <a href="https://en.wikipedia.org/wiki/Circular_segment">circle segment</a>:
\[
A = r² / 2 * (ϑ - sin(ϑ))
\]
where \(r\) is the radius of the circle and ϑ the angle that cuts off
the circle.
</p>

<p>
However, in the general case we need to know the area of a circle that
is cut off from 2 sides. By subtracting the corresponding areas of
circle segments for each of the lines that cut something off, we
remove too much. So we need to add back:
</p>
<ul class="org-ul">
<li>another circle segment, of the angle between the two angles given by
the twice counted area</li>
<li>the area of the triangle with the two sides given by \(R - r&apos;\) in
length, where \(r&apos;\) is the distance that is cut off from the circle.</li>
</ul>

<p>
In combination the area remaining for a circle cut off from two
(orthogonal, fortunately) lines is:
</p>

<p>
\[
E = F - A - B + C + D
\]
where:
</p>
<ul class="org-ul">
<li>\(F\): the total area of the circle</li>
<li>\(A\): the area of the first circle segment</li>
<li>\(B\): the area of the second circle segment</li>
<li>\(C\): the area of the triangle built by the two line cutoffs:
\[
  C = \frac{r&apos; r&apos;&apos;}{2} 
  \]
with \(r&apos;\) as defined above for cutoff A and \(r&apos;&apos;\) for cutoff B.</li>
<li>\(D\): the area of the circle segment given by the angles between the
two cutoff lines touching the circle edge:
\[
  D = r² / 2 * (α - sin(α))
  \]
where \(α\) is:
\[
  α = π/2 - ϑ_1 - ϑ_2
  \]
where \(ϑ_{1,2}\) are the related to the angles \(ϑ\) needed to compute
each circle segment, by:
\[
  ϑ&apos; = (π - ϑ) / 2
  \]
denoted as \(ϑ&apos;\) here.</li>
</ul>

<p>
Implemented this as a prototype in:
<a href="./../org/Misc/circle_segments.nim">./../org/Misc/circle_segments.nim</a>
<b>UPDATE</b>: <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-03-01 Wed 18:02&gt; </span></span> which now also lives in TPA in the
<code>NimUtil/helpers</code> directory!
</p>

<p>
Next step: incorporate this into the interpolation to re-weight the
interpolation near the corners.
</p>
</div>
</div>

<div class="outline-5" id="outline-container-sec:limit:gaussian_weight_normalization">
<h5 id="sec:limit:gaussian_weight_normalization"><span class="section-number-5">13.10.8.3.</span> Normalization of gaussian weighted k-d tree background interpolation   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-sec:limit:gaussian_weight_normalization">
<p>
The background interpolation described above includes multiple steps
required to finalize it.
</p>

<p>
As mentioned, we start by building a k-d tree on the data using a
custom metric:
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">distance</span><span style="color: #AE81FF;">(</span>metric: <span style="color: #66D9EF;">typedesc</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">CustomMetric</span><span style="color: #66D9EF;">]</span>, v, w: <span style="color: #66D9EF;">Tensor</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">doAssert</span> v.squeeze.rank == <span style="font-style: italic;">1</span>
  <span style="color: #F92672;">doAssert</span> w.squeeze.rank == <span style="font-style: italic;">1</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xyDist </span>= pow<span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span>v<span style="color: #A6E22E;">[</span><span style="font-style: italic;">0</span><span style="color: #A6E22E;">]</span> - w<span style="color: #A6E22E;">[</span><span style="font-style: italic;">0</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> + pow<span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span>v<span style="color: #A6E22E;">[</span><span style="font-style: italic;">1</span><span style="color: #A6E22E;">]</span> - w<span style="color: #A6E22E;">[</span><span style="font-style: italic;">1</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">zDist </span>= pow<span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span>v<span style="color: #A6E22E;">[</span><span style="font-style: italic;">2</span><span style="color: #A6E22E;">]</span> - w<span style="color: #A6E22E;">[</span><span style="font-style: italic;">2</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> zDist &lt;= <span style="color: #66D9EF;">Radius</span> * <span style="color: #66D9EF;">Radius</span>:
    <span style="color: #FD971F;">result</span> = xyDist
  <span style="color: #F92672;">else</span>:
    <span style="color: #FD971F;">result</span> = zDist
  <span style="color: #75715E;">#</span><span style="color: #75715E;">if xyDist &gt; zDist:</span>
  <span style="color: #75715E;">#  </span><span style="color: #75715E;">result = xyDist</span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">elif xyDist &lt; zDist and zDist &lt;= Radius:</span>
  <span style="color: #75715E;">#  </span><span style="color: #75715E;">result = xyDist</span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">else:</span>
  <span style="color: #75715E;">#  </span><span style="color: #75715E;">result = zDist</span>
</pre>
</div>
<p>
or in pure math:
</p>

<p>
Let \(R\) be a cutoff value.
</p>
\begin{equation}
\mathcal{D}( (\vec{x}_1, E_1), (\vec{x}_2, E_2)) =
  \begin{cases}
    (\vec{x}_1 - \vec{x}_2)² \text{ if } |E_1 - E_2| \leq R \\
    |E_1 - E_2|
  \end{cases}
\end{equation}
<p>
where we make sure to scale the energies such that a value for the
radius in Euclidean space of the x / y geometry covers the same range
as it does in energy.
</p>

<p>
This creates essentially a cylinder. In words it means we use the
distance in x and y as the actual distance, unless the distance in
energy is larger than the allowed cutoff, in which case we return it.
</p>

<p>
This simply assures that:
</p>
<ul class="org-ul">
<li>if two clusters are close in energy, but further in Euclidean
distance than the allowed cutoff, they will be removed later</li>
<li>if two clusters are too far away in energy they will be removed,
despite possibly being close in x/y</li>
<li>otherwise the distance in energy is <b>irrelevant</b>.</li>
</ul>

<p>
The next step is to compute the actual background value associated with each \((x,
y, E)\) point.
</p>

<p>
In the most naive approach (as presented in the first few plots in the
section above), we can associate to each point the number of clusters
found within a certain radius (including or excluding the energy
dimension).
</p>

<p>
For obvious reasons treating each point independent of the distance
as a single count (pure nearest neighbor) is problematic, as the
distance matters of course.
Thus, our choice is a weighted nearest neighbor. Indeed, we weigh the
distance by normal distribution centered around the location at which
we want to compute the background.
</p>

<p>
So, in code our total weight for an individual point is:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">template</span> <span style="color: #A6E22E;">compValue</span><span style="color: #AE81FF;">(</span>tup: <span style="color: #66D9EF;">untyped</span>, byCount = <span style="color: #AE81FF;">false</span>, energyConst = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">untyped</span> =
  <span style="color: #F92672;">if</span> byCount:
    tup.idx.size.<span style="color: #66D9EF;">float</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">for the pure nearest neighbor case</span>
  <span style="color: #F92672;">else</span>:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">weigh by distance using gaussian of radius being 3 sigma</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">val </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
    <span style="color: #F92672;">for</span> d <span style="color: #F92672;">in</span> <span style="color: #F92672;">items</span><span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>:
      <span style="color: #75715E;"># </span><span style="color: #75715E;">default, gaussian an energy</span>
      val += smath.gauss<span style="color: #AE81FF;">(</span>d, mean = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, sigma = radius / <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
    val
</pre>
</div>
<p>
where <code>tup</code> contains the distances to all neighbors found within the
desired radius.
</p>

<p>
In math this means we first modify our distance measure \(\mathcal{D}\)
from above to:
</p>
\begin{equation}
\mathcal{D&apos;}( (\vec{x}_1, E_1), (\vec{x}_2, E_2)) =
  \begin{cases}
    (\vec{x}_1 - \vec{x}_2)² \text{ if } |E_1 - E_2| \leq R \\
    0 \text{ if } (\vec{x}_1 - \vec{x}_2)² &gt; R² \\
    0 \text{ if } |E_1 - E_2| &gt; R
  \end{cases}
\end{equation}
<p>
to incorporate the nearest neighbor properties of dropping everything
outside of the radius either in x/y or in (scaled) energy.
</p>

\begin{align*}
I(\vec{x}_e, E_e) &amp;= Σ_i \exp \left[ -\frac{1}{2} \left( \mathcal{D&apos;}((\vec{x}_e, E_e), (\vec{x}_i, E_i)) \right)² / σ² \right] \\
I(\vec{x}_e, E_e) &amp;= Σ_i \exp \left[ -\frac{1}{2} \mathcal{D}^{&apos;2} / σ² \right] \text{ for clarity w/o arguments} \\
I(\vec{x}_e, E_e) &amp;= Σ_i \mathcal{M}(\vec{x}_i, E_i) 
\end{align*}
<p>
where we introduce \(\mathcal{M}\) to refer to the measure we use and
<code>i</code> runs over all clusters (\(\mathcal{D&apos;}\) takes care of only allowing
points in the radius to contribute) and the subscript <code>e</code> stands for
the evaluation point. \(σ\) is the sigma of the (non-normalized!)
Gaussian distribution for the weights, which is set to \(σ =
\frac{R}{3}\).
</p>

<p>
This gives us a valid interpolated value for each possible value of
position and energy pairs. However, these are still not normalized,
nor corrected for the cutoff of the radius once it&apos;s not fully &quot;on&quot;
the chip anymore. The normalization is done via the area of circle
segments, as described in the previous section
<a href="./limit.html#sec:correct_inter_cutoff">13.10.8.2</a>.
</p>

<p>
The normalization will be described next.
For the case of unweighted points (taking every cluster in the
&apos;cylinder&apos;), it would simply be done by dividing by the:
</p>
<ul class="org-ul">
<li>background data taking time</li>
<li>energy range of interest</li>
<li>  <b>volume of the cylinder</b></li>
</ul>

<p>
But for a weighted distance measure \(\mathcal{D&apos;}\), we need to perform the
integration over the measure (which we do implicitly for the
non-weighted case by taking the area! Each point simply contributes
with 1, resulting in the area of the circle).
</p>

<p>
The necessary integration over the energy can be reduced to simply
dividing by the energy range (the &apos;cylinder height&apos; part if one will),
as everything is constant in the energy direction, i.e. no weighting
in that axis.
</p>

<p>
Let&apos;s look at what happens in the trivial case for an understanding of
what we are actually doing when normalizing by area of a non-weighted thing.
</p>

<p>
The measure in the unweighted case is thus:
\[
\mathcal{M}(x, y) = 1
\]
</p>

<p>
Now, we need to integrate this measure over the region of interest
around a point (i.e from a point x over the full radius that  we
consider):
</p>

\begin{align*}
W &amp;= \int_{x² + y² &lt; R²} \mathcal{M}(x&apos;, y&apos;)\, \mathrm{d}x \mathrm{d}y \\
 &amp;= \int_{x² + y² &lt; R²} 1\, \mathrm{d}x \mathrm{d}y \\
 &amp;= \int_0^R \int_0^{2 π} r\, \mathrm{d}r \mathrm{d}φ \\
 &amp;= \int_0^{2 π} \frac{1}{2} R² \, \mathrm{d}φ \\
 &amp;= 2 π\frac{1}{2} R² \\
 &amp;= π R²
\end{align*}
<p>
where the additional \(r\) after transformation from cartesian
coordinates to polar coordinates is from the Jacobi determinant (ref:
<a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant#Example_2:_polar-Cartesian_transformation">https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant#Example_2:_polar-Cartesian_transformation</a>
as a reminder). For this reason it is important that we start our
assumption in cartesian coordinates, as otherwise we miss out that
crucial factor!
Unexpectedly, the result is simply the area of a circle with radius
\(R\), as we intuitively assumed to be for a trivial measure.
</p>

<p>
For our actual measure we use:
\[
\mathcal{M}(\vec{x}_i, E_i) = \exp \left[ - \frac{1}{2} \mathcal{D}^{&apos;2}((\vec{x}_e, E_e), (\vec{x}_i, E_i)) / σ² \right]
\]
the procedure follows in the exact same fashion (we leave out the
arguments to \(\mathcal{D}\) in the further part:
</p>
\begin{align*}
W &amp;= \int_{x² + y² &lt; R²} \mathcal{M}(x&apos;, y&apos;)\, \mathrm{d}x \mathrm{d}y \\
 &amp;= \int_{x² + y² &lt; R²} \exp \left[ - \frac{1}{2} \mathcal{D}^{&apos;2} / σ² \right] \, \mathrm{d}x \mathrm{d}y \\
 &amp;= \int_0^R \int_0^{2 π} r \exp \left[ - \frac{1}{2} \mathcal{D}^{&apos;2} / σ² \right]\, \mathrm{d}r \mathrm{d}φ 
\end{align*}
<p>
which can be integrated using standard procedures or just using
SageMath, …:
</p>

<div class="org-src-container">
<pre class="src src-sage">sage: r = var(&apos;r&apos;) # for radial variable we integrate over
sage: σ = var(&apos;σ&apos;) # for constant sigma
sage: φ = var(&apos;φ&apos;) # for angle variable we integrate over
sage: R = var(&apos;R&apos;) # for the radius to which we integrate
sage: assume(R &gt; 0) # required for sensible integration
sage: f = exp(-r ** 2 / (sqrt(2) * σ) ** 2) * r 
sage: result = integrate(integrate(f, r, 0, R), φ, 0, 2 * pi)
sage: result
-2*pi*(σ^2*e^(-1/2*R^2/σ^2) - σ^2)
sage: result(R = 100, σ = 33.33333).n()
6903.76027055093
</pre>
</div>

<p>
The final normalization in code:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">normalizeValue*</span><span style="color: #AE81FF;">(</span>x, radius: <span style="color: #66D9EF;">float</span>, energyRange: keV, backgroundTime: <span style="color: #66D9EF;">Hour</span><span style="color: #AE81FF;">)</span>: keV⁻¹•cm⁻²•s⁻¹ =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pixelSizeRatio </span>= <span style="font-style: italic;">65536</span> / <span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span> * <span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span><span style="color: #AE81FF;">)</span>.cm²
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">σ </span>= <span style="color: #66D9EF;">Sigma</span>
  <span style="color: #E6DB74;">## This comes for integration with `</span><span style="color: #AE81FF;">sagemath</span><span style="color: #E6DB74;">` over the gaussian weighting. See the notes.</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">area </span>= -<span style="font-style: italic;">2</span>*π*<span style="color: #AE81FF;">(</span>σ*σ * exp<span style="color: #66D9EF;">(</span>-<span style="font-style: italic;">1</span>/<span style="font-style: italic;">2</span> * radius*radius / <span style="color: #A6E22E;">(</span>σ*σ<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> - <span style="color: #66D9EF;">(</span>σ*σ<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">energyRange </span>= energyRange * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">we look at (factor 2 for radius)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">factor </span>= area / pixelSizeRatio * <span style="color: #75715E;"># </span><span style="color: #75715E;">area in cm²</span>
    energyRange *
    backgroundTime.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Second</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = x / factor
</pre>
</div>
</div>
</div>


<div class="outline-5" id="outline-container-sec:background_interpolation_uncertainty">
<h5 id="sec:background_interpolation_uncertainty"><span class="section-number-5">13.10.8.4.</span> Error propagation of background interpolation   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-sec:background_interpolation_uncertainty">
<p>
For obvious reasons the background interpolation suffers from
statistical uncertainties. Ideally, we compute the resulting error
from the statistical uncertainty for the points by propagating the
errors through the whole computation. That is from the nearest
neighbor lookup, through the sum of the weighted distance calculation
and then the normalization.
</p>

<p>
We&apos;ll use <a href="https://github.com/SciNim/Measuremancer">https://github.com/SciNim/Measuremancer</a>.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> datamancer, measuremancer, unchained, seqmath
</pre>
</div>
<p>
Start by importing some data taken from running the main
program. These are the distances at some energy at pixel (127, 127) to
the nearest neighbors.
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">data </span>= <span style="color: #E6DB74;">&quot;&quot;&quot;</span>
<span style="color: #E6DB74;">dists</span>
<span style="color: #E6DB74;">32.14</span>
<span style="color: #E6DB74;">31.89</span>
<span style="color: #E6DB74;">29.41</span>
<span style="color: #E6DB74;">29.12</span>
<span style="color: #E6DB74;">27.86</span>
<span style="color: #E6DB74;">21.38</span>
<span style="color: #E6DB74;">16.16</span>
<span style="color: #E6DB74;">16.03</span>
<span style="color: #E6DB74;">&quot;&quot;&quot;</span>
</pre>
</div>
<p>
Parse and look at it:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= parseCsvString<span style="color: #AE81FF;">(</span>data<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> df
</pre>
</div>

<p>
Now import the required transformations of the code, straight from the limit code
(we will remove all unnecessary bits). First get the radius and sigma
that we used here:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Radius</span> = <span style="font-style: italic;">33</span>.<span style="font-style: italic;">3</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">Sigma</span> = <span style="color: #66D9EF;">Radius</span> / <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">EnergyRange</span> = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">3</span>.keV
</pre>
</div>
<p>
and now the functions:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">template</span> <span style="color: #A6E22E;">compValue</span><span style="color: #AE81FF;">(</span>tup: <span style="color: #66D9EF;">untyped</span>, byCount = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">untyped</span> =
  <span style="color: #F92672;">if</span> byCount:
    tup.size.<span style="color: #66D9EF;">float</span>
  <span style="color: #F92672;">else</span>:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">weigh by distance using gaussian of radius being 3 sigma</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= tup <span style="color: #75715E;"># </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">NOTE:</span><span style="color: #75715E;">` not a tuple here anymore</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">val </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
    <span style="color: #F92672;">for</span> d <span style="color: #F92672;">in</span> <span style="color: #F92672;">items</span><span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>:
      val += smath.gauss<span style="color: #AE81FF;">(</span>d, mean = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, sigma = <span style="color: #66D9EF;">Sigma</span><span style="color: #AE81FF;">)</span>
    val

defUnit<span style="color: #AE81FF;">(</span>cm²<span style="color: #AE81FF;">)</span>    
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">normalizeValue*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>x: <span style="color: #66D9EF;">T</span>, radius, σ: <span style="color: #66D9EF;">float</span>, energyRange: keV, byCount = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">auto</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pixelSizeRatio </span>= <span style="font-style: italic;">65536</span> / <span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span> * <span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span><span style="color: #AE81FF;">)</span>.cm²
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">area</span>: <span style="color: #66D9EF;">float</span>
  <span style="color: #F92672;">if</span> byCount:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">case for regular circle with weights 1</span>
    area = π * radius * radius <span style="color: #75715E;"># </span><span style="color: #75715E;">area in pixel</span>
  <span style="color: #F92672;">else</span>:
    area = -<span style="font-style: italic;">2</span>*<span style="color: #66D9EF;">Pi</span>*<span style="color: #AE81FF;">(</span>σ*σ * exp<span style="color: #66D9EF;">(</span>-<span style="font-style: italic;">1</span>/<span style="font-style: italic;">2</span> * radius*radius / <span style="color: #A6E22E;">(</span>σ*σ<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> - <span style="color: #66D9EF;">(</span>σ*σ<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">energyRange </span>= energyRange * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #75715E;">#</span><span style="color: #75715E;">radius / 6.0 / 256.0 * 12.0 * 2.0 # fraction of full 12 keV range</span>
                                                <span style="color: #75715E;"># </span><span style="color: #75715E;">we look at (factor 2 for radius)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">backgroundTime </span>= <span style="font-style: italic;">3300</span>.h.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Second</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">factor </span>= area / pixelSizeRatio * <span style="color: #75715E;"># </span><span style="color: #75715E;">area in cm²</span>
    energyRange *
    backgroundTime
  <span style="color: #FD971F;">result</span> = x / factor
</pre>
</div>
<p>
<code>compValue</code> computes the weighted (or unweighted) distance measure and
<code>normalizeValue</code> computes the correct normalization based on the
radius. The associated area is obtained using the integration shown in
the previous section (using sagemath).
</p>

<p>
Let&apos;s check if we can run the computation and see what we get
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;dists&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Weighted value : &quot;</span>, compValue<span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Normalized value : &quot;</span>, compValue<span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>.normalizeValue<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Radius</span>, <span style="color: #66D9EF;">Sigma</span>, <span style="color: #66D9EF;">EnergyRange</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
values that seem reasonable.
</p>

<p>
To compute the associated errors, we need to promote the functions we
use above to work with <code>Measurement[T]</code> objects. <code>normalizeValue</code> we
can just make generic (DONE). For <code>compValue</code> we still need a Gaussian
implementation (note: we don&apos;t have errors associated with \(μ\) and \(σ\)
for now. We might add that.).
</p>

<p>
The logic for the error calculation / getting an uncertainty from the
set of clusters in the search radius is somewhat subtle.
</p>

<p>
Consider the unweighted case: If we have \(N\) clusters, we associate an
uncertainty to these number of clusters to \(ΔN = √N\). Why is that?
Because:
\[
N = Σ_i (1 ± 1) =: f
\]
leads to precisely that result using linear error propagation! Each
value has an uncertainty of \(√1\). Computing the uncertainty of a
single value just yields \(√((∂(N)/∂N)² ΔN²) = ΔN\). Doing the same of
the <b>sum</b> of elements, just means 
\[
ΔN =  √( Σ_i (∂f/∂N_i)²(ΔN_i)² ) = √( Σ_i 1² ) = √N
\]
precisely what we expect.
</p>

<p>
We can then just treat the gaussian in the same way, namely:
\[
f = Σ_i (1 ± 1) * \text{gauss}(\vec{x} - \vec{x_i}, μ = 0, σ)
\]
and transform it the same way. This has the effect that points that
are further away contribute less than those closer!
</p>

<p>
This is implemented here (thanks to <code>Measuremancer</code>, damn):
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">gauss*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>x: <span style="color: #66D9EF;">T</span>, μ, σ: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">T</span> =
  <span style="color: #F92672;">let</span>
    arg = <span style="color: #AE81FF;">(</span>x - μ<span style="color: #AE81FF;">)</span> / σ
    res = exp<span style="color: #AE81FF;">(</span>-<span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span> * arg * arg<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = res

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">compMeasureValue*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>tup: <span style="color: #66D9EF;">Tensor</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">]</span>, σ: <span style="color: #66D9EF;">float</span>, byCount: <span style="color: #66D9EF;">bool</span> = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">auto</span> =
  <span style="color: #F92672;">if</span> byCount:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= tup <span style="color: #75715E;"># </span><span style="color: #75715E;">only a tuple in real interp code</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">num </span>= tup.size.<span style="color: #66D9EF;">float</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">val </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span> ± <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
    <span style="color: #F92672;">for</span> d <span style="color: #F92672;">in</span> <span style="color: #F92672;">items</span><span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>:
      val = val + <span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> ± <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> * <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">last * 1.0 represents the weight that is one !this holds!</span>
    <span style="color: #F92672;">doAssert</span> val == <span style="color: #AE81FF;">(</span>num ± sqrt<span style="color: #66D9EF;">(</span>num<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">sanity check that our math works out</span>
    val
  <span style="color: #F92672;">else</span>:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">weigh by distance using gaussian of radius being 3 sigma</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= tup <span style="color: #75715E;"># </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">NOTE:</span><span style="color: #75715E;">` not a tuple here anymore</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">val </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span> ± <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
    <span style="color: #F92672;">for</span> d <span style="color: #F92672;">in</span> <span style="color: #F92672;">items</span><span style="color: #AE81FF;">(</span>dists<span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">gv </span>= <span style="color: #AE81FF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> ± <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> * gauss<span style="color: #AE81FF;">(</span>d, μ = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, σ = σ<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">equivalent to unweighted but with gaussian weights</span>
      val = val + gv
    val
</pre>
</div>

<p>
Time to take our data and plug it into the two procedures:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dists </span>= df<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;dists&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Weighted values (byCount) : &quot;</span>, compMeasureValue<span style="color: #AE81FF;">(</span>dists, σ = <span style="color: #66D9EF;">Sigma</span>, byCount = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Normalized value (byCount) : &quot;</span>, compMeasureValue<span style="color: #AE81FF;">(</span>dists, σ = <span style="color: #66D9EF;">Sigma</span>, byCount = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
    .normalizeValue<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Radius</span>, <span style="color: #66D9EF;">Sigma</span>, <span style="color: #66D9EF;">EnergyRange</span>, byCount = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Weighted values (gauss) : &quot;</span>, compMeasureValue<span style="color: #AE81FF;">(</span>dists, σ = <span style="color: #66D9EF;">Sigma</span>, byCount = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Normalized value (gauss) : &quot;</span>, compMeasureValue<span style="color: #AE81FF;">(</span>dists, σ = <span style="color: #66D9EF;">Sigma</span>, byCount = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
    .normalizeValue<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Radius</span>, <span style="color: #66D9EF;">Sigma</span>, <span style="color: #66D9EF;">EnergyRange</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
The result mostly makes sense: Namely, in the case of the gaussian, we
essentially have &quot;less&quot; statistics, because we weigh the events
further away less. The result is a larger error on the weighted case
with less statistics.
</p>

<p>
<b>Note:</b> In this particular case the computed background rate is
significantly lower (but almost within 1σ!) than in the non weighted
case. This is expected and also essentially proving the correctness of
the uncertainty. The distances of the points in the input data is
simply quite far away for all values.
</p>
</div>

<ol class="org-ol">
<li><a id="org078a5a1"> </a>Random sampling to simulate background uncertainty<br />
<div class="outline-text-6" id="text-13-10-8-4-1">
<p>
We&apos;ll do a simple Monte Carlo experiment to assess the uncertainties
from a statistical point of view and compare with the results obtained
in the section above.
</p>

<p>
First do the sampling of backgrounds part:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>random, math, strformat, strutils<span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">const</span> <span style="color: #FD971F;">outDir </span>= <span style="color: #E6DB74;">&quot;/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty&quot;</span>

<span style="color: #F92672;">import</span> ./sampling_helpers
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">sampleBackgroundClusters</span><span style="color: #AE81FF;">(</span>rng: <span style="color: #F92672;">var</span> <span style="color: #66D9EF;">Rand</span>, num: <span style="color: #66D9EF;">int</span>,
                              sampleFn: <span style="color: #66D9EF;">(</span><span style="color: #F92672;">proc</span><span style="color: #A6E22E;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>: <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>
                             <span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #F92672;">tuple</span><span style="color: #66D9EF;">[</span>x, y: <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #E6DB74;">## Samples a number `</span><span style="color: #AE81FF;">num</span><span style="color: #E6DB74;">` of background clusters distributed over the whole chip.</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #F92672;">tuple</span><span style="color: #66D9EF;">[</span>x, y: <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">](</span>num<span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">sample in `</span><span style="color: #AE81FF;">y</span><span style="color: #75715E;">` from function</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ySamples </span>= sampleFrom<span style="color: #AE81FF;">(</span>sampleFn, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">255</span>.<span style="font-style: italic;">0</span>, num<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; num:
    <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = <span style="color: #AE81FF;">(</span>x: rng.rand<span style="color: #66D9EF;">(</span><span style="font-style: italic;">255</span><span style="color: #66D9EF;">)</span>,
                 y: ySamples<span style="color: #66D9EF;">[</span>i<span style="color: #66D9EF;">]</span>.round.<span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">import</span> ggplotnim, sequtils
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotClusters</span><span style="color: #AE81FF;">(</span>s: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #F92672;">tuple</span><span style="color: #A6E22E;">[</span>x, y: <span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">]</span>, suffix: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;x&quot;</span> : s.mapIt<span style="color: #A6E22E;">(</span>it.x<span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;y&quot;</span> : s.mapIt<span style="color: #A6E22E;">(</span>it.y<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">outname </span>= &amp;<span style="color: #E6DB74;">&quot;{outDir}/clusters{suffix}.pdf&quot;</span>
  ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;x&quot;</span>, <span style="color: #E6DB74;">&quot;y&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_point<span style="color: #AE81FF;">(</span>size = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Sampling bias: {suffix}. Num clusters: {s.len}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>outname<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">import</span> unchained
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeNumClusters</span><span style="color: #AE81FF;">(</span>backgroundRate: keV⁻¹•cm⁻²•s⁻¹, energyRange: keV<span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #E6DB74;">## computes the number of clusters we need to simulate a certain background level</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">goldArea </span>= <span style="font-style: italic;">5</span>.mm * <span style="font-style: italic;">5</span>.mm
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">area </span>= <span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span>.cm * <span style="font-style: italic;">1</span>.<span style="font-style: italic;">4</span>.cm
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">time </span>= <span style="font-style: italic;">3300</span>.h
  <span style="color: #75715E;"># </span><span style="color: #75715E;">let clusters = 10000 # about 10000 clusters in total chip background</span>
  <span style="color: #FD971F;">result</span> = backgroundRate * area * time.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Second</span><span style="color: #AE81FF;">)</span> * energyRange

<span style="color: #F92672;">import</span> arraymancer, measuremancer
<span style="color: #F92672;">import</span> ./background_interpolation_error_propagation


<span style="color: #F92672;">import</span> numericalnim
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">compClusters</span><span style="color: #AE81FF;">(</span>fn: <span style="color: #66D9EF;">(</span><span style="color: #F92672;">proc</span><span style="color: #A6E22E;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>: <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>, numClusters: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">hFn</span><span style="color: #AE81FF;">(</span>x: <span style="color: #66D9EF;">float</span>, ctx: <span style="color: #66D9EF;">NumContext</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
    <span style="color: #AE81FF;">(</span>numClusters / <span style="color: #66D9EF;">(</span><span style="font-style: italic;">256</span>.<span style="font-style: italic;">0</span> * fn<span style="color: #A6E22E;">(</span><span style="font-style: italic;">127</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> * fn<span style="color: #AE81FF;">(</span>x<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = simpson<span style="color: #AE81FF;">(</span>hfn, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">256</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">doAssert</span> almostEqual<span style="color: #AE81FF;">(</span>hFn<span style="color: #66D9EF;">(</span><span style="font-style: italic;">127</span>.<span style="font-style: italic;">0</span>, newNumContext<span style="color: #A6E22E;">[</span><span style="color: #66D9EF;">float</span>, <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">]()</span><span style="color: #66D9EF;">)</span>, numClusters / <span style="font-style: italic;">256</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeToy</span><span style="color: #AE81FF;">(</span>rng: <span style="color: #F92672;">var</span> <span style="color: #66D9EF;">Rand</span>, numClusters: <span style="color: #66D9EF;">int</span>, radius, σ: <span style="color: #66D9EF;">float</span>, energyRange: keV,
                sampleFn: <span style="color: #66D9EF;">(</span><span style="color: #F92672;">proc</span><span style="color: #A6E22E;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>: <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>,
                correctNumClusters = <span style="color: #AE81FF;">false</span>,
                verbose = <span style="color: #AE81FF;">false</span>, suffix = <span style="color: #E6DB74;">&quot;&quot;</span><span style="color: #AE81FF;">)</span>: <span style="color: #F92672;">tuple</span><span style="color: #AE81FF;">[</span>m: <span style="color: #66D9EF;">Measurement</span><span style="color: #66D9EF;">[</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #66D9EF;">]</span>,
                                                     num: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">numClusters </span>= numClusters
  <span style="color: #F92672;">if</span> correctNumClusters:
    numClusters = compClusters<span style="color: #AE81FF;">(</span>sampleFn, numClusters<span style="color: #AE81FF;">)</span>.round.<span style="color: #66D9EF;">int</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">clusters </span>= rng.sampleBackgroundClusters<span style="color: #AE81FF;">(</span>numClusters.<span style="color: #66D9EF;">int</span>, sampleFn<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> verbose:
    plotClusters<span style="color: #AE81FF;">(</span>clusters, suffix<span style="color: #AE81FF;">)</span>

  <span style="color: #75715E;"># </span><span style="color: #75715E;">generate a kd tree based on the data</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">tTree </span>= stack<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span>clusters.mapIt<span style="color: #A6E22E;">(</span>it.x.<span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>.toTensor,
                     clusters.mapIt<span style="color: #A6E22E;">(</span>it.y.<span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>.toTensor<span style="color: #66D9EF;">]</span>, axis = <span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">kd </span>= kdTree<span style="color: #AE81FF;">(</span>tTree, leafSize = <span style="font-style: italic;">16</span>, balancedTree = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">tup </span>= kd.queryBallPoint<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="font-style: italic;">127</span>.<span style="color: #66D9EF;">float</span>, <span style="font-style: italic;">127</span>.<span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toTensor, radius<span style="color: #AE81FF;">)</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">m </span>= compMeasureValue<span style="color: #AE81FF;">(</span>tup<span style="color: #66D9EF;">[</span><span style="font-style: italic;">0</span><span style="color: #66D9EF;">]</span>, σ = radius / <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span>, byCount = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
      .normalizeValue<span style="color: #AE81FF;">(</span>radius, σ, energyRange<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">num </span>= tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span>
  <span style="color: #F92672;">if</span> verbose:
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Normalized value (gauss) : &quot;</span>, m, <span style="color: #E6DB74;">&quot; based on &quot;</span>, num, <span style="color: #E6DB74;">&quot; clusters in radius&quot;</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>m: m, num: num<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">radius </span>= <span style="font-style: italic;">33</span>.<span style="font-style: italic;">3</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">σ </span>= radius / <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span>      
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">energyRange </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">3</span>.keV
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">num </span>= computeNumClusters<span style="color: #AE81FF;">(</span>5e-<span style="font-style: italic;">6</span>.keV⁻¹•cm⁻²•s⁻¹, energyRange * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>.round.<span style="color: #66D9EF;">int</span>

<span style="color: #F92672;">var</span> <span style="color: #FD971F;">rng </span>= initRand<span style="color: #AE81FF;">(</span><span style="font-style: italic;">1337</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">import</span> sugar
<span style="color: #75715E;"># </span><span style="color: #75715E;">first look at / generate some clusters to see sampling works</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span>num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_constant_gold_region_rate&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">should be the same number of clusters!</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span>num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>,
                       correctNumClusters = <span style="color: #AE81FF;">true</span>,
                       verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_constant_gold_region_rate_corrected&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">now again with more statistics</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_constant&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">should be the same number of clusters!</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>,
                       correctNumClusters = <span style="color: #AE81FF;">true</span>,
                       verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_constant_corrected&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">linear</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; x<span style="color: #66D9EF;">)</span>, verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_linear&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">should be the same number of clusters!</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; x<span style="color: #66D9EF;">)</span>,
                       correctNumClusters = <span style="color: #AE81FF;">true</span>,
                       verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_linear_corrected&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">square</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; x*x<span style="color: #66D9EF;">)</span>, verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_square&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">number of clusters should differ!</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; x*x<span style="color: #66D9EF;">)</span>,
                       correctNumClusters = <span style="color: #AE81FF;">true</span>,
                       verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_square_corrected&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">exp</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; exp<span style="color: #A6E22E;">(</span>x/<span style="font-style: italic;">64</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>, verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_exp64&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">number of clusters should differ!</span>
<span style="color: #F92672;">discard</span> rng.computeToy<span style="color: #AE81FF;">(</span><span style="font-style: italic;">100</span> * num, radius, σ, energyRange, sampleFn = <span style="color: #66D9EF;">(</span>x =&gt; exp<span style="color: #A6E22E;">(</span>x/<span style="font-style: italic;">64</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>,
                       correctNumClusters = <span style="color: #AE81FF;">true</span>,
                       verbose = <span style="color: #AE81FF;">true</span>, suffix = <span style="color: #E6DB74;">&quot;_exp64_corrected&quot;</span><span style="color: #AE81FF;">)</span> 

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">performToys</span><span style="color: #AE81FF;">(</span>nmc: <span style="color: #66D9EF;">int</span>,
                 numClusters: <span style="color: #66D9EF;">int</span>,
                 sampleFn: <span style="color: #66D9EF;">(</span><span style="color: #F92672;">proc</span><span style="color: #A6E22E;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>: <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>,
                 suffix: <span style="color: #66D9EF;">string</span>,
                 correctNumClusters = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">numClusters </span>= numClusters
  <span style="color: #F92672;">if</span> correctNumClusters:
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Old number of clusters: &quot;</span>, numClusters
    numClusters = compClusters<span style="color: #AE81FF;">(</span>sampleFn, numClusters<span style="color: #AE81FF;">)</span>.round.<span style="color: #66D9EF;">int</span>
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Corrected number of clusters: &quot;</span>, numClusters
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">data </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">Measurement</span><span style="color: #66D9EF;">[</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">](</span>nmc<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">clustersInRadius </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">](</span>nmc<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; nmc:
    <span style="color: #F92672;">if</span> i <span style="color: #F92672;">mod</span> <span style="font-style: italic;">500</span> == <span style="font-style: italic;">0</span>:
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Iteration: &quot;</span>, i
    <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>m, numInRadius<span style="color: #AE81FF;">)</span> = rng.computeToy<span style="color: #AE81FF;">(</span>numClusters, radius, σ, energyRange, sampleFn = sampleFn<span style="color: #AE81FF;">)</span>
    data<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = m
    clustersInRadius<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = numInRadius

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span> <span style="color: #E6DB74;">&quot;values&quot;</span> : data.mapIt<span style="color: #A6E22E;">(</span>it.value.<span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>,
                      <span style="color: #E6DB74;">&quot;errors&quot;</span> : data.mapIt<span style="color: #A6E22E;">(</span>it.error.<span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">)</span>,
                      <span style="color: #E6DB74;">&quot;numInRadius&quot;</span> : clustersInRadius <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;values&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">500</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_{suffix}.pdf&quot;</span><span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;errors&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">500</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_errors_{suffix}.pdf&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> numClusters &lt; <span style="font-style: italic;">500</span>:
    ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_bar<span style="color: #AE81FF;">()</span> +
      ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_numInRadius_{suffix}.pdf&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">else</span>:
    ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_histogram<span style="color: #AE81FF;">(</span>bins = clustersInRadius.<span style="color: #F92672;">max</span><span style="color: #AE81FF;">)</span> +
      ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_numInRadius_{suffix}.pdf&quot;</span><span style="color: #AE81FF;">)</span>
    
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfG </span>= df.gather<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;values&quot;</span>, <span style="color: #E6DB74;">&quot;errors&quot;</span><span style="color: #66D9EF;">]</span>, key = <span style="color: #E6DB74;">&quot;Type&quot;</span>, value = <span style="color: #E6DB74;">&quot;Value&quot;</span><span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>dfG, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Value&quot;</span>, fill = <span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">500</span>, position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, hdKind = hdOutline, alpha = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Sampling bias: {suffix}. NMC = {nmc}, numClusters = {int}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_combined_{suffix}.pdf&quot;</span><span style="color: #AE81FF;">)</span>
    
  <span style="color: #FD971F;">result</span> = dfG
  <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #AE81FF;">]</span> = suffix

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">performAllToys</span><span style="color: #AE81FF;">(</span>nmc, numClusters: <span style="color: #66D9EF;">int</span>, suffix = <span style="color: #E6DB74;">&quot;&quot;</span>, correctNumClusters = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  df.<span style="color: #F92672;">add</span> performToys<span style="color: #AE81FF;">(</span>nmc, numClusters, <span style="color: #66D9EF;">(</span>x =&gt; <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">&quot;constant&quot;</span>, correctNumClusters<span style="color: #AE81FF;">)</span>
  df.<span style="color: #F92672;">add</span> performToys<span style="color: #AE81FF;">(</span>nmc, numClusters, <span style="color: #66D9EF;">(</span>x =&gt; x<span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">&quot;linear&quot;</span>, correctNumClusters<span style="color: #AE81FF;">)</span>
  df.<span style="color: #F92672;">add</span> performToys<span style="color: #AE81FF;">(</span>nmc, numClusters, <span style="color: #66D9EF;">(</span>x =&gt; x*x<span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">&quot;square&quot;</span>, correctNumClusters<span style="color: #AE81FF;">)</span>
  df.<span style="color: #F92672;">add</span> performToys<span style="color: #AE81FF;">(</span>nmc, numClusters, <span style="color: #66D9EF;">(</span>x =&gt; exp<span style="color: #A6E22E;">(</span>x/<span style="font-style: italic;">64</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span>, <span style="color: #E6DB74;">&quot;exp_x_div_64&quot;</span>, correctNumClusters<span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">df = if numClusters &lt; 100: df.filter(f{`</span><span style="color: #AE81FF;">Value</span><span style="color: #75715E;">` &lt; 2e-5}) else: df</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">suffixClean </span>= suffix.strip<span style="color: #AE81FF;">(</span>chars = <span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&apos;_&apos;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pltVals </span>= ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Value&quot;</span>, fill = <span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    facet_wrap<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #AE81FF;">)</span> + 
    geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">500</span>, position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, hdKind = hdOutline, alpha = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    prefer_rows<span style="color: #AE81FF;">()</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Comp diff. sampling biases, {suffixClean}. NMC = {nmc}, numClusters = {numClusters}&quot;</span><span style="color: #AE81FF;">)</span>
    <span style="color: #75715E;">#</span><span style="color: #75715E;">ggsave(&amp;&quot;{outDir}/background_uncertainty_mc_all_samplers{suffix}.pdf&quot;, height = 600, width = 800)</span>

  <span style="color: #75715E;"># </span><span style="color: #75715E;">stacked version of number in radius</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">width </span>= <span style="color: #F92672;">if</span> numClusters &lt; <span style="font-style: italic;">100</span>: <span style="font-style: italic;">800</span>.<span style="font-style: italic;">0</span> <span style="color: #F92672;">else</span>: <span style="font-style: italic;">1000</span>.<span style="font-style: italic;">0</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">stacked version</span>
  ggplot<span style="color: #AE81FF;">(</span>df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;values&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span>, fill = <span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_bar<span style="color: #AE81FF;">(</span>position = <span style="color: #E6DB74;">&quot;stack&quot;</span><span style="color: #AE81FF;">)</span> + 
    scale_x_discrete<span style="color: #AE81FF;">()</span> +
    xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;# cluster in radius&quot;</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;# clusters in interp radius, {suffixClean}. NMC = {nmc}, numClusters = {numClusters}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_all_samplers_numInRadius_stacked{suffix}.pdf&quot;</span>, height = <span style="font-style: italic;">600</span>, width = width<span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">ridgeline version</span>
  ggplot<span style="color: #AE81FF;">(</span>df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;values&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span>, fill = <span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    ggridges<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;sampling&quot;</span>, overlap = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">3</span><span style="color: #AE81FF;">)</span> + 
    geom_bar<span style="color: #AE81FF;">(</span>position = <span style="color: #E6DB74;">&quot;identity&quot;</span><span style="color: #AE81FF;">)</span> + 
    scale_x_discrete<span style="color: #AE81FF;">()</span> +
    xlab<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;# cluster in radius&quot;</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;# clusters in interp radius, {suffixClean}. NMC = {nmc}, numClusters = {numClusters}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_all_samplers_numInRadius_ridges{suffix}.pdf&quot;</span>, height = <span style="font-style: italic;">600</span>, width = width<span style="color: #AE81FF;">)</span>
    
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">pltNum</span>: <span style="color: #66D9EF;">GgPlot</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">non stacked bar/histogram with alpha</span>
  <span style="color: #F92672;">if</span> numClusters &lt; <span style="font-style: italic;">100</span>:
    pltNum = ggplot<span style="color: #AE81FF;">(</span>df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;values&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span>, fill = <span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_bar<span style="color: #AE81FF;">(</span>position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, alpha = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      scale_x_discrete<span style="color: #AE81FF;">()</span> + 
      ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;# clusters in interp radius, {suffixClean}. NMC = {nmc}, numClusters = {numClusters}&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">else</span>:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">binEdges </span>= toSeq<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span> .. df<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span>, <span style="color: #66D9EF;">int</span><span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">max</span> + <span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span>it.<span style="color: #66D9EF;">float</span> - <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span>
    pltNum = ggplot<span style="color: #AE81FF;">(</span>df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>`<span style="color: #66D9EF;">Type</span>` == <span style="color: #E6DB74;">&quot;values&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;numInRadius&quot;</span>, fill = <span style="color: #E6DB74;">&quot;sampling&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_histogram<span style="color: #AE81FF;">(</span>breaks = binEdges, hdKind = hdOutline, position = <span style="color: #E6DB74;">&quot;identity&quot;</span>, alpha = some<span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;# clusters in interp radius, {suffixClean}. NMC = {nmc}, numClusters = {numClusters}&quot;</span><span style="color: #AE81FF;">)</span><span style="color: #75715E;"># </span><span style="color: #75715E;">+</span>
  ggmulti<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span>pltVals, pltNum<span style="color: #66D9EF;">]</span>, fname = &amp;<span style="color: #E6DB74;">&quot;{outDir}/background_uncertainty_mc_all_samplers{suffix}.pdf&quot;</span>,
          widths = @<span style="color: #66D9EF;">[</span><span style="font-style: italic;">800</span><span style="color: #66D9EF;">]</span>, heights = @<span style="color: #66D9EF;">[</span><span style="font-style: italic;">600</span>, <span style="font-style: italic;">300</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>

<span style="color: #75715E;"># </span><span style="color: #75715E;">first regular MC  </span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">nmc </span>= <span style="font-style: italic;">100_000</span>
performAllToys<span style="color: #AE81FF;">(</span>nmc, num, suffix = <span style="color: #E6DB74;">&quot;_uncorrected&quot;</span>, correctNumClusters = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">and now the artificial increased toy example</span>
performAllToys<span style="color: #AE81FF;">(</span>nmc <span style="color: #F92672;">div</span> <span style="font-style: italic;">10</span>, <span style="font-style: italic;">10</span> * num, <span style="color: #E6DB74;">&quot;_uncorrected_artificial_statistics&quot;</span>, correctNumClusters = <span style="color: #AE81FF;">false</span><span style="color: #AE81FF;">)</span>
<span style="color: #E6DB74;">## and now with cluster correction</span>
performAllToys<span style="color: #AE81FF;">(</span>nmc, num, suffix = <span style="color: #E6DB74;">&quot;_corrected&quot;</span>, correctNumClusters = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">and now the artificial increased toy example</span>
performAllToys<span style="color: #AE81FF;">(</span>nmc <span style="color: #F92672;">div</span> <span style="font-style: italic;">10</span>, <span style="font-style: italic;">10</span> * num, <span style="color: #E6DB74;">&quot;_corrected_artificial_statistics&quot;</span>, correctNumClusters = <span style="color: #AE81FF;">true</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> random, seqmath, sequtils, algorithm

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">cdf</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>data: <span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">T</span> =
  <span style="color: #FD971F;">result</span> = data.cumSum<span style="color: #AE81FF;">()</span>
  <span style="color: #FD971F;">result</span>.applyIt<span style="color: #AE81FF;">(</span>it / <span style="color: #FD971F;">result</span><span style="color: #66D9EF;">[</span>^<span style="font-style: italic;">1</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">sampleFromCdf</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>data, cdf: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">T</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">sample an index based on this CDF</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">idx </span>= cdf.lowerBound<span style="color: #AE81FF;">(</span>rand<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = data<span style="color: #AE81FF;">[</span>idx<span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">sampleFrom*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>data: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">]</span>,
                   start, stop: <span style="color: #66D9EF;">T</span>,
                   numSamples: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">get the normalized (to 1) CDF for this radius</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">points </span>= linspace<span style="color: #AE81FF;">(</span>start, stop, data.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cdfD </span>= cdf<span style="color: #AE81FF;">(</span>data<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>numSamples<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; numSamples:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">sample an index based on this CDF</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">idx </span>= cdfD.lowerBound<span style="color: #AE81FF;">(</span>rand<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = points<span style="color: #AE81FF;">[</span>idx<span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">sampleFrom*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>fn: <span style="color: #66D9EF;">(</span><span style="color: #F92672;">proc</span><span style="color: #A6E22E;">(</span>x: <span style="color: #66D9EF;">T</span><span style="color: #A6E22E;">)</span>: <span style="color: #66D9EF;">T</span><span style="color: #66D9EF;">)</span>, start, stop: <span style="color: #66D9EF;">T</span>,
                   numSamples: <span style="color: #66D9EF;">int</span>,
                   numInterp = <span style="font-style: italic;">10_000</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">get the normalized (to 1) CDF for this radius</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">points </span>= linspace<span style="color: #AE81FF;">(</span>start, stop, numInterp<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">data </span>= points.mapIt<span style="color: #AE81FF;">(</span>fn<span style="color: #66D9EF;">(</span>it<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cdfD </span>= cdf<span style="color: #AE81FF;">(</span>data<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>numSamples<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; numSamples:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">sample an index based on this CDF</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">idx </span>= cdfD.lowerBound<span style="color: #AE81FF;">(</span>rand<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
    <span style="color: #FD971F;">result</span><span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = points<span style="color: #AE81FF;">[</span>idx<span style="color: #AE81FF;">]</span>
</pre>
</div>

<p>
So, from these Monte Carlo toy experiments, we can gleam quite some
insight.
</p>

<p>
We have implemented unbiased clusters as well as biased clusters.
</p>

<p>
First one example for the four different cluster samplers, with the
condition each time that the <b>number of total clusters</b> is the same as
in the constant background rate case:
</p>


<figure id="unbiased_sampled_background_clusters_uncorrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_constant.svg" class="org-svg" alt="clusters_constant.svg" />

<figcaption>Figure 8: <span class="figure-number">Figure 85: </span>Example of an unbiased cluster sampling. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking.</figcaption>
</figure>



<figure id="linear_sampled_background_clusters_uncorrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_linear.svg" class="org-svg" alt="clusters_linear.svg" />

<figcaption>Figure 9: <span class="figure-number">Figure 86: </span>Example of a linearly biased cluster sampling. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking.</figcaption>
</figure>


<figure id="square_sampled_background_clusters_uncorrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_square.svg" class="org-svg" alt="clusters_square.svg" />

<figcaption>Figure 10: <span class="figure-number">Figure 87: </span>Example of a squarely biased cluster sampling. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking.</figcaption>
</figure>


<figure id="exp64_sampled_background_clusters_uncorrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_exp64.svg" class="org-svg" alt="clusters_exp64.svg" />

<figcaption>Figure 11: <span class="figure-number">Figure 88: </span>Example of a \(\exp(x/64)\) biased cluster sampling. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking.</figcaption>
</figure>

<p>
With these in place, we performed two sets of Monte Carlo experiments
to compute the value &amp; uncertainty of the center point <code>(127, 127)</code>
using the gaussian weighted nearest neighbor interpolation from the
previous section.
</p>

<p>
This is done for all four different samplers and the obtained values
and their errors (propagated via <code>Measuremancer</code>) plotted as a
histogram
</p>

<p>
Once for the number of expected clusters (based on the gold region
background rate), fig. [BROKEN LINK: background_uncertainty_mc_all_samplers] and once
for a lower statistics, but much 10 times higher number of clusters,
fig. [BROKEN LINK: background_uncertainty_mc_all_samplers_artificial_statistics]
</p>


<figure id="background_uncertainty_mc_all_samplers_uncorrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/background_uncertainty_mc_all_samplers_uncorrected.svg" class="org-svg" alt="background_uncertainty_mc_all_samplers_uncorrected.svg" />

<figcaption>Figure 12: <span class="figure-number">Figure 89: </span>Comparison of four different samplers (unbiased + 3 biased), showing the result of \num{100000} MC toy experiments based on the expected number of clusters if the same background rate of the gold region covered the whole chip. Below a bar chart of the number of clusters found inside the radius. The number of clusters corresponds to about <code>5e-6 keV⁻¹•cm⁻²•s⁻¹</code> over the whole chip.</figcaption>
</figure>


<figure id="background_uncertainty_mc_all_samplers_uncorrected_artificial_statistics">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/background_uncertainty_mc_all_samplers_uncorrected_artificial_statistics.svg" class="org-svg" alt="background_uncertainty_mc_all_samplers_uncorrected_artificial_statistics.svg" />

<figcaption>Figure 19: <span class="figure-number">Figure 90: </span>Comparison of four different samplers (unbiased + 3 biased), showing the result of \num{10000} MC toy experiments based on the 10 times the expected number of clusters if the same background rate of the gold region covered the whole chip. Below a histogram of the number of clusters found inside the radius. The number of clusters corresponds to about <code>5e-5 keV⁻¹•cm⁻²•s⁻¹</code> over the whole chip.</figcaption>
</figure>

<p>
First of all there is some visible structure in the low statistics
figure (fig. <a href="background_uncertainty_mc_all_samplers_uncorrected">12</a>). The
meaning of it, is not entirely clear to me. Initially, we thought it
might be an integer effect of 0, 1, 2, … clusters within the radius
and the additional slope being from the distance these clusters are
away from the center. Further away, less weight, less background
rate. But looking at the number of clusters in the radius (lowest plot
in the figure), this explanation alone does not really seem to explain it.
</p>

<p>
For the high statistics case, we can see that the mean of the
distribution shifts lower and lower, the more extreme the bias is.
This is likely, because the bias causes a larger and larger number of
clusters to land near the top corner of the chip, meaning that there
are less and less clusters found within the point of interpolation.
Comparing the number of clusters in radius figure for this case shows
that indeed, the square and exponential bias case show a peak at lower
energies.
</p>

<p>
Therefore, I also computed a correction function to compute a biased
distribution that matches the background rate exactly at the center of
the chip, but therefore allows for a larger number of sampled clusters
in total.
</p>

<p>
We know that (projecting onto the y axis alone), there are:
</p>

<p>
\[
∫_0^{256} f(x) dx = N
\]
</p>

<p>
where \(N\) is the total number of clusters we draw and \(f(x)\) the
function we use to sample. For the constant case, this means that we
have a rate of \(N / 256\) clusters per pixel along the y axis
(i.e. per row).
</p>

<p>
So in order to correct for this and compute the new required number of
clusters in total that gives us the same rate of \(N / 256\) in the
center, we can:
</p>

<p>
\[
∫_0^{256} \frac{N}{256 · f(127)} f(x) dx = N&apos;
\]
</p>

<p>
where the point \(f(127)\) is simply the value of the &quot;background rate&quot;
the function we currently use produces as is in the center of the
chip.
</p>

<p>
Given our definition of the functions (essentially as primitive
<code>f(x)= x</code>, <code>f(x) = x * x</code>, etc. we expect the linear function to match
the required background rate of the constant case exactly in the
middle, i.e. at 127. And this is indeed the case (as can be seen in
the new linear plot below, fig. <a href="linear_sampled_background_clusters_corrected">15</a>).
</p>

<p>
This correction has been implemented. The equivalent figures to the
cluster distributions from further above are:
</p>


<figure id="unbiased_sampled_background_clusters_corrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_constant_corrected.svg" class="org-svg" alt="clusters_constant_corrected.svg" />

<figcaption>Figure 14: <span class="figure-number">Figure 91: </span>Example of an unbiased cluster sampling with the applied correction. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking. As expected the number of clusters is still the same number as above.</figcaption>
</figure>


<figure id="linear_sampled_background_clusters_corrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_linear_corrected.svg" class="org-svg" alt="clusters_linear_corrected.svg" />

<figcaption>Figure 15: <span class="figure-number">Figure 92: </span>Example of a linearly biased cluster sampling with the applied correction. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking.</figcaption>
</figure>


<figure id="square_sampled_background_clusters_corrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_square_corrected.svg" class="org-svg" alt="clusters_square_corrected.svg" />

<figcaption>Figure 16: <span class="figure-number">Figure 93: </span>Example of a squarely biased cluster sampling with the applied correction. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking. The correction means that the total number of clusters is now almost 2500 more than in the uncorrected case.</figcaption>
</figure>


<figure id="exp64_sampled_background_clusters_corrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/clusters_exp64_corrected.svg" class="org-svg" alt="clusters_exp64_corrected.svg" />

<figcaption>Figure 17: <span class="figure-number">Figure 94: </span>Example of a \(\exp(x/64)\) biased cluster sampling with the applied correction. Sampled 100 times (for better visibility of the distribution) as many clusters as predicted for our background data taking. The correction means that the total number of clusters is now almost double the amount in the uncorrected case.</figcaption>
</figure>

<p>
The correction works nicely. It is visible that in the center the
density seems to be the same as in the constant case.
</p>

<p>
From here we can again look at the same plots as above, i.e. the
corrected monte carlo plots:
</p>


<figure id="background_uncertainty_mc_all_samplers_corrected">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/background_uncertainty_mc_all_samplers_corrected.svg" class="org-svg" alt="background_uncertainty_mc_all_samplers_corrected.svg" />

<figcaption>Figure 18: <span class="figure-number">Figure 95: </span>Comparison of four different samplers (unbiased + 3 biased), showing the result of \num{100000} MC toy experiments based on the expected number of clusters such that the background is biased and produces the same background rate as in the gold region in the constant case. Below a bar chart of the number of clusters found inside the radius. The number of clusters corresponds to about <code>5e-6 keV⁻¹•cm⁻²•s⁻¹</code> over the whole chip.</figcaption>
</figure>


<figure id="background_uncertainty_mc_all_samplers_uncorrected_artificial_statistics">
<img src="./figs/home/basti/org/Figs/statusAndProgress/background_interpolation/uncertainty/background_uncertainty_mc_all_samplers_corrected_artificial_statistics.svg" class="org-svg" alt="background_uncertainty_mc_all_samplers_corrected_artificial_statistics.svg" />

<figcaption>Figure 19: <span class="figure-number">Figure 96: </span>Comparison of four different samplers (unbiased + 3 biased), showing the result of \num{10000} MC toy experiments based on the 10 times the expected number of clusters such that the background is biased and produces the same background rate as in the gold region in the constant case. Below a histogram of the number of clusters found inside the radius. The number of clusters corresponds to about <code>5e-5 keV⁻¹•cm⁻²•s⁻¹</code> over the whole chip.</figcaption>
</figure>

<p>
It can be nicely seen that the mean of the value is now again at the
same place for all samplers! This is reassuring, because it implies
that any systematic uncertainty due to such a bias in our real data is
<b>probably</b> negligible, as the effects will never be as strong as
simulated here.
</p>

<p>
Secondly, we can nicely see that the computed uncertainty for a single
element seems to follow nicely the actual width of the distribution.
</p>

<p>
In particular this is visible in the artificial high statistics case,
where the mean value of the error is comparable to the width of the
<code>value</code> histogram.
</p>
</div>
</li>
</ol>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:ingredients:candidates">
<h4 id="sec:limit:ingredients:candidates"><span class="section-number-4">13.10.9.</span> Candidates</h4>
<div class="outline-text-4" id="text-sec:limit:ingredients:candidates">
<p>
Finally, the candidates are the X-ray like clusters remaining after
the background rejection algorithm has been applied to the data taken
during the solar tracking. For the computation of the expected limit,
the set of candidates is drawn from the background rate distribution
via sampling from a Poisson distribution with the mean of the
background rate. As our background model is an interpolation instead
of a binned model with Poisson distributed bins, we create a grid of
\((x, y, E) = (10, 10, 20)\) cells from the interpolation, which we
scale such that they contain the expected number of candidates from
each cell after the solar tracking duration, \(b_{ijk}\). Then we can
walk over the entire grid and sample from a Poisson distribution for
each grid cell with mean \(λ_{ijk} = b_{ijk}\). For all sampled
candidates \(κ_{ijk}\) in each grid cell, we then compute a random
position and energy from uniform distributions along each dimension.
</p>

<p>
A slice of the grid cells centered at \(\SI{2.75}{keV}\) is shown in
fig. <a href="#fig:limit:expected_counts">20(a)</a>, with the color indicating how
many candidates are expected in each cell after the solar tracking duration.
</p>

<p>
A set of toy candidates generated in this manner is shown in
fig. <a href="#fig:limit:toy_candidate_set">20(b)</a>. Each point represents one toy
candidate at its cluster center position. The color scale represents
the energy of each cluster in \(\si{keV}\).
</p>


<figure class="figure-wrapper" id="fig:limit:toy_candidates">
<figure class="subfigure" id="fig:limit:expected_counts" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/candidate_sampling_grid_index_5.svg" data-width="99%" />  <figcaption>Figure 20(a): Grid of expected counts</figcaption></figure> <figure class="subfigure" id="fig:limit:toy_candidate_set" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/example_candidates_1.svg" data-width="99%" />  <figcaption>Figure 20(b): Toy candidate set</figcaption></figure>
<figcaption>Figure 20: <a href="#fig:limit:expected_counts">20(a)</a>: Expected counts in $(10, 10, 20)$ cells, centered around $\SI{2.75}{keV}$ obtained from background interpolation and normalized back to counts in
           solar tracking within the volume of the grid cell. <a href="#fig:limit:toy_candidate_set">20(b)</a>: A set of toy candidates drawn from cells of expected counts using a Poisson
           distribution with mean based on each grid cell. Each point is the center of a
           cluster with the color scale showing the energy of that cluster.</figcaption>
</figure>
</div>



<div class="outline-5" id="outline-container-org7e80792">
<h5 id="org7e80792"><span class="section-number-5">13.10.9.1.</span> Generate the candidate sampling figure   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-10-9-1">
<p>
Sanity check for candidate sampling:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">DEBUG_TEX</span>=true <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
                      mcmc_limit_calculation sanity <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --sanityPath ~/phd/Figs/limit/sanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --backgroundSampling
</pre>
</div>
</div>
</div>
</div>
</div>


<div class="outline-3" id="outline-container-sec:limit:systematics">
<h3 id="sec:limit:systematics"><span class="section-number-3">13.11.</span> Systematics</h3>
<div class="outline-text-3" id="text-sec:limit:systematics">
<p>
As explained previously in sec. <a href="./limit.html#sec:limit:method_systematics">13.6</a>, we
introduce 4 different nuisance parameters to handle systematics. These
are split by those impacting the signal, the background and each
position axis independently.
</p>

<p>
Tab. <a href="#tab:limit:systematic_uncertainties">25</a> shows the different systematic
uncertainties we consider, whether they affect signal, background or
the position, their value and finally potential biases due to some
imperfect knowledge. Note that the listed software efficiency
systematic is an upper bound. The explicit value depends on the
parameter setup for which we compute a limit, as each setup with
differing software efficiency can have differing
uncertainties. Further note that the accuracy given is purely the
result of our estimation on the signal or background of the underlying
systematic assuming some uncertainty. It does not strictly speaking
reflect our knowledge of it to that extent.
</p>

<p>
All individual systematic uncertainties are combined in the form of a
euclidean distance
</p>

<p>
\[
\bar{σ} = \sqrt{\sum_i σ_i²}
\]
</p>

<p>
for each type of systematic (\(s\), \(b\)). The combined uncertainties
come out to
</p>

\begin{align*}
σ_s &amp;\leq \SI{3.38}{\percent} \text{ (assuming } σ_{\text{software}} = \SI{2}{\%} \text{)} \\
σ_b &amp;= \SI{0.28}{\percent} \\
σ_{xy} &amp;= \SI{5}{\percent} \text{ (fixed, uncertainty numbers are bounds)}
\end{align*}

<p>
where again the final \(σ_s\) depends on the specific setup and the
given value is for a case of \(σ_{\text{software}} = \SI{2}{\%}\), which
is a bound larger than the observed uncertainties. The position
uncertainty is fixed by hand to \(\SI{5}{\%}\) due to lack of knowledge
about parameters that could be used to calculate a specific value. The
numbers in the table represent bounds about the maximum deviation
possible. For a derivation of these numbers, see the extended thesis <sup>  <a role="doc-backlink" class="footref" id="fnr.12" href="#fn.12">12</a></sup>.
</p>

<table id="tab:limit:systematic_uncertainties">
<caption class="t-above"><span class="table-number">Table 25:</span> Overview of the different systematics that are considered as well as possible biases due to our understanding.</caption>

<colgroup>
<col class="org-left" />

<col class="org-left" />

<col class="org-right" />

<col class="org-left" />
</colgroup>
<thead>
<tr>
<th class="org-left" scope="col">Uncertainty</th>
<th class="org-left" scope="col">s or b?</th>
<th class="org-right" scope="col">rel. σ [%]</th>
<th class="org-left" scope="col">bias?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Earth \(⇔\) Sun distance</td>
<td class="org-left">s</td>
<td class="org-right">0.7732</td>
<td class="org-left">none</td>
</tr>

<tr>
<td class="org-left">Window thickness (± 10 nm)</td>
<td class="org-left">s</td>
<td class="org-right">0.5807</td>
<td class="org-left">none</td>
</tr>

<tr>
<td class="org-left">Solar models</td>
<td class="org-left">s</td>
<td class="org-right">\(&lt; 1\)</td>
<td class="org-left">none</td>
</tr>

<tr>
<td class="org-left">Magnet length (- 1 cm)</td>
<td class="org-left">s</td>
<td class="org-right">0.2159</td>
<td class="org-left">likely \(\SI{9.26}{m}\)</td>
</tr>

<tr>
<td class="org-left">Magnet bore diameter (± 0.5 mm)</td>
<td class="org-left">s</td>
<td class="org-right">2.32558</td>
<td class="org-left">measurements: 42.x - 43</td>
</tr>

<tr>
<td class="org-left">Window rotation (30° ± 0.5°)</td>
<td class="org-left">s</td>
<td class="org-right">0.18521</td>
<td class="org-left">none</td>
</tr>

<tr>
<td class="org-left">Software efficiency</td>
<td class="org-left">s</td>
<td class="org-right">\(&lt; 2\)</td>
<td class="org-left">none</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Gas gain time binning</td>
<td class="org-left">b</td>
<td class="org-right">0.26918</td>
<td class="org-left">to 0</td>
</tr>

<tr>
<td class="org-left">Reference dist interp (CDL morphing)</td>
<td class="org-left">b</td>
<td class="org-right">0.0844</td>
<td class="org-left">none</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Alignment (signal, related mounting)</td>
<td class="org-left">s (pos.)</td>
<td class="org-right">0.5 mm</td>
<td class="org-left">none</td>
</tr>

<tr>
<td class="org-left">Detector mounting precision (±0.25 mm)</td>
<td class="org-left">s (pos.)</td>
<td class="org-right">0.25 mm</td>
<td class="org-left">none</td>
</tr>
</tbody>
</table>
</div>

<div class="outline-4" id="outline-container-org3bcc770">
<h4 id="org3bcc770"><span class="section-number-4">13.11.1.</span> Thoughts on systematics   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-1">
<p>
Systematics like the above are obviously useful. However, one can
easily fall into the trap of realizing that – if one is being honest
– there are a myriad of other things that introduce bias and hence
yield a form of systematic uncertainty.
</p>

<p>
The numbers shown in the table are those where
</p>
<ul class="org-ul">
<li>understanding and calculating their impact was somewhat possible</li>
<li>estimating a reasonable number possible.</li>
</ul>

<p>
By no means are those the only possible numbers. Some things that one
could include relate to most of the algorithms used for background
rejection and signal calculations. For example the random coincidence
determination itself comes with both a statistical and likely
systematic uncertainty, which we did not attempt to estimate
(statistical uncertainties take care of themselves to an extent via
our expected limits). The energy calibration comes with systematic
uncertainties of many different kinds, but putting these into numbers
is tricky. Or even things like CAST&apos;s pointing uncertainty (some of it
could be computed from the CAST slow control files). 
</p>

<p>
Generally, by combining all systematics we <i>do</i> consider as a square
root of the squared sum should generally be a conservative
estimate. Therefore, I hope that even if some numbers are not taken
into account, the combined uncertainty is anyhow a roughly realistic
estimate of our systematic uncertainty.
</p>

<p>
One parameter of interest that I would have included, had I had the
data at an earlier times, is the uncertainty of the telescope
effective area. The numbers sent to me by Jaime Ruz do contain an
uncertainty band, which one could have attempted to utilize. 
</p>

<p>
In any case though, to me the most important aspect about these
systematics here is that we show that including systematics into such
a limit calculation directly via such a Bayesian approach works
well. This is interesting, because – as far as I&apos;m aware – no CAST
analysis before actually did that. This means for BabyIAXO in the
future, there should be more emphasis on estimating systematic
uncertainties and there need not be worry about handling them in the
limit calculations.
</p>

<p>
In particular each group responsible for a certain subset of the
experiment should document their own systematic uncertainties. A PhD
student should not be in charge of estimating uncertainties for
aspects of the experiment they have no expertise in.
</p>
</div>
</div>

<div class="outline-4" id="outline-container-sec:systematics:combined_uncertainties">
<h4 id="sec:systematics:combined_uncertainties"><span class="section-number-4">13.11.2.</span> Computing the combined uncertainties   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:systematics:combined_uncertainties">
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> math
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ss </span>= <span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">77315941</span>, <span style="color: #75715E;"># </span><span style="color: #75715E;">based on real tracking dates # 3.3456, &lt;- old number for Sun ⇔ Earth using min/max perihelion/aphelion</span>
          <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5807</span>,
          <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>,
          <span style="font-style: italic;">0</span>.<span style="font-style: italic;">2159</span>,
          <span style="font-style: italic;">2</span>.<span style="font-style: italic;">32558</span>,
          <span style="font-style: italic;">0</span>.<span style="font-style: italic;">18521</span><span style="color: #AE81FF;">]</span>
          <span style="color: #75715E;">#</span><span style="color: #75715E;">1.727] # software efficiency of LnL method. Included in `</span><span style="color: #AE81FF;">mcmc_limit</span><span style="color: #75715E;">` directly!</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">bs </span>= <span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">26918</span>,
          <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0844</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">total</span><span style="color: #AE81FF;">(</span>vals: <span style="color: #66D9EF;">openArray</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">for</span> x <span style="color: #F92672;">in</span> vals:
    <span style="color: #FD971F;">result</span> += x * x
  <span style="color: #FD971F;">result</span> = sqrt<span style="color: #AE81FF;">(</span><span style="color: #FD971F;">result</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Combined uncertainty signal: &quot;</span>, total<span style="color: #AE81FF;">(</span>ss<span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">100</span>.<span style="font-style: italic;">0</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Combined uncertainty background: &quot;</span>, total<span style="color: #AE81FF;">(</span>bs<span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">100</span>.<span style="font-style: italic;">0</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Position: &quot;</span>, sqrt<span style="color: #AE81FF;">(</span>pow<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span> / <span style="font-style: italic;">7</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span>, <span style="font-style: italic;">2</span><span style="color: #66D9EF;">)</span> + pow<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">25</span> / <span style="font-style: italic;">7</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span>, <span style="font-style: italic;">2</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

</pre>
</div>

<p>
Compared to 4.582 % we&apos;re now down to 3.22%! (in each case including
already the software efficiency, which we don&apos;t actually include
anymore here, but in <code>mcmc_limit</code>).
Without the software efficiency we&apos;re down to 2.7%!
</p>
</div>

<div class="outline-5" id="outline-container-org204d562">
<h5 id="org204d562"><span class="section-number-5">13.11.2.1.</span> Old results</h5>
<div class="outline-text-5" id="text-13-11-2-1">
<p>
These were the numbers that still used the Perihelion/Aphelion based
distances for the systematic of Sun ⇔ Earth distance.
</p>

<table>


<colgroup>
<col class="org-left" />

<col class="org-left" />

<col class="org-left" />

<col class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Combined</td>
<td class="org-left">uncertainty</td>
<td class="org-left">signal:</td>
<td class="org-right">0.04582795952309026</td>
</tr>

<tr>
<td class="org-left">Combined</td>
<td class="org-left">uncertainty</td>
<td class="org-left">background:</td>
<td class="org-right">0.002821014576353691</td>
</tr>

<tr>
<td class="org-left">Position:</td>
<td class="org-left">0.07985957062499248</td>
<td class="org-left"> </td>
<td class="org-right"> </td>
</tr>
</tbody>
</table>

<p>
<b>NOTE</b>: The value used here is not the one that was used in most mcmc
limit calculations. There we used:
</p>
<div class="org-src-container">
<pre class="src src-nim">    σ_sig = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">04692492913207222</span>,
</pre>
</div>
<p>
which comes out from assuming 2% uncertainty for the software
efficiency instead of the <code>1.727</code> that now show up in the code!
</p>
</div>
</div>
</div>


<div class="outline-4" id="outline-container-org24251d7">
<h4 id="org24251d7"><span class="section-number-4">13.11.3.</span> Signal <code>[0/3]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-3">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>signal position</b> (i.e. the spot of the raytracing result)
<ul class="org-ul">
<li>to be implemented as a nuisance parameter (actually 2) in the
limit calculation code.</li>
</ul></li>
<li class="off"><code>[ ]</code> pointing precision of the CAST magnet
<ul class="org-ul">
<li>check the reports of the CAST sun filming. That should give us a
good number for the alignment accuracy</li>
</ul></li>
<li class="off"><code>[ ]</code> detector and telescope alignment
<ul class="org-ul">
<li>detector alignment goes straight into the signal position one. The
telescope alignment can be estimated maybe from the geometer
measurements. In any case that will also directly impact the
placement / shape of the axion image. So this should be
redundant. Still need to check the geometer measurements to get a
good idea here.
<ul class="org-ul">
<li class="on"><code>[X]</code> compute center based on X-ray finger run</li>
<li class="on"><code>[X]</code> find image of laser alignment with plastic target</li>
<li class="off"><code>[ ]</code> find geometer measurements and see where they place us (good
for relative from 2017/18 to end of 2018)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>

<div class="outline-4" id="outline-container-org09e7bed">
<h4 id="org09e7bed"><span class="section-number-4">13.11.4.</span> Signal rate &amp; efficiency <code>[5/7]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-4">
<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>CLEAN THIS UP SOMEWHAT!</b></li>
</ul>


<ul class="org-ul">
<li class="off"><code>[ ]</code> (solar model)
<ul class="org-ul">
<li class="on"><code>[X]</code> look into the work by Lennert &amp; Sebastian. What does their study
of different solar models imply for different fluxes?
<ul class="org-ul">
<li class="off"><code>[ ]</code> check absolute number for</li>
</ul></li>
</ul></li>
<li class="on"><code>[X]</code> axion rate as a function of distance Earth ⇔ Sun (depends on time
data was taken)
<ul class="org-ul">
<li class="on"><code>[X]</code> simple: compute different rate based on perihelion &amp;
aphelion. Difference is measure for &gt; 1σ uncertainty on flux</li>
<li class="off"><code>[ ]</code> more complex: compute actual distance at roughly times when data
taking took place. Compare those numbers with the AU distance used
in the ray tracer &amp; in axion flux (<code>expRate</code> in code).</li>
</ul></li>
<li class="on"><code>[X]</code> telescope and window efficiencies
<ul class="org-ul">
<li class="on"><code>[X]</code> window: especially uncertainty of window thickness: Yevgen
measured thickness of 3 samples using ellipsometry and got values
O(350 nm)!
Norcada themselves say 300 ± 10 nm
<ul class="org-ul">
<li>compute different absorptions for the 300 ± 10 nm case
(integrated over some energy range) and for the extrema (Yevgen). That
should give us a number in flux one might lose / gain.</li>
</ul></li>
</ul></li>
<li class="on"><code>[X]</code> window rotation (position of the strongbacks), different for two run
periods &amp; somewhat uncertain
<ul class="org-ul">
<li class="on"><code>[X]</code> measurement: look at occupancy of calibration runs. This <b>should</b>
give us a well defined orientation for the strongback. From that
we can adjust the raytracing. Ideally this does not count as a
systematic as we can measure it (I think, but need to do!)
<ul class="org-ul">
<li class="on"><code>[X]</code> need to look at X-ray finger runs reconstructed &amp; check
occupancy to compare with occupancies of the calibration data</li>
<li class="on"><code>[X]</code> determine the actual loss based on the rotation uncertainty
if plugged into raytracer &amp; computed total signal?</li>
</ul></li>
</ul></li>
<li class="on"><code>[X]</code> magnet length, diameter and field strength (9 T?)
<ul class="org-ul">
<li>magnet length sometimes reported as 9.25 m, other times as 9.26
<ul class="org-ul">
<li class="on"><code>[X]</code> compute conversion probability for 9.26 ± 0.01 m. Result affects
signal. Get number.</li>
</ul></li>
<li>diameter sometimes reported as 43 mm, sometimes 42.5 (iirc, look
up again!), but numbers given by Theodoros from a measurement for
CAPP indicated essentially 43 (with some measured uncertainty!)
<ul class="org-ul">
<li class="on"><code>[X]</code> treated the same way as magnet length. Adjust area accordingly &amp;
get number for the possible range.</li>
</ul></li>
</ul></li>
<li class="off"><code>[ ]</code> Software signal efficiency due to linear logL interpolation, for
classification signal / background
<ul class="org-ul">
<li class="off"><code>[ ]</code> what we already did: took two bins surrounding a center bin and
interpolated the middle one.
-&gt; what is difference between interpolated and real? This is a measure for
its uncertainty.</li>
</ul></li>
<li class="on"><code>[X]</code> detector mounting precision:
<ul class="org-ul">
<li class="on"><code>[X]</code> 6 mounting holes, a M6. Hole size 6.5 mm. Thus, easily 0.25mm
variation is possible (discussed with Tobi).</li>
<li class="on"><code>[X]</code> plug can be moved about ±0.43mm away from the center. On
septemboard variance of plugs is ±0.61mm.</li>
</ul></li>
</ul>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:distance_earth_sun">
<h5 id="sec:uncertain:distance_earth_sun"><span class="section-number-5">13.11.4.1.</span> Distance Earth ⇔ Sun</h5>
<div class="outline-text-5" id="text-sec:uncertain:distance_earth_sun">
<p>
The distance between Earth and the Sun varies between:
</p>

<p>
Aphelion:        152100000 km
Perihelion:      147095000 km 
Semi-major axis: 149598023 km
</p>
<p>
which first of all is a variation of a bit more than 3% or about ~1.5%
from one AU. The naive interpretation of the effect on the signal
variation would then be 1 / (1.015²) = ~0.971, a loss of about 3% for
the increase from the semi-major axis to the aphelion (or the inverse
for an increase to the aphelion).
</p>

<p>
In more explicit numbers:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> math

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">flux</span><span style="color: #AE81FF;">(</span>r: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #FD971F;">result</span> = <span style="font-style: italic;">1</span> / <span style="color: #AE81FF;">(</span>r * r<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f_au </span>= flux<span style="color: #AE81FF;">(</span><span style="font-style: italic;">149598023</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f_pe </span>= flux<span style="color: #AE81FF;">(</span><span style="font-style: italic;">147095000</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f_ap </span>= flux<span style="color: #AE81FF;">(</span><span style="font-style: italic;">152100000</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux at 1 AU: &quot;</span>, f_au
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux at Perihelion: &quot;</span>, f_pe
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux at Aphelion: &quot;</span>, f_ap

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux decrease from 1 AU to Perihelion: &quot;</span>, f_au / f_pe
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux increase from 1 AU to Aphelion: &quot;</span>, f_au / f_ap
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Mean of increase &amp; decrease: &quot;</span>, <span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - f_au / f_pe<span style="color: #66D9EF;">)</span> + <span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - f_au / f_ap<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Total flux difference: &quot;</span>, f_pe / f_ap
</pre>
</div>
</div>

<ol class="org-ol">
<li><a id="org1104de9"> </a><b>UPDATE</b>: <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-07-01 Sat 15:50&gt;</span></span><br />
<div class="outline-text-6" id="text-13-11-4-1-1">
<p>
In section [BROKEN LINK: sec:journal:01_07_23_sun_earth_dist] of the <code>journal.org</code>
we discuss the real distances during the CAST trackings. The numbers
we actually need to care about are the following:
</p>

<pre class="example">
Mean distance during trackings = 0.9891144450781392
Variance of distance during trackings = 1.399449924353128e-05
Std of distance during trackings = 0.003740922245052853
</pre>

<p>
referring to the CSV file:
<a href="./../org/resources/sun_earth_distance_cast_solar_trackings.csv">./../org/resources/sun_earth_distance_cast_solar_trackings.csv</a>
</p>

<p>
where the numbers are in units of 1 AU.
</p>

<p>
So the absolute numbers come out to:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">mean </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9891144450781392</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Actual distance = &quot;</span>, mean.<span style="color: #66D9EF;">AU</span>.to<span style="color: #AE81FF;">(</span>km<span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
This means an improvement in flux, following the code snippet above:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> math, unchained, measuremancer

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">flux</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">](</span>r: <span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">T</span> =
  <span style="color: #FD971F;">result</span> = <span style="font-style: italic;">1</span> / <span style="color: #AE81FF;">(</span>r * r<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">mean </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">9891144450781392</span>.<span style="color: #66D9EF;">AU</span>.to<span style="color: #AE81FF;">(</span>km<span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">float</span> ± <span style="font-style: italic;">0</span>.<span style="font-style: italic;">003740922245052853</span>.<span style="color: #66D9EF;">AU</span>.to<span style="color: #AE81FF;">(</span>km<span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">float</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Flux increase from 1 AU to our actual mean: &quot;</span>, pretty<span style="color: #AE81FF;">(</span>flux<span style="color: #66D9EF;">(</span>mean<span style="color: #66D9EF;">)</span> / flux<span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="color: #66D9EF;">AU</span>.to<span style="color: #A6E22E;">(</span>km<span style="color: #A6E22E;">)</span>.<span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">)</span>, precision = <span style="font-style: italic;">8</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
Which comes out to be an equivalent of 0.773% for the signal
uncertainty now!
</p>

<p>
This is a really nice improvement from the 3.3% we had before! It
should bring the signal uncertainty from ~4.5% down to close to 3%
probably.
</p>

<p>
This number was reproduced using <code>readOpacityFile</code> as well by (see
<code>journal.org</code> on <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-07-03 Mon 14:09&gt; </span></span> for more details):
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df1 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/org/resources/differential_flux_sun_earth_distance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_1AU.csv&quot;</span><span style="color: #AE81FF;">)</span>
  .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`<span style="color: #F92672;">type</span>` == <span style="color: #E6DB74;">&quot;Total flux&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df2 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/org/resources/differential_flux_sun_earth_distance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv&quot;</span><span style="color: #AE81FF;">)</span>
  .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`<span style="color: #F92672;">type</span>` == <span style="color: #E6DB74;">&quot;Total flux&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">max1AU </span>= df1<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;diffFlux&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">max</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">max0989AU </span>= df2<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;diffFlux&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">max</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Ratio of 1 AU to 0.989 AU = &quot;</span>, max0989AU / max1AU
</pre>
</div>
<p>
Bang on!
</p>
</div>
</li>
</ol>
</div>


<div class="outline-5" id="outline-container-sec:uncertain:window_thickness">
<h5 id="sec:uncertain:window_thickness"><span class="section-number-5">13.11.4.2.</span> Variation of window thickness</h5>
<div class="outline-text-5" id="text-sec:uncertain:window_thickness">
<p>
The thickness of the SiN windows will vary somewhat. Norcada says they
are within 10nm of 300nm thickness. Measurements done by Yevgen rather
imply variations on the O(50 nm). Difficult to know which numbers to
trust. The thickness goes into the transmission according to
Beer-Lambert&apos;s law. Does this imply quadratically?
</p>

<p>
I&apos;m a bit confused playing around with the Henke tool.
</p>

<p>
TODO: get a data file for 1 μm and for 2 μm and check what the
difference is.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df1 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/si_nitride_1_micron_5_to_10_kev.txt&quot;</span>, sep = <span style="color: #E6DB74;">&apos; &apos;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;TSq&quot;</span> ~ `<span style="color: #66D9EF;">Transmission</span>` * `<span style="color: #66D9EF;">Transmission</span>`<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df2 </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/si_nitride_2_micron_5_to_10_kev.txt&quot;</span>, sep = <span style="color: #E6DB74;">&apos; &apos;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= bind_rows<span style="color: #AE81FF;">(</span>df1, df2, id = <span style="color: #E6DB74;">&quot;id&quot;</span><span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Energy[eV]&quot;</span>, <span style="color: #E6DB74;">&quot;Transmission&quot;</span>, color = <span style="color: #E6DB74;">&quot;id&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  geom_line<span style="color: #AE81FF;">(</span>data = df1, aes = aes<span style="color: #66D9EF;">(</span>y = <span style="color: #E6DB74;">&quot;TSq&quot;</span><span style="color: #66D9EF;">)</span>, color = <span style="color: #E6DB74;">&quot;purple&quot;</span>, lineType = ltDashed<span style="color: #AE81FF;">)</span> + 
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/transmissions.pdf&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">compute the ratio</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfI </span>= inner_join<span style="color: #AE81FF;">(</span>df1.rename<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span><span style="color: #E6DB74;">&quot;T1&quot;</span> &lt;- <span style="color: #E6DB74;">&quot;Transmission&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>,
                     df2.rename<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span><span style="color: #E6DB74;">&quot;T2&quot;</span> &lt;- <span style="color: #E6DB74;">&quot;Transmission&quot;</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, by = <span style="color: #E6DB74;">&quot;Energy[eV]&quot;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Ratio&quot;</span> ~ `<span style="color: #66D9EF;">T1</span>` / `<span style="color: #66D9EF;">T2</span>`<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> dfI
ggplot<span style="color: #AE81FF;">(</span>dfI, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Energy[eV]&quot;</span>, <span style="color: #E6DB74;">&quot;Ratio&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> + geom_line<span style="color: #AE81FF;">()</span> + ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/ratio_transmissions_1_to_2_micron.pdf&quot;</span><span style="color: #AE81FF;">)</span>

</pre>
</div>

<p>
The resulting <code>Ratio</code> here kind of implies that we&apos;re missing
something….
Ah, no. The <code>Ratio</code> thing was a brain fart. Just squaring the 1μm
thing does indeed reproduce the 2μm case! All good here.
</p>

<p>
So how do we get the correct value then for e.g. 310nm when having
300nm?
</p>

<p>
If my intuition is correct (we&apos;ll check with a few other numbers in a
minute) then essentially the following holds:
</p>

<p>
\[
T_{xd} = (T_d)^x
\]
</p>

<p>
where <code>T_d</code> is the transmission of the material at thickness <code>d</code> and
we get the correct transmission for a different thickness that is a
multiple <code>x</code> of <code>d</code> by the given power-law relation.
</p>

<p>
Let&apos;s apply this to the files we have for the 300nm window and see
what we get if we also add 290 and 300 nm.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim, strformat, math

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readFile</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = readCsv<span style="color: #AE81FF;">(</span>fname, sep = <span style="color: #E6DB74;">&apos; &apos;</span><span style="color: #AE81FF;">)</span>
    .rename<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Energy / eV&quot;</span> &lt;- <span style="color: #E6DB74;">&quot;PhotonEnergy(eV)&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;E / keV&quot;</span> ~ c<span style="color: #E6DB74;">&quot;Energy / eV&quot;</span> / <span style="font-style: italic;">1000</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">sinDf </span>= <span style="color: #F92672;">readFile</span><span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/Si3N4_density_3.44_thickness_0.3microns.txt&quot;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;T310&quot;</span> ~ pow<span style="color: #A6E22E;">(</span>`<span style="color: #66D9EF;">Transmission</span>`, <span style="font-style: italic;">310</span>.<span style="font-style: italic;">0</span> / <span style="font-style: italic;">300</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;T290&quot;</span> ~ pow<span style="color: #A6E22E;">(</span>`<span style="color: #66D9EF;">Transmission</span>`, <span style="font-style: italic;">290</span>.<span style="font-style: italic;">0</span> / <span style="font-style: italic;">300</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">sin1Mu </span>= <span style="color: #F92672;">readFile</span><span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/Si3N4_density_3.44_thickness_1microns.txt&quot;</span><span style="color: #AE81FF;">)</span>
.mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;Transmission&quot;</span> ~ pow<span style="color: #A6E22E;">(</span>`<span style="color: #66D9EF;">Transmission</span>`, <span style="font-style: italic;">0</span>.<span style="font-style: italic;">3</span> / <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
sin1Mu<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;Setup&quot;</span><span style="color: #AE81FF;">]</span> = <span style="color: #E6DB74;">&quot;T300_from1μm&quot;</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">winDf </span>= sinDf.gather<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Transmission&quot;</span>, <span style="color: #E6DB74;">&quot;T310&quot;</span>, <span style="color: #E6DB74;">&quot;T290&quot;</span><span style="color: #66D9EF;">]</span>, key = <span style="color: #E6DB74;">&quot;Setup&quot;</span>, value = <span style="color: #E6DB74;">&quot;Transmission&quot;</span><span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>winDf, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;E / keV&quot;</span>, <span style="color: #E6DB74;">&quot;Transmission&quot;</span>, color = <span style="color: #E6DB74;">&quot;Setup&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  geom_line<span style="color: #AE81FF;">(</span>data = sin1Mu, lineType = ltDashed, color = <span style="color: #E6DB74;">&quot;purple&quot;</span><span style="color: #AE81FF;">)</span> +
  xlim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span>, outsideRange = <span style="color: #E6DB74;">&quot;drop&quot;</span><span style="color: #AE81FF;">)</span> +
  xMargin<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">02</span><span style="color: #AE81FF;">)</span> + yMargin<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">02</span><span style="color: #AE81FF;">)</span> +
  margin<span style="color: #AE81FF;">(</span>top = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> + 
  ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Impact of 10nm uncertainty on window thickness. Dashed line: 300nm transmission computed &quot;</span> &amp;
    <span style="color: #E6DB74;">&quot;from 1μm via power law T₃₀₀ = T₁₀₀₀^{0.3/1}&quot;</span><span style="color: #AE81FF;">)</span> + 
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/Figs/statusAndProgress/window_uncertainty_transmission.pdf&quot;</span>, width = <span style="font-style: italic;">853</span>, height = <span style="font-style: italic;">480</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
Plot
</p>


<figure id="org975f863">
<img src="./figs/home/basti/org/Figs/statusAndProgress/window_uncertainty_transmission.svg" class="org-svg" alt="window_uncertainty_transmission.svg" />

</figure>

<p>
shows us the impact on the transmission of the uncertainty on the
window thickness. In terms of such transmission the impact seems
almost negligible as long as it&apos;s small. However, to get an accurate
number, we should check the integrated effect on the axion flux after
conversion &amp; going through the window. That then takes into account
the energy dependence and thus gives us a proper number of the impact
on the signal.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> sequtils, math, unchained, datamancer
<span style="color: #F92672;">import</span> numericalnim <span style="color: #F92672;">except</span> linspace, cumSum
<span style="color: #75715E;"># </span><span style="color: #75715E;">import ./background_interpolation</span>

defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">type</span>
  <span style="color: #66D9EF;">Context</span> = <span style="color: #F92672;">object</span>
    integralBase: <span style="color: #66D9EF;">float</span>
    efficiencySpl: <span style="color: #66D9EF;">InterpolatorType</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•m⁻²•yr⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>cm⁻²<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readAxModel</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">upperBin </span>= <span style="font-style: italic;">10</span>.<span style="font-style: italic;">0</span>
  <span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">convert</span><span style="color: #AE81FF;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
    <span style="color: #FD971F;">result</span> = x.keV⁻¹•m⁻²•yr⁻¹.to<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">float</span>
  <span style="color: #FD971F;">result</span> = readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/CastData/ExternCode/AxionElectronLimit/axion_diff_flux_gae_1e-13_gagamma_1e-12.csv&quot;</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Energy / keV&quot;</span> ~ c<span style="color: #E6DB74;">&quot;Energy / eV&quot;</span> / <span style="font-style: italic;">1000</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span>,
            f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;Flux / keV⁻¹•cm⁻²•s⁻¹&quot;</span> ~ convert<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Flux / keV⁻¹ m⁻² yr⁻¹&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: c<span style="color: #E6DB74;">&quot;Energy / keV&quot;</span> &lt;= upperBin<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">detectionEff</span><span style="color: #AE81FF;">(</span>spl: <span style="color: #66D9EF;">InterpolatorType</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>, energy: keV<span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">window + gas</span>
  <span style="color: #F92672;">if</span> energy &lt; <span style="font-style: italic;">0</span>.<span style="font-style: italic;">001</span>.keV <span style="color: #F92672;">or</span> energy &gt; <span style="font-style: italic;">10</span>.<span style="font-style: italic;">0</span>.keV: <span style="color: #F92672;">return</span> <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
  <span style="color: #FD971F;">result</span> = spl.<span style="color: #F92672;">eval</span><span style="color: #AE81FF;">(</span>energy.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>    

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">initContext</span><span style="color: #AE81FF;">(</span>thickness: <span style="color: #66D9EF;">NanoMeter</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">Context</span> =

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">combEffDf </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/combined_detector_efficiencies.csv&quot;</span><span style="color: #AE81FF;">)</span>
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;Efficiency&quot;</span> ~ pow<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;300nm SiN&quot;</span><span style="color: #E6DB74;">)</span>, thickness / <span style="font-style: italic;">300</span>.nm<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span> <span style="color: #E6DB74;">## no-op if input is also 300nm</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">effSpl </span>= newCubicSpline<span style="color: #AE81FF;">(</span>combEffDf<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Energy [keV]&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toRawSeq,
                              combEffDf<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Efficiency&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toRawSeq<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">effective area included in raytracer</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">axData </span>= readAxModel<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">axModel </span>= axData
    .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Flux&quot;</span> ~ idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;Flux / keV⁻¹•cm⁻²•s⁻¹&quot;</span><span style="color: #A6E22E;">)</span> * detectionEff<span style="color: #A6E22E;">(</span>effSpl, idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;Energy / keV&quot;</span><span style="color: #E6DB74;">)</span>.keV<span style="color: #A6E22E;">)</span> <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">integralBase </span>= simpson<span style="color: #AE81FF;">(</span>axModel<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Flux&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toRawSeq,
                             axModel<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Energy / keV&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toRawSeq<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #66D9EF;">Context</span><span style="color: #AE81FF;">(</span>integralBase: integralBase,
                   efficiencySpl: effSpl<span style="color: #AE81FF;">)</span>

defUnit<span style="color: #AE81FF;">(</span>cm²<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">func</span> <span style="color: #A6E22E;">conversionProbability</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #E6DB74;">## the conversion probability in the CAST magnet (depends on g_aγ)</span>
  <span style="color: #E6DB74;">## simplified vacuum conversion prob. for small masses</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">B</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">0</span>.<span style="color: #66D9EF;">T</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">L</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">g_aγ </span>= 1e-<span style="font-style: italic;">12</span>.GeV⁻¹ <span style="color: #75715E;"># </span><span style="color: #75715E;">``</span><span style="color: #AE81FF;">must</span><span style="color: #75715E;">`` be same as reference in Context</span>
  <span style="color: #FD971F;">result</span> = pow<span style="color: #AE81FF;">(</span> <span style="color: #66D9EF;">(</span>g_aγ * <span style="color: #66D9EF;">B</span>.toNaturalUnit * <span style="color: #66D9EF;">L</span>.toNaturalUnit / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #AE81FF;">)</span>

defUnit<span style="color: #AE81FF;">(</span>cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>m⁻²•yr⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">expRate</span><span style="color: #AE81FF;">(</span>integralBase: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">trackingTime </span>= <span style="font-style: italic;">190</span>.h
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">areaBore </span>= π * <span style="color: #AE81FF;">(</span><span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span> * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span><span style="color: #AE81FF;">)</span>.cm²
  <span style="color: #FD971F;">result</span> = integralBase.cm⁻²•s⁻¹ * areaBore * trackingTime.to<span style="color: #AE81FF;">(</span>s<span style="color: #AE81FF;">)</span> * conversionProbability<span style="color: #AE81FF;">()</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ctx300 </span>= initContext<span style="color: #AE81FF;">(</span><span style="font-style: italic;">300</span>.nm<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">rate300 </span>= expRate<span style="color: #AE81FF;">(</span>ctx300.integralBase<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ctx310 </span>= initContext<span style="color: #AE81FF;">(</span><span style="font-style: italic;">310</span>.nm<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">rate310 </span>= expRate<span style="color: #AE81FF;">(</span>ctx310.integralBase<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">ctx290 </span>= initContext<span style="color: #AE81FF;">(</span><span style="font-style: italic;">290</span>.nm<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">rate290 </span>= expRate<span style="color: #AE81FF;">(</span>ctx290.integralBase<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Decrease: 300 ↦ 310 nm: &quot;</span>, rate310 / rate300
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Increase: 300 ↦ 290 nm: &quot;</span>, rate290 / rate300
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Total change: &quot;</span>, rate290 / rate310
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Averaged difference: &quot;</span>, <span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - rate310 / rate300<span style="color: #66D9EF;">)</span> + <span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - rate290 / rate300<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-sec:magnet_length_bore_uncertainty">
<h5 id="sec:magnet_length_bore_uncertainty"><span class="section-number-5">13.11.4.3.</span> Magnet length &amp; bore diameter</h5>
<div class="outline-text-5" id="text-sec:magnet_length_bore_uncertainty">
<p>
Length was reported to be 9.25m in the original CAST proposal,
compared to the since then reported 9.26m.
</p>

<p>
Conversion probability scales by length quadratically, so the change in
flux should thus also just be quadratic.
</p>

<p>
The bore diameter was also given as 42.5mm (iirc) initially, but later
as 43mm. The amount of flux scales by the area.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> math
<span style="color: #F92672;">echo</span> <span style="font-style: italic;">9</span>.<span style="font-style: italic;">25</span> / <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">Order 0.1% </span>
<span style="color: #F92672;">echo</span> pow<span style="color: #AE81FF;">(</span><span style="font-style: italic;">42</span>.<span style="font-style: italic;">5</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> / pow<span style="color: #AE81FF;">(</span><span style="font-style: italic;">43</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">Order 2.3% </span>
</pre>
</div>

<p>
With the conversion probability:
</p>

<p>
\[
P_{a↦γ, \text{vacuum}} = \left(\frac{g_{aγ} B L}{2} \right)^2 \left(\frac{\sin\left(\delta\right)}{\delta}\right)^2
\]
</p>

<p>
The change in conversion probability from a variation in magnet length
is thus (using the simplified form if δ is small:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
<span style="color: #F92672;">func</span> <span style="color: #A6E22E;">conversionProbability</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">L</span>: <span style="color: #66D9EF;">Meter</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #E6DB74;">## the conversion probability in the CAST magnet (depends on g_aγ)</span>
  <span style="color: #E6DB74;">## simplified vacuum conversion prob. for small masses</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">B</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">0</span>.<span style="color: #66D9EF;">T</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">g_aγ </span>= 1e-<span style="font-style: italic;">12</span>.GeV⁻¹ <span style="color: #75715E;"># </span><span style="color: #75715E;">``</span><span style="color: #AE81FF;">must</span><span style="color: #75715E;">`` be same as reference in Context</span>
  <span style="color: #FD971F;">result</span> = pow<span style="color: #AE81FF;">(</span> <span style="color: #66D9EF;">(</span>g_aγ * <span style="color: #66D9EF;">B</span>.toNaturalUnit * <span style="color: #66D9EF;">L</span>.toNaturalUnit / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">P26</span> = conversionProbability<span style="color: #AE81FF;">(</span><span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">P25</span> = conversionProbability<span style="color: #AE81FF;">(</span><span style="font-style: italic;">9</span>.<span style="font-style: italic;">25</span>.m<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">P27</span> = conversionProbability<span style="color: #AE81FF;">(</span><span style="font-style: italic;">9</span>.<span style="font-style: italic;">25</span>.m<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Change from 9.26 ↦ 9.25 m = &quot;</span>, <span style="color: #66D9EF;">P26</span> / <span style="color: #66D9EF;">P25</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Change from 9.25 ↦ 9.27 m = &quot;</span>, <span style="color: #66D9EF;">P27</span> / <span style="color: #66D9EF;">P25</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Relative change = &quot;</span>, <span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - <span style="color: #66D9EF;">P27</span> / <span style="color: #66D9EF;">P26</span><span style="color: #66D9EF;">)</span> + <span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - <span style="color: #66D9EF;">P25</span> / <span style="color: #66D9EF;">P26</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>
</pre>
</div>

<p>
And now for the area:
</p>

<p>
As it only goes into the expected rate by virtue of, well, being the
area we integrate over, we simply need to look at the change in area
from a change in bore radius. 
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">expRate</span><span style="color: #AE81FF;">(</span>integralBase: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">trackingTime </span>= <span style="font-style: italic;">190</span>.h
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">areaBore </span>= π * <span style="color: #AE81FF;">(</span><span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span> * <span style="font-style: italic;">2</span>.<span style="font-style: italic;">15</span><span style="color: #AE81FF;">)</span>.cm²
  <span style="color: #FD971F;">result</span> = integralBase.cm⁻²•s⁻¹ * areaBore * trackingTime.to<span style="color: #AE81FF;">(</span>s<span style="color: #AE81FF;">)</span> * conversionProbability<span style="color: #AE81FF;">()</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
defUnit<span style="color: #AE81FF;">(</span>MilliMeter²<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">boreArea</span><span style="color: #AE81FF;">(</span>diameter: <span style="color: #66D9EF;">MilliMeter</span><span style="color: #AE81FF;">)</span>: MilliMeter² =
  <span style="color: #FD971F;">result</span> = π * <span style="color: #AE81FF;">(</span>diameter / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>^<span style="font-style: italic;">2</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">areaD </span>= boreArea<span style="color: #AE81FF;">(</span><span style="font-style: italic;">43</span>.mm<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">areaS </span>= boreArea<span style="color: #AE81FF;">(</span><span style="font-style: italic;">42</span>.<span style="font-style: italic;">5</span>.mm<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">areaL </span>= boreArea<span style="color: #AE81FF;">(</span><span style="font-style: italic;">43</span>.<span style="font-style: italic;">5</span>.mm<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Change from 43 ↦ 42.5 mm = &quot;</span>, areaS / areaD
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Change from 43 ↦ 43.5 mm = &quot;</span>, areaL / areaD
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Relative change = &quot;</span>, <span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - areaL / areaD<span style="color: #66D9EF;">)</span> + <span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - areaS / areaD<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>
</pre>
</div>
</div>
</div>


<div class="outline-5" id="outline-container-sec:window_rotation_uncertainty">
<h5 id="sec:window_rotation_uncertainty"><span class="section-number-5">13.11.4.4.</span> Window rotation &amp; alignment precision <code>[2/2]</code></h5>
<div class="outline-text-5" id="text-sec:window_rotation_uncertainty">
<p>
Rotation of the window. Initially we assumed that the rotation was
different in the two different data taking periods.
</p>

<p>
We can check the rotation by looking at the occupancy runs taken in
the 2017 dataset and in the 2018 dataset.
</p>

<p>
The 2017 occupancy (filtered to only use events in eccentricity 1 -
1.4) is
</p>


<figure id="org61b2a4d">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/occupancy_clusters_run83_187_chip3_ckQuantile_80.0_region_crAll_eccentricity_1.0_1.3_applyAll_true_.svg" class="org-svg" alt="occupancy_clusters_run83_187_chip3_ckQuantile_80.0_region_crAll_eccentricity_1.0_1.3_applyAll_true_.svg" />

</figure>

<p>
and for 2018:
</p>


<figure id="orgd59425b">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/occupancy_clusters_run239_304_chip3_ckQuantile_80.0_region_crAll_eccentricity_1.0_1.3_applyAll_true.svg" class="org-svg" alt="occupancy_clusters_run239_304_chip3_ckQuantile_80.0_region_crAll_eccentricity_1.0_1.3_applyAll_true.svg" />

</figure>

<p>
They imply that the angle was indeed the same (compare with the sketch
of our windows in fig. [BROKEN LINK: 300nm_sin_norcada_window_layout]). However,
there seems to be a small shift in y between the two, which seems hard
to explain. Such a shift <b>only</b> makes sense (unless I&apos;m missing
something!) if there is a shift between the <b>chip</b> and the <b>window</b>,
but not for any kind of installation shift or shift in the position of
the 55Fe source. I suppose a slight change in how the window is
mounted on the detector can already explain it? This is &lt; 1mm after
all.
</p>

<p>
In terms of the rotation angle, we&apos;ll just read it of using Inkscape.
</p>

<p>
It comes out to pretty much <span class="underline">exactly</span> 30°, see
fig. <a href="#fig:window_rotation">24</a>. I suppose this makes sense given the number
of screws (6?). Still, this implies that the window was mounted
perfectly aligned with some line relative to 2 screws. Not that it
matters.
</p>


<figure id="fig:window_rotation">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/window_rotation_2018.png" alt="window_rotation_2018.png" />

<figcaption>Figure 24: <span class="figure-number">Figure 97: </span>Measurement of the rotation angle of the window in 2018 data taking (2017 is the same) using Inkscape. Comes out to ~30° (with maybe 0.5° margin for error, aligned for exactly 30° for the picture, but some variation around that all looks fine).</figcaption>
</figure>

<p>
Need to check the number used in the raytracing code. There we have
(also see discussion with Johanna in Discord):
</p>
<div class="org-src-container">
<pre class="src src-nim">  <span style="color: #F92672;">case</span> wyKind
  <span style="color: #F92672; font-style: italic;">of</span> wy2017:
    <span style="color: #FD971F;">result</span> = degToRad<span style="color: #AE81FF;">(</span><span style="font-style: italic;">10</span>.<span style="font-style: italic;">8</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672; font-style: italic;">of</span> wy2018:
    <span style="color: #FD971F;">result</span> = degToRad<span style="color: #AE81FF;">(</span><span style="font-style: italic;">71</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672; font-style: italic;">of</span> wyIAXO:
    <span style="color: #FD971F;">result</span> = degToRad<span style="color: #AE81FF;">(</span><span style="font-style: italic;">20</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">who knows</span>
</pre>
</div>
<p>
so an angle of 71.5 (2018) and 10.8 (2017). Very different from the
number we get in Inkscape based on the calibration runs.
</p>

<p>
She used the following plot:
</p>


<figure id="orgc3ef73b">
<img src="./figs/home/basti/org/Talks/CCM_2018_Apr/figs/xray_finger_side.svg" class="org-svg" alt="xray_finger_side.svg" />

</figure>

<p>
to extract the angles.
</p>

<p>
The impact of this on the signal only depends on where the strongbacks
are compared to the axion image.
</p>

<p>
Fig. <a href="#fig:axion_image_71_5deg">26</a> shows the axion image for the rotation of
71.5° (Johanna from X-ray finger) and fig. <a href="#fig:axion_image_30deg">27</a> shows the same for a rotation of
30° (our measurement). The 30° case matches nicely with the extraction
of fig. <a href="#fig:window_rotation">24</a>.
</p>


<figure id="fig:axion_image_71_5deg">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/axion_image_2018_71_5deg.png" alt="axion_image_2018_71_5deg.png" />

<figcaption>Figure 26: <span class="figure-number">Figure 98: </span>Axion image for a window setup rotated to 71.5° (the number Johanna read off from the X-ray finger run).</figcaption>
</figure>


<figure id="fig:axion_image_30deg">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/axion_image_2018_30deg.png" alt="axion_image_2018_30deg.png" />

<figcaption>Figure 27: <span class="figure-number">Figure 99: </span>Axion image for a window setup rotated to 30° (the number we read off from from the calibration runs).</figcaption>
</figure>


<p>
From here there are 2 things to do:
</p>
<ul class="org-ul">
<li class="on"><code>[X]</code> reconstruct the X-ray finger runs &amp; check the rotation of those
again using the same occupancy plots as for the calibration runs.</li>
<li class="on"><code>[X]</code> compute the integrated signal for the 71.5°, 30° and 30°±0.5°
cases and see how the signal differs. The latter will be the number
for the systematic we&apos;ll use. We do that by just summing the
raytracing output.</li>
</ul>

<p>
To do the latter, we need to add an option to write the CSV files in
the raytracer first.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> datamancer

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">print</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">hmap </span>= readCsv<span style="color: #AE81FF;">(</span>fname<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = hmap<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;photon flux&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.sum
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f71 </span>= print<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/axion_images_systematics/axion_image_2018_71_5deg.csv&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f30 </span>= print<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/axion_images_systematics/axion_image_2018_30deg.csv&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f29 </span>= print<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/axion_images_systematics/axion_image_2018_29_5deg.csv&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">f31 </span>= print<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/home/basti/org/resources/axion_images_systematics/axion_image_2018_30_5deg.csv&quot;</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">echo</span> f71
<span style="color: #F92672;">echo</span> f30
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Ratio : &quot;</span>, f30 / f71
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Ratio f29 / f31 &quot;</span>, f29 / f31
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Difference &quot;</span>, <span style="color: #AE81FF;">(</span><span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - <span style="color: #A6E22E;">(</span>f29/f30<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span> + <span style="color: #F92672;">abs</span><span style="color: #66D9EF;">(</span><span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span> - <span style="color: #A6E22E;">(</span>f31/f30<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span>
</pre>
</div>

<p>
Now on to the reconstruction of the X-ray finger run.
</p>

<p>
I copied the X-ray finger runs from tpc19 over to
<a href="./../CastData/data/XrayFingerRuns/">./../CastData/data/XrayFingerRuns/</a>. The run of interest is mainly
the run 189, as it&apos;s the run done with the detector installed as in
2017/18 data taking.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> /dev/shm <span style="color: #75715E;"># </span><span style="color: #75715E;">store here for fast access &amp; temporary</span>
cp ~/CastData/data/XrayFingerRuns/XrayFingerRun2018.tar.gz .
tar xzf XrayFingerRun2018.tar.gz
raw_data_manipulation -p Run_189_180420-09-53 --runType xray --out xray_raw_run189.h5
reconstruction -i xray_raw_run189.h5 --out xray_reco_run189.h5 <span style="color: #75715E;"># </span><span style="color: #75715E;">make sure `config.toml` for reconstruction uses `default` clustering!</span>
reconstruction -i xray_reco_run189.h5 --only_charge
reconstruction -i xray_reco_run189.h5 --only_gas_gain
reconstruction -i xray_reco_run189.h5 --only_energy_from_e
plotData --h5file xray_reco_run189.h5 --runType=rtCalibration -b bGgPlot --ingrid --occupancy --config plotData.toml
</pre>
</div>

<p>
which gives us the following plot:
</p>


<figure id="fig:occupancy_cluster_xray_finger_run_189">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/occupancy_clusters_run189_chip3_ckQuantile_95.0_region_crAll_eccentricity_1.0_1.3_applyAll_true.svg" class="org-svg" alt="occupancy_clusters_run189_chip3_ckQuantile_95.0_region_crAll_eccentricity_1.0_1.3_applyAll_true.svg" />

<figcaption>Figure 28: <span class="figure-number">Figure 100: </span>Occupancies of cluster centers of the X-ray finger run (189) in 2018. Shows the same rotation as the calibration runs here.</figcaption>
</figure>

<p>
With many more plots here:
<a href="./../org/Figs/statusAndProgress/xrayFingerRun/run189/">./../org/Figs/statusAndProgress/xrayFingerRun/run189/</a>
</p>

<p>
Also see the relevant section in sec. <a href="./cast.html#sec:cast:alignment">10.2</a>.
</p>


<p>
Using <code>TimepixAnalysis/Tools/printXyDataset</code> we can now compute the
center of the X-ray finger run.
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> ~/CastData/ExternCode/TimepixAnalysis/Tools/
./printXyDataset -f /dev/shm/xray_reco_run189.h5 -c 3 -r 189 <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --dset centerX --reco <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;eccentricity&quot;, 0.9, 1.4)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;centerX&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;centerY&quot;, 3.0, 11.0)&apos;</span>

./printXyDataset -f /dev/shm/xray_reco_run189.h5 -c 3 -r 189 <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --dset centerY --reco <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;eccentricity&quot;, 0.9, 1.4)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;centerX&quot;, 3.0, 11.0)&apos;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
                 --cuts <span style="color: #E6DB74;">&apos;(&quot;centerY&quot;, 3.0, 11.0)&apos;</span>
</pre>
</div>

<p>
So we get a mean of:
</p>
<ul class="org-ul">
<li>centerX: 7.658</li>
<li>centerY: 6.449</li>
</ul>

<p>
meaning we are ~0.5 mm away from the center in either direction. Given
that there is distortion due to the magnet optic, uncertainty about
the location of X-ray finger &amp; emission characteristic, using a
variation of 0.5mm seems reasonable.
</p>

<p>
This also matches more or less the laser alignment we did initially,
see fig. <a href="#fig:cast_laser_alignment_target">29</a>.
</p>


<figure id="fig:cast_laser_alignment_target">
<img src="./figs/home/basti/org/Figs/statusAndProgress/CAST_detector_laser_alignment_target.jpg" alt="CAST_detector_laser_alignment_target.jpg" />

<figcaption>Figure 29: <span class="figure-number">Figure 101: </span>Laser alignment using target on flange at CAST. Visible deviation is ~0.5mm more or less.</figcaption>
</figure>
</div>

<ol class="org-ol">
<li><a id="org9024d90"> </a><span class="todo TODO">TODO</span> Question about signal &amp; window<br />
<div class="outline-text-6" id="text-13-11-4-4-1">
<p>
One thing we currently do not take into account is that when varying
the signal position using the nuisance parameters, we move the window
strongback <b>with</b> the position…
</p>

<p>
In principle we&apos;re not allowed to do that. The strongbacks are part of
the detector &amp; not the signal (but are currently convolved into the
image).
</p>

<p>
The strongback position depends on the detector mounting precision
only.
</p>

<p>
So if the main peak was exactly on the strongback, we&apos;d barely see anything!
</p>
</div>
</li>
</ol>
</div>

<div class="outline-5" id="outline-container-org1eb104f">
<h5 id="org1eb104f"><span class="section-number-5">13.11.4.5.</span> Integration routines for nuisance parameters</h5>
<div class="outline-text-5" id="text-13-11-4-5">
<p>
For performance reasons we cannot integrate out the nuisance
parameters using the most sophisticated algorithms. Maybe in the end
we could assign a systematic by computing a few &quot;accurate&quot;
integrations (e.g. integrating out \(ϑ_x\) and \(ϑ_y\)) with adaptive
gauss and then with our chosen method and compare the result on the
limit? Could just be a &quot;total&quot; uncertainty on the limit w/o changing
any parameters. 
</p>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-org28f2717">
<h4 id="org28f2717"><span class="section-number-4">13.11.5.</span> Detector behavior <code>[0/1]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-5">
<ul class="org-ul">
<li class="off"><code>[ ]</code> drift in # hits in ⁵⁵Fe. &quot;Adaptive gas gain&quot; tries to minimize this,
maybe variation of mean energy over time after application a measure for uncertainty?
-&gt; should mainly have an effect on <b>software signal efficiency</b>.
<ul class="org-ul">
<li>goes into S of limit likelihood (ε), which is currently assumed a
constant number</li>
</ul></li>

<li class="off"><code>[ ]</code> veto random coincidences</li>
</ul>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:random_coincidences">
<h5 id="sec:uncertain:random_coincidences"><span class="section-number-5">13.11.5.1.</span> Random coincidences</h5>
<div class="outline-text-5" id="text-sec:uncertain:random_coincidences">
<p>
Come up with equation to compute rate of random coincidences.
</p>

<p>
Inputs:
</p>
<ul class="org-ul">
<li>area of chip</li>
<li>rate of cosmics</li>
<li>shutter length</li>
<li>physical time scale of background events</li>
</ul>

<p>
to compute rate of random coincidences.
</p>

<p>
Leads to effective reduction in live data taking time (increased dead
time). 
</p>
</div>
</div>
</div>


<div class="outline-4" id="outline-container-org1b1858d">
<h4 id="org1b1858d"><span class="section-number-4">13.11.6.</span> Background <code>[0/2]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-6">
<ul class="org-ul">
<li class="off"><code>[ ]</code> background interpolation
<ul class="org-ul">
<li>we already did: study of statistical uncertainty (both MC as well
as via error propagation) 
<ul class="org-ul">
<li class="on"><code>[X]</code> extract from error propagation code
unclear what to do with these numbers!</li>
</ul></li>
</ul></li>
<li class="off"><code>[ ]</code> septem veto can suffer from uncertainties due to possible random
coincidences of events on outer chip that veto a center event, which
are not actually correlated.
In our current application of it, this implies a) a lower background
rate, but b) a lower software signal efficiency <b>as we might also
remove real photons</b>. So its effect is on ε as ell.
<ul class="org-ul">
<li class="off"><code>[ ]</code> think about random coincidences, derive some formula similar
to lab course to compute chance</li>
</ul></li>
</ul>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:background_interpolation">
<h5 id="sec:uncertain:background_interpolation"><span class="section-number-5">13.11.6.1.</span> Background interpolation <code>[0/1]</code></h5>
<div class="outline-text-5" id="text-sec:uncertain:background_interpolation">
<p>
Ref: <a href="./limit.html#sec:background_interpolation_uncertainty">13.10.8.4</a>
and <code>ntangle</code> this file and run
<code>/tmp/background_interpolation_error_propagation.nim</code> for the
background interpolation with <code>Measuremancer</code> error propagation.
</p>

<p>
For an input of 8 clusters in a search radius around a point we get
numbers such as:
<code>Normalized value (gauss) : 6.08e-06 ± 3.20e-06 CentiMeter⁻²•Second⁻¹</code>
so an error that is almost 50% of the input.
</p>

<p>
However, keep in mind that this is for a small area around the
specific point. Just purely from Poisson statistics we expect an
uncertainty of 2.82 for 8 events
\[
ΔN = √8 = 2.82
\]
</p>

<p>
As such this makes sense (the number is larger due to the gaussian
nature of the distance calculation etc.) and just being a weighted sum
of <code>1 ± 1</code> terms error propagated.
</p>

<p>
If we compute the same for a larger number of points, the error should
go down, which can be seen comparing
fig. <a href="background_uncertainty_mc_all_samplers_corrected">18</a> with
fig. <a href="background_uncertainty_mc_all_samplers_uncorrected_artificial_statistics">19</a>
(where the latter has artificially increased statistics).
</p>

<p>
As this is purely a statistical effect, I&apos;m not sure how to quantify
any kind of systematic errors.
</p>

<p>
The systematics come into play, due to the:
</p>
<ul class="org-ul">
<li>choice of radius &amp; sigma</li>
<li>choice of gaussian weighting</li>
<li>choice of &quot;energy radius&quot;</li>

<li class="off"><code>[ ]</code> look at background interpolation uncertainty section linked
above. Modify to also include a section about a flat model that
varies the different parameters going into the interpolation.</li>
<li class="off"><code>[ ]</code> use existing code to compute a systematic based on the kind of
background model. Impact of background hypothesis?</li>
</ul>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-org5f46c25">
<h4 id="org5f46c25"><span class="section-number-4">13.11.7.</span> Energy calibration, likelihood method <code>[0/1]</code>   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-11-7">
<ul class="org-ul">
<li class="off"><code>[ ]</code> the energy calibration as a whole has many uncertainties (due to
detector variation, etc.)
<ul class="org-ul">
<li>gas gain time binning:
<ul class="org-ul">
<li class="off"><code>[ ]</code> compute everything up to background rate for no time binning, 90
min and maybe 1 or 2 other values. Influence on σ<sub>b</sub> is the
change in background that we see from this (will be a lot of
work, but useful to make things more reproducible).</li>
</ul></li>
<li class="off"><code>[ ]</code> compute energy of 55Fe peaks after energy
calibration. Variation gives indication for systematic influence.</li>
</ul></li>
</ul>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:gas_gain_binning">
<h5 id="sec:uncertain:gas_gain_binning"><span class="section-number-5">13.11.7.1.</span> Gas gain time binning</h5>
<div class="outline-text-5" id="text-sec:uncertain:gas_gain_binning">
<p>
We need to investigate the impact of the gas gain binning on the
background rate. How do we achieve that?
</p>

<p>
Simplest approach:
</p>
<ol class="org-ol">
<li>Compute gas gain slices for different cases (no binning, 30 min
binning, 90 min binning, 240 min binning ?)</li>
<li>calculate energy based on the used gas gain binning</li>
<li>compute the background rate for each case</li>
<li>compare amount of background after that.</li>
</ol>

<p>
Question:
Do we need to recompute the gas gain for the calibration data as well?
Yes, as the gas gain slices directly go into the &apos;gain fit&apos; that needs
to be done in order to compute the energy for any cluster.
</p>

<p>
So, the whole process is only made complicated by the fact that we
need to change the <code>config.toml</code> file in between runs. In the future
this should be a CL argument. For the time being, we can use the same
approach as in
<code>/home/basti/CastData/ExternCode/TimepixAnalysis/Tools/backgroundRateDifferentEffs/backgroundRateDifferentEfficiencies.nim</code>
where we simply read the toml file, rewrite the single line and write
it back.
</p>

<p>
Let&apos;s write a script that does mainly steps 1 to 3 for us.
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> shell, strformat, strutils, sequtils, os

<span style="color: #75715E;"># </span><span style="color: #75715E;">an interval of 0 implies _no_ gas gain interval, i.e. full run</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">intervals </span>= <span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>, <span style="font-style: italic;">30</span>, <span style="font-style: italic;">90</span>, <span style="font-style: italic;">240</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">Tmpl</span> = <span style="color: #E6DB74;">&quot;</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">Runs</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">_Reco.h5&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">Path</span> = <span style="color: #E6DB74;">&quot;/home/basti/CastData/data/systematics/&quot;</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">TomlFile</span> = <span style="color: #E6DB74;">&quot;/home/basti/CastData/ExternCode/TimepixAnalysis/Analysis/ingrid/config.toml&quot;</span>    

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">rewriteToml</span><span style="color: #AE81FF;">(</span>path: <span style="color: #66D9EF;">string</span>, interval: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">## rewrites the given TOML file in the `</span><span style="color: #AE81FF;">path</span><span style="color: #E6DB74;">` to use the `</span><span style="color: #AE81FF;">interval</span><span style="color: #E6DB74;">`</span>
  <span style="color: #E6DB74;">## instead of the existing value</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">data </span>= <span style="color: #F92672;">readFile</span><span style="color: #AE81FF;">(</span>path<span style="color: #AE81FF;">)</span>.splitLines
  <span style="color: #F92672;">for</span> l <span style="color: #F92672;">in</span> <span style="color: #F92672;">mitems</span><span style="color: #AE81FF;">(</span>data<span style="color: #AE81FF;">)</span>:
    <span style="color: #F92672;">if</span> interval == <span style="font-style: italic;">0</span> <span style="color: #F92672;">and</span> l.startsWith<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;fullRunGasGain&quot;</span><span style="color: #AE81FF;">)</span>:
      l = <span style="color: #E6DB74;">&quot;fullRunGasGain = true&quot;</span>
    <span style="color: #F92672;">elif</span> interval != <span style="font-style: italic;">0</span> <span style="color: #F92672;">and</span> l.startsWith<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;fullRunGasGain&quot;</span><span style="color: #AE81FF;">)</span>:
      l = <span style="color: #E6DB74;">&quot;fullRunGasGain = false&quot;</span>
    <span style="color: #F92672;">elif</span> interval != <span style="font-style: italic;">0</span> <span style="color: #F92672;">and</span> l.startsWith<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;gasGainInterval&quot;</span><span style="color: #AE81FF;">)</span>:
      l = <span style="color: #E6DB74;">&quot;gasGainInterval = &quot;</span> &amp; $interval
  <span style="color: #F92672;">writeFile</span><span style="color: #AE81FF;">(</span>path, data.join<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;\n&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeGasGainSlices</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, interval: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>res, err, code<span style="color: #AE81FF;">)</span> = shellVerboseErr:
    one:
      cd ~/<span style="color: #66D9EF;">CastData</span>/data/systematics
      reconstruction <span style="color: #AE81FF;">(</span>$fname<span style="color: #AE81FF;">)</span> <span style="color: #E6DB74;">&quot;--only_gas_gain&quot;</span>
  <span style="color: #F92672;">if</span> code != <span style="font-style: italic;">0</span>:
    <span style="color: #F92672;">raise</span> <span style="color: #F92672;">newException</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Exception</span>, <span style="color: #E6DB74;">&quot;Error calculating gas gain for interval &quot;</span> &amp; $interval<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeGasGainFit</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, interval: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>res, err, code<span style="color: #AE81FF;">)</span> = shellVerboseErr:
    one:
      cd ~/<span style="color: #66D9EF;">CastData</span>/data/systematics
      reconstruction <span style="color: #AE81FF;">(</span>$fname<span style="color: #AE81FF;">)</span> <span style="color: #E6DB74;">&quot;--only_gain_fit&quot;</span>
  <span style="color: #F92672;">if</span> code != <span style="font-style: italic;">0</span>:
    <span style="color: #F92672;">raise</span> <span style="color: #F92672;">newException</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Exception</span>, <span style="color: #E6DB74;">&quot;Error calculating gas gain fit for interval &quot;</span> &amp; $interval<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeEnergy</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, interval: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>res, err, code<span style="color: #AE81FF;">)</span> = shellVerboseErr:
    one:
      cd ~/<span style="color: #66D9EF;">CastData</span>/data/systematics
      reconstruction <span style="color: #AE81FF;">(</span>$fname<span style="color: #AE81FF;">)</span> <span style="color: #E6DB74;">&quot;--only_energy_from_e&quot;</span>
  <span style="color: #F92672;">if</span> code != <span style="font-style: italic;">0</span>:
    <span style="color: #F92672;">raise</span> <span style="color: #F92672;">newException</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Exception</span>, <span style="color: #E6DB74;">&quot;Error calculating energy for interval &quot;</span> &amp; $interval<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeLikelihood</span><span style="color: #AE81FF;">(</span>f, outName: <span style="color: #66D9EF;">string</span>, interval: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">args </span>= <span style="color: #AE81FF;">{</span> <span style="color: #E6DB74;">&quot;--altCdlFile&quot;</span> : <span style="color: #E6DB74;">&quot;~/CastData/data/CDL_2019/calibration-cdl-2018.h5&quot;</span>,
               <span style="color: #E6DB74;">&quot;--altRefFile&quot;</span> : <span style="color: #E6DB74;">&quot;~/CastData/data/CDL_2019/XrayReferenceFile2018.h5&quot;</span>,
               <span style="color: #E6DB74;">&quot;--cdlYear&quot;</span> : <span style="color: #E6DB74;">&quot;2018&quot;</span>,
               <span style="color: #E6DB74;">&quot;--region&quot;</span> : <span style="color: #E6DB74;">&quot;crGold&quot;</span><span style="color: #AE81FF;">}</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">argStr </span>= args.mapIt<span style="color: #AE81FF;">(</span>it<span style="color: #66D9EF;">[</span><span style="font-style: italic;">0</span><span style="color: #66D9EF;">]</span> &amp; <span style="color: #E6DB74;">&quot; &quot;</span> &amp; it<span style="color: #66D9EF;">[</span><span style="font-style: italic;">1</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>.join<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot; &quot;</span><span style="color: #AE81FF;">)</span>           
  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>res, err, code<span style="color: #AE81FF;">)</span> = shellVerboseErr:
    one:
      cd ~/<span style="color: #66D9EF;">CastData</span>/data/systematics
      likelihood <span style="color: #AE81FF;">(</span>$f<span style="color: #AE81FF;">)</span> <span style="color: #E6DB74;">&quot;--h5out&quot;</span> <span style="color: #AE81FF;">(</span>$outName<span style="color: #AE81FF;">)</span> <span style="color: #AE81FF;">(</span>$argStr<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> code != <span style="font-style: italic;">0</span>:
    <span style="color: #F92672;">raise</span> <span style="color: #F92672;">newException</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Exception</span>, <span style="color: #E6DB74;">&quot;Error computing likelihood cuts for interval &quot;</span> &amp; $interval<span style="color: #AE81FF;">)</span>

<span style="color: #75715E;">#</span><span style="color: #75715E;">proc plotBackgroundRate(f1, f2: string, eff: float) =</span>
<span style="color: #75715E;">#  </span><span style="color: #75715E;">let suffix = &amp;&quot;_eff_{eff}&quot;</span>
<span style="color: #75715E;">#  </span><span style="color: #75715E;">let (res, err, code) = shellVerboseErr:</span>
<span style="color: #75715E;">#    </span><span style="color: #75715E;">one:</span>
<span style="color: #75715E;">#      </span><span style="color: #75715E;">cd ~/CastData/ExternCode/TimepixAnalysis/Plotting/plotBackgroundRate</span>
<span style="color: #75715E;">#      </span><span style="color: #75715E;">./plotBackgroundRate ($f1) ($f2) &quot;--suffix&quot; ($suffix)</span>
<span style="color: #75715E;">#      </span><span style="color: #75715E;">./plotBackgroundRate ($f1) ($f2) &quot;--separateFiles --suffix&quot; ($suffix)</span>
<span style="color: #75715E;">#  </span><span style="color: #75715E;">if code != 0:</span>
<span style="color: #75715E;">#    </span><span style="color: #75715E;">raise newException(Exception, &quot;Error plotting background rate for eff &quot; &amp; $eff)</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">years </span>= <span style="color: #AE81FF;">[</span><span style="font-style: italic;">2017</span>, <span style="font-style: italic;">2018</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">calibs </span>= years.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Tmpl</span> % <span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Calibration&quot;</span>, $it<span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">backs </span>= years.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Tmpl</span> % <span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Data&quot;</span>, $it<span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
    
copyFile<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">TomlFile</span>, <span style="color: #E6DB74;">&quot;/tmp/toml_file.backup&quot;</span><span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">for</span> interval <span style="color: #F92672;">in</span> intervals:    
  <span style="color: #E6DB74;">## rewrite toml file</span>
  rewriteToml<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">TomlFile</span>, interval<span style="color: #AE81FF;">)</span>
  <span style="color: #E6DB74;">## compute new gas gain for new interval for all files</span>
  <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> concat<span style="color: #AE81FF;">(</span>calibs, backs<span style="color: #AE81FF;">)</span>:
    computeGasGainSlices<span style="color: #AE81FF;">(</span>f, interval<span style="color: #AE81FF;">)</span>
  <span style="color: #E6DB74;">## use gas gain slices to compute gas gain fit</span>
  <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> calibs:
    computeGasGainFit<span style="color: #AE81FF;">(</span>f, interval<span style="color: #AE81FF;">)</span>
  <span style="color: #E6DB74;">## compute energy based on new gain fit</span>
  <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> concat<span style="color: #AE81FF;">(</span>calibs, backs<span style="color: #AE81FF;">)</span>:
    computeEnergy<span style="color: #AE81FF;">(</span>f, interval<span style="color: #AE81FF;">)</span>
  <span style="color: #E6DB74;">## compute likelihood based on new energies</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">logFs </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">]()</span>
  <span style="color: #F92672;">for</span> b <span style="color: #F92672;">in</span> backs:
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">yr </span>= <span style="color: #F92672;">if</span> <span style="color: #E6DB74;">&quot;2017&quot;</span> <span style="color: #F92672;">in</span> b: <span style="color: #E6DB74;">&quot;2017&quot;</span> <span style="color: #F92672;">else</span>: <span style="color: #E6DB74;">&quot;2018&quot;</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fname </span>= &amp;<span style="color: #E6DB74;">&quot;out/lhood_{yr}_interval_{interval}.h5&quot;</span>
    logFs.<span style="color: #F92672;">add</span> fname
    <span style="color: #E6DB74;">## XXX: need to redo likelihood computation!!</span>
    computeLikelihood<span style="color: #AE81FF;">(</span>b, fname, interval<span style="color: #AE81FF;">)</span>
<span style="color: #E6DB74;">## plot background rate for all combined? or just plot cluster centers? can all be done later...</span>
<span style="color: #75715E;">#</span><span style="color: #75715E;">plotBackgroundRate(log, eff)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> shell, strformat, strutils, sequtils, os

<span style="color: #75715E;"># </span><span style="color: #75715E;">an interval of 0 implies _no_ gas gain interval, i.e. full run</span>
<span style="color: #F92672;">const</span> <span style="color: #FD971F;">intervals </span>= <span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span>, <span style="font-style: italic;">30</span>, <span style="font-style: italic;">90</span>, <span style="font-style: italic;">240</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">Tmpl</span> = <span style="color: #E6DB74;">&quot;</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">Runs</span><span style="color: #F92672;">$#</span><span style="color: #E6DB74;">_Reco.h5&quot;</span>
<span style="color: #F92672;">echo</span> <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Tmpl</span> % <span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;Data&quot;</span>, <span style="color: #E6DB74;">&quot;2017&quot;</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>.extractFilename
</pre>
</div>

<p>
The resulting files are found in
<a href="./../CastData/data/systematics/out/">./../CastData/data/systematics/out/</a>
or
<a href="./../CastData/data/systematics/">./../CastData/data/systematics/</a>
on my laptop.
</p>

<p>
Let&apos;s extract the number of clusters found on the center chip (gold
region) for each of the intervals:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> ~/CastData/data/systematics
<span style="color: #F92672;">for</span> i<span style="color: #F92672;"> in</span> 0 30 90 240 
  <span style="color: #F92672;">do </span><span style="color: #F92672;">echo</span> Inteval: $<span style="color: #FD971F;">i</span>
     extractClusterInfo -f lhood_2017_interval_$<span style="color: #FD971F;">i</span>.h5 --short --region crGold
     extractClusterInfo -f lhood_2018_interval_$<span style="color: #FD971F;">i</span>.h5 --short --region crGold     
<span style="color: #F92672;">done</span>
</pre>
</div>

<p>
The numbers pretty much speak for themselves.
</p>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">let</span> <span style="color: #FD971F;">nums </span>= <span style="color: #AE81FF;">{</span> <span style="font-style: italic;">0</span> : <span style="font-style: italic;">497</span> + <span style="font-style: italic;">244</span>,
             <span style="font-style: italic;">30</span> : <span style="font-style: italic;">499</span> + <span style="font-style: italic;">244</span>,
             <span style="font-style: italic;">90</span> : <span style="font-style: italic;">500</span> + <span style="font-style: italic;">243</span>,
             <span style="font-style: italic;">240</span> : <span style="font-style: italic;">497</span> + <span style="font-style: italic;">244</span> <span style="color: #AE81FF;">}</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">reference is 90</span>
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">num90 </span>= nums<span style="color: #AE81FF;">[</span><span style="font-style: italic;">2</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">minVal </span>= <span style="color: #66D9EF;">Inf</span>
<span style="color: #F92672;">var</span> <span style="color: #FD971F;">maxVal </span>= <span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>
<span style="color: #F92672;">for</span> num <span style="color: #F92672;">in</span> nums:
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">rat </span>= num<span style="color: #AE81FF;">[</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span> / num90
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Ratio of &quot;</span>, num, <span style="color: #E6DB74;">&quot; = &quot;</span>, rat
  minVal = <span style="color: #F92672;">min</span><span style="color: #AE81FF;">(</span>minVal, rat<span style="color: #AE81FF;">)</span>
  maxVal = <span style="color: #F92672;">max</span><span style="color: #AE81FF;">(</span>maxVal, rat<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Deviation: &quot;</span>, maxVal - minVal
</pre>
</div>

<p>
<b>NOTE</b>: The one &apos;drawback&apos; of this approach taken here is the following:
the CDL data was <span class="underline">not</span> reconstructed using the changed gas gain
data. <b>However</b> that is much less important, as we assume constant
gain over the CDL runs anyway more or less / want to pick the most
precise description of our data!
</p>
</div>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:cdl_morphing">
<h5 id="sec:uncertain:cdl_morphing"><span class="section-number-5">13.11.7.2.</span> Interpolation of reference distributions (CDL morphing) <code>[/]</code></h5>
<div class="outline-text-5" id="text-sec:uncertain:cdl_morphing">
<p>
We already did the study of the variation in the interpolation for the
reference distributions. To estimate the systematic uncertainty
related to that, we should simply look at the computation of the
&quot;intermediate&quot; distributions again and compare the real numbers to the
interpolated ones. The deviation can be done per bin. The average &amp;
some quantiles should be a good number to refer to as a systematic.
</p>

<p>
The <code>cdlMorphing</code> tool
<a href="./../CastData/ExternCode/TimepixAnalysis/Tools/cdlMorphing/cdlMorphing.nim">./../CastData/ExternCode/TimepixAnalysis/Tools/cdlMorphing/cdlMorphing.nim</a>
is well suited to this. We will compute the difference between the
morphed and real data for each bin &amp; sum the squares for each
target/filter (those that are morphed, so not the outer two of
course).
</p>

<p>
Running the tool now yields the following output:
</p>
<pre class="example">
Target/Filter: Cu-EPIC-0.9kV = 0.0006215219861090395
Target/Filter: Cu-EPIC-2kV = 0.0007052150065674744
Target/Filter: Al-Al-4kV = 0.001483398679126846
Target/Filter: Ag-Ag-6kV = 0.001126063558474516
Target/Filter: Ti-Ti-9kV = 0.0006524420692883554
Target/Filter: Mn-Cr-12kV = 0.0004757207676502019
Mean difference 0.0008440603445360723
</pre>

<p>
So we really have a miniscule difference there.
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> also compute the background rate achieved using no CDL morphing
vs using it.</li>
</ul>
</div>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:energy_calibration">
<h5 id="sec:uncertain:energy_calibration"><span class="section-number-5">13.11.7.3.</span> Energy calibration <code>[/]</code></h5>
<div class="outline-text-5" id="text-sec:uncertain:energy_calibration">
<ul class="org-ul">
<li class="off"><code>[ ]</code> compute peaks of 55Fe energy. What is variation?</li>
</ul>
</div>
</div>

<div class="outline-5" id="outline-container-sec:uncertain:software_efficiency">
<h5 id="sec:uncertain:software_efficiency"><span class="section-number-5">13.11.7.4.</span> Software efficiency systematic <code>[/]</code></h5>
<div class="outline-text-5" id="text-sec:uncertain:software_efficiency">
<p>
In order to guess at the systematic uncertainty of the software
efficiency, we can push all calibration data through the likelihood
cuts and evaluate the real efficiency that way.
</p>

<p>
This means the following:
</p>
<ul class="org-ul">
<li>compute likelihood values for all calibration runs</li>
<li>for each run, remove extreme outliers using rough RMS transverse &amp;
eccentricity cuts</li>
<li>filter to 2 energies (essentially a secondary cut), the photopeak
and escape peak</li>
<li>for each peak, push through likelihood cut. # after / # before is
software efficiency at that energy</li>
</ul>
<p>
The variation we&apos;ll see over all runs tells us something about the
systematic uncertainty &amp; potential bias.
</p>

<p>
<b>UPDATE</b>: The results presented below the code were computed with the
code snippet here <b>as is</b> (and multiple arguments of course, check
<code>zsh_history</code> at home for details). A modified version now also lives
at
<a href="./../CastData/ExternCode/TimepixAnalysis/Tools/determineEffectiveEfficiency.nim">./../CastData/ExternCode/TimepixAnalysis/Tools/determineEffectiveEfficiency.nim</a>
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>REMOVE THE PIECE OF CODE HERE, REPLACE BY CALL TO ABOVE!</b></li>
</ul>

<p>
<b>UPDATE2</b> :<span class="timestamp-wrapper">  <span class="timestamp">&lt;2022-08-24 Wed 19:15&gt; </span></span> While working on the below code for
the script mentioned in the first update, I noticed a bug in the
<code>filterEvents</code> function:
</p>
<div class="org-src-container">
<pre class="src src-nim">      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>.toRefDset<span style="color: #AE81FF;">()</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCuts </span>= xrayCutsTab<span style="color: #AE81FF;">[</span>dset<span style="color: #AE81FF;">]</span>
        <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> applyFilters<span style="color: #AE81FF;">(</span>df<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= <span style="font-style: italic;">2</span>.<span style="font-style: italic;">9</span>.toRefDset<span style="color: #AE81FF;">()</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCuts </span>= xrayCutsTab<span style="color: #AE81FF;">[</span>dset<span style="color: #AE81FF;">]</span>
        <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> applyFilters<span style="color: #AE81FF;">(</span>df<span style="color: #AE81FF;">)</span>
</pre>
</div>
<p>
the energies are exchanged and <code>applyFilters</code> is applied to <code>df</code> and
not <code>subDf</code> as it should here!
</p>
<ul class="org-ul">
<li class="off"><code>[ ]</code> <p>
Investigate the effect for the systematics of CAST!
-&gt; <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-03-20 Mon 21:53&gt;</span></span>: I just had a short look at this. It seems
like this is the correct output:
</p>
<p>
DataFrame with 3 columns and 67 rows:
     Idx    Escapepeak     Photopeak     RunNumber
  dtype:         float         float           int
       0        0.6579        0.7542            83
       1        0.6452         0.787            88
       2        0.6771        0.7667            93
       3        0.7975        0.7599            96
       4         0.799        0.7605           102
       5        0.8155        0.7679           108
       6        0.7512        0.7588           110
       7        0.8253        0.7769           116
       8        0.7766        0.7642           118
       9        0.7752        0.7765           120
      10        0.7556        0.7678           122
      11        0.7788        0.7711           126
      12        0.7749        0.7649           128
      13        0.8162        0.7807           145
      14        0.8393        0.7804           147
      15        0.7778          0.78           149
      16        0.8153         0.778           151
      17        0.7591        0.7873           153
      18        0.8229        0.7819           155
      19        0.8341        0.7661           157
      20        0.7788        0.7666           159
      21        0.7912        0.7639           161
      22        0.8041        0.7675           163
      23        0.7884         0.777           165
      24        0.8213        0.7791           167
      25        0.7994        0.7833           169
      26        0.8319        0.7891           171
      27        0.8483        0.7729           173
      28        0.7973        0.7733           175
      29         0.834        0.7771           177
      30         0.802         0.773           179
      31        0.7763        0.7687           181
      32        0.8061         0.766           183
      33        0.7916        0.7799           185
      34        0.8131        0.7745           187
      35        0.8366        0.8256           239
      36        0.8282        0.8035           241
      37        0.8072        0.8045           243
      38         0.851        0.8155           245
      39        0.7637        0.8086           247
      40        0.8439        0.8135           249
      41        0.8571        0.8022           251
      42        0.7854        0.7851           253
      43        0.8159        0.7843           255
      44         0.815        0.7827           257
      45        0.8783        0.8123           259
      46        0.8354        0.8094           260
      47           0.8         0.789           262
      48        0.8038        0.8097           264
      49        0.7926        0.7937           266
      50        0.8275        0.7961           269
      51        0.8514        0.8039           271
      52        0.8089        0.7835           273
      53        0.8134        0.7789           275
      54        0.8168        0.7873           277
      55        0.8198        0.7886           280
      56        0.8447        0.7833           282
      57        0.7876        0.7916           284
      58        0.8093        0.8032           286
      59        0.7945        0.8059           288
      60        0.8407        0.7981           290
      61        0.7824          0.78           292
      62        0.7885        0.7869           294
      63        0.7933        0.7823           296
      64         0.837        0.7834           300
      65        0.7594        0.7826           302
      66        0.8333        0.7949           304
</p>

<p>
Std Escape = 0.04106537728575545
Std Photo = 0.01581231947284212
Mean Escape = 0.8015071105396809
Mean Photo = 0.7837728948033928
</p>
<p>
So a bit worse than initially thought…
</p></li>
</ul>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> std / <span style="color: #AE81FF;">[</span>os, strutils, random, sequtils, stats, strformat<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> nimhdf5, cligen
<span style="color: #F92672;">import</span> numericalnim <span style="color: #F92672;">except</span> linspace


<span style="color: #F92672;">import</span> ingrid / private / <span style="color: #AE81FF;">[</span>likelihood_utils, hdf5_utils, ggplot_utils, geometry, cdl_cuts<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / calibration
<span style="color: #F92672;">import</span> ingrid / calibration / <span style="color: #AE81FF;">[</span>fit_functions<span style="color: #AE81FF;">]</span>
<span style="color: #F92672;">import</span> ingrid / ingrid_types
<span style="color: #F92672;">import</span> ingridDatabase / <span style="color: #AE81FF;">[</span>databaseRead, databaseDefinitions, databaseUtils<span style="color: #AE81FF;">]</span>

<span style="color: #75715E;"># </span><span style="color: #75715E;">cut performed regardless of logL value on the data, since transverse</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">rms &gt; 1.5 cannot be a physical photon, due to diffusion in 3cm drift</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">distance</span>
<span style="color: #F92672;">const</span> <span style="color: #66D9EF;">RmsCleaningCut</span> = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">5</span>

<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">CdlFile</span> = <span style="color: #E6DB74;">&quot;/home/basti/CastData/data/CDL_2019/calibration-cdl-2018.h5&quot;</span>
<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">RefFile</span> = <span style="color: #E6DB74;">&quot;/home/basti/CastData/data/CDL_2019/XrayReferenceFile2018.h5&quot;</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">drawNewEvent</span><span style="color: #AE81FF;">(</span>rms, energy: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">int</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">num </span>= rms.<span style="color: #F92672;">len</span> - <span style="font-style: italic;">1</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">idx </span>= rand<span style="color: #AE81FF;">(</span>num<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">while</span> rms<span style="color: #AE81FF;">[</span>idx<span style="color: #AE81FF;">]</span> &gt;= <span style="color: #66D9EF;">RmsCleaningCut</span> <span style="color: #F92672;">or</span>
        <span style="color: #AE81FF;">(</span>energy<span style="color: #66D9EF;">[</span>idx<span style="color: #66D9EF;">]</span> &lt;= <span style="font-style: italic;">4</span>.<span style="font-style: italic;">5</span> <span style="color: #F92672;">or</span> energy<span style="color: #66D9EF;">[</span>idx<span style="color: #66D9EF;">]</span> &gt;= <span style="font-style: italic;">7</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span>:
    idx = rand<span style="color: #AE81FF;">(</span>num<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = idx

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">computeEnergy</span><span style="color: #AE81FF;">(</span>h5f: <span style="color: #66D9EF;">H5File</span>, pix: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">Pix</span><span style="color: #66D9EF;">]</span>, group: <span style="color: #66D9EF;">string</span>, a, b, c, t, bL, mL: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">totalCharge </span>= pix.mapIt<span style="color: #AE81FF;">(</span>calibrateCharge<span style="color: #66D9EF;">(</span>it.ch.<span style="color: #66D9EF;">float</span>, a, b, c, t<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>.sum
  <span style="color: #75715E;"># </span><span style="color: #75715E;">compute mean of all gas gain slices in this run (most sensible)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">gain </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/gasGainSlices&quot;</span>, <span style="color: #66D9EF;">GasGainIntervalResult</span><span style="color: #AE81FF;">]</span>.mapIt<span style="color: #AE81FF;">(</span>it.<span style="color: #66D9EF;">G</span><span style="color: #AE81FF;">)</span>.mean
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">calibFactor </span>= linearFunc<span style="color: #AE81FF;">(</span>@<span style="color: #66D9EF;">[</span>bL, mL<span style="color: #66D9EF;">]</span>, gain<span style="color: #AE81FF;">)</span> * 1e-<span style="font-style: italic;">6</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">now calculate energy for all hits</span>
  <span style="color: #FD971F;">result</span> = totalCharge * calibFactor
  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">generateFakeData</span><span style="color: #AE81FF;">(</span>h5f: <span style="color: #66D9EF;">H5File</span>, nFake: <span style="color: #66D9EF;">int</span>, energy = <span style="font-style: italic;">3</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #E6DB74;">## For each run generate `</span><span style="color: #AE81FF;">nFake</span><span style="color: #E6DB74;">` fake events</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">refSetTuple </span>= readRefDsets<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">RefFile</span>, yr2018<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>num, group<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> runs<span style="color: #AE81FF;">(</span>h5f<span style="color: #AE81FF;">)</span>:
    <span style="color: #75715E;"># </span><span style="color: #75715E;">first read all x / y / tot data</span>
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Run number: &quot;</span>, num
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xs </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/x&quot;</span>, special_type<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">uint8</span><span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">uint8</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ys </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/y&quot;</span>, special_type<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">uint8</span><span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">uint8</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ts </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/ToT&quot;</span>, special_type<span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">uint16</span><span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">uint16</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">rms </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/rmsTransverse&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cX </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/centerX&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cY </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/centerY&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>    
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">energyInput </span>= h5f<span style="color: #AE81FF;">[</span>group / <span style="color: #E6DB74;">&quot;chip_3/energyFromCharge&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">chipGrp </span>= h5f<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span>group / <span style="color: #E6DB74;">&quot;chip_3&quot;</span><span style="color: #66D9EF;">)</span>.grp_str<span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">chipName </span>= chipGrp.attrs<span style="color: #AE81FF;">[</span><span style="color: #E6DB74;">&quot;chipName&quot;</span>, <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">]</span>
    <span style="color: #75715E;"># </span><span style="color: #75715E;">get factors for charge calibration</span>
    <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>a, b, c, t<span style="color: #AE81FF;">)</span> = getTotCalibParameters<span style="color: #AE81FF;">(</span>chipName, num<span style="color: #AE81FF;">)</span>    
    <span style="color: #75715E;"># </span><span style="color: #75715E;">get factors for charge / gas gain fit</span>
    <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>bL, mL<span style="color: #AE81FF;">)</span> = getCalibVsGasGainFactors<span style="color: #AE81FF;">(</span>chipName, num, suffix = $gcIndividualFits<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">count </span>= <span style="font-style: italic;">0</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">evIdx </span>= <span style="font-style: italic;">0</span>

    <span style="color: #F92672;">when</span> <span style="color: #AE81FF;">false</span>:
      <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; xs.<span style="color: #F92672;">len</span>:
        <span style="color: #F92672;">if</span> xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> &lt; <span style="font-style: italic;">150</span> <span style="color: #F92672;">and</span> energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> &gt; <span style="font-style: italic;">5</span>.<span style="font-style: italic;">5</span>:
          <span style="color: #75715E;"># </span><span style="color: #75715E;">recompute from data</span>
          <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pp </span>= toSeq<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span> ..&lt; xs<span style="color: #66D9EF;">[</span>i<span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>x: xs<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, y: ys<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, ch: ts<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
          <span style="color: #F92672;">let</span> <span style="color: #FD971F;">newEnergy </span>= h5f.computeEnergy<span style="color: #AE81FF;">(</span>pp, group, a, b, c, t, bL, mL<span style="color: #AE81FF;">)</span>
          <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Length &quot;</span>, xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> , <span style="color: #E6DB74;">&quot; w/ energy &quot;</span>, energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>, <span style="color: #E6DB74;">&quot; recomp &quot;</span>, newEnergy
          <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;x&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.x.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;y&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.y.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;ch&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.ch.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
          ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;x&quot;</span>, <span style="color: #E6DB74;">&quot;y&quot;</span>, color = <span style="color: #E6DB74;">&quot;ch&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
            geom_point<span style="color: #AE81FF;">()</span> +
            ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;funny its real&quot;</span><span style="color: #AE81FF;">)</span> + 
            ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/fake_event_&quot;</span> &amp; $i &amp; <span style="color: #E6DB74;">&quot;.pdf&quot;</span><span style="color: #AE81FF;">)</span>
          sleep<span style="color: #AE81FF;">(</span><span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">if</span> <span style="color: #AE81FF;">true</span>: <span style="color: #F92672;">quit</span><span style="color: #AE81FF;">()</span>
    
    <span style="color: #75715E;"># </span><span style="color: #75715E;">to store fake data</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">energies </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">logLs </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">rmss </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">eccs </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">ldivs </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">frins </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">cxxs </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">cyys </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">lengths </span>= newSeqOfCap<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>nFake<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">while</span> count &lt; nFake:
      <span style="color: #75715E;"># </span><span style="color: #75715E;">draw index from to generate a fake event</span>
      evIdx = drawNewEvent<span style="color: #AE81FF;">(</span>rms, energyInput<span style="color: #AE81FF;">)</span>
      <span style="color: #75715E;"># </span><span style="color: #75715E;">draw number of fake pixels</span>
      <span style="color: #75715E;"># </span><span style="color: #75715E;">compute ref # pixels for this event taking into account possible double counting etc.</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">basePixels </span>= <span style="color: #AE81FF;">(</span>energy / energyInput<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">]</span> * xs<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">nPix </span>= round<span style="color: #AE81FF;">(</span>basePixels + gauss<span style="color: #66D9EF;">(</span>sigma = <span style="font-style: italic;">10</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">int</span>  <span style="color: #75715E;"># </span><span style="color: #75715E;">~115 pix as reference in 3 keV (26 eV), draw normal w/10 around</span>
      <span style="color: #F92672;">if</span> nPix &lt; <span style="font-style: italic;">4</span>:
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Less than 4 pixels: &quot;</span>, nPix, <span style="color: #E6DB74;">&quot; skipping&quot;</span>
        <span style="color: #F92672;">continue</span>
      <span style="color: #F92672;">var</span> <span style="color: #FD971F;">pix </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">Pix</span><span style="color: #AE81FF;">](</span>nPix<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">var</span> <span style="color: #FD971F;">seenPix</span>: <span style="color: #66D9EF;">set</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">uint16</span><span style="color: #AE81FF;">]</span> = <span style="color: #AE81FF;">{}</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">evNumPix </span>= xs<span style="color: #AE81FF;">[</span>evIdx<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span>

      <span style="color: #F92672;">if</span> nPix &gt;= evNumPix:
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;More pixels to draw than available! &quot;</span>, nPix, <span style="color: #E6DB74;">&quot; vs &quot;</span>, evNumPix, <span style="color: #E6DB74;">&quot;, skipping!&quot;</span>
        <span style="color: #F92672;">continue</span>
      <span style="color: #F92672;">if</span> <span style="color: #F92672;">not</span> inRegion<span style="color: #AE81FF;">(</span>cX<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">]</span>, cY<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">]</span>, crSilver<span style="color: #AE81FF;">)</span>:
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Not in silver region. Not a good basis&quot;</span>
        <span style="color: #F92672;">continue</span>
      
      <span style="color: #F92672;">var</span> <span style="color: #FD971F;">pIdx </span>= rand<span style="color: #AE81FF;">(</span>evNumPix - <span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">for</span> j <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; nPix:
        <span style="color: #75715E;"># </span><span style="color: #75715E;">draw pix index</span>
        <span style="color: #F92672;">while</span> pIdx.<span style="color: #66D9EF;">uint16</span> <span style="color: #F92672;">in</span> seenPix:
          pIdx = rand<span style="color: #AE81FF;">(</span>evNumPix - <span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>
        seenPix.<span style="color: #F92672;">incl</span> pIdx.<span style="color: #66D9EF;">uint16</span>
        pix<span style="color: #AE81FF;">[</span>j<span style="color: #AE81FF;">]</span> = <span style="color: #AE81FF;">(</span>x: xs<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">][</span>pIdx<span style="color: #66D9EF;">]</span>, y: ys<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">][</span>pIdx<span style="color: #66D9EF;">]</span>, ch: ts<span style="color: #66D9EF;">[</span>evIdx<span style="color: #66D9EF;">][</span>pIdx<span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
      <span style="color: #75715E;"># </span><span style="color: #75715E;">now draw</span>
      <span style="color: #F92672;">when</span> <span style="color: #AE81FF;">false</span>:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;x&quot;</span> : pix.mapIt<span style="color: #A6E22E;">(</span>it.x.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;y&quot;</span> : pix.mapIt<span style="color: #A6E22E;">(</span>it.y.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;ch&quot;</span> : pix.mapIt<span style="color: #A6E22E;">(</span>it.ch.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
        ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;x&quot;</span>, <span style="color: #E6DB74;">&quot;y&quot;</span>, color = <span style="color: #E6DB74;">&quot;ch&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
          geom_point<span style="color: #AE81FF;">()</span> +
          ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/fake_event.pdf&quot;</span><span style="color: #AE81FF;">)</span>
        sleep<span style="color: #AE81FF;">(</span><span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span>

      <span style="color: #75715E;"># </span><span style="color: #75715E;">reconstruct event</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">inp </span>= <span style="color: #AE81FF;">(</span>pixels: pix, eventNumber: <span style="font-style: italic;">0</span>, toa: <span style="color: #F92672;">newSeq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">uint16</span><span style="color: #66D9EF;">]()</span>, toaCombined: <span style="color: #F92672;">newSeq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">uint64</span><span style="color: #66D9EF;">]()</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">recoEv </span>= recoEvent<span style="color: #AE81FF;">(</span>inp, -<span style="font-style: italic;">1</span>,
                             num, searchRadius = <span style="font-style: italic;">50</span>,
                             dbscanEpsilon = <span style="font-style: italic;">65</span>,
                             clusterAlgo = caDefault<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">if</span> recoEv.cluster.<span style="color: #F92672;">len</span> &gt; <span style="font-style: italic;">1</span> <span style="color: #F92672;">or</span> recoEv.cluster.<span style="color: #F92672;">len</span> == <span style="font-style: italic;">0</span>:
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Found more than 1 or 0 cluster! Skipping&quot;</span>
        <span style="color: #F92672;">continue</span>
      <span style="color: #75715E;"># </span><span style="color: #75715E;">compute charge</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">energy </span>= h5f.computeEnergy<span style="color: #AE81FF;">(</span>pix, group, a, b, c, t, bL, mL<span style="color: #AE81FF;">)</span>

      <span style="color: #75715E;"># </span><span style="color: #75715E;">puhhh, now the likelihood...</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ecc </span>= recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.geometry.eccentricity
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">ldiv </span>= recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.geometry.lengthDivRmsTrans
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">frin </span>= recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.geometry.fractionInTransverseRms
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">logL </span>= calcLikelihoodForEvent<span style="color: #AE81FF;">(</span>energy, 
                                        ecc,
                                        ldiv,
                                        frin,
                                        refSetTuple<span style="color: #AE81FF;">)</span>
      <span style="color: #75715E;"># </span><span style="color: #75715E;">finally done</span>
      energies.<span style="color: #F92672;">add</span> energy
      logLs.<span style="color: #F92672;">add</span> logL
      rmss.<span style="color: #F92672;">add</span> recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.geometry.rmsTransverse
      eccs.<span style="color: #F92672;">add</span> ecc
      ldivs.<span style="color: #F92672;">add</span> ldiv
      frins.<span style="color: #F92672;">add</span> frin
      cxxs.<span style="color: #F92672;">add</span> recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.centerX
      cyys.<span style="color: #F92672;">add</span> recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.centerY
      lengths.<span style="color: #F92672;">add</span> recoEv.cluster<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>.geometry.length
      <span style="color: #F92672;">inc</span> count
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span> <span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span> : energies,
                    <span style="color: #E6DB74;">&quot;likelihood&quot;</span> : logLs,
                    <span style="color: #E6DB74;">&quot;runNumber&quot;</span> : num,
                    <span style="color: #E6DB74;">&quot;rmsTransverse&quot;</span> : rmss,
                    <span style="color: #E6DB74;">&quot;eccentricity&quot;</span> : eccs,
                    <span style="color: #E6DB74;">&quot;lengthDivRmsTrans&quot;</span> : ldivs,
                    <span style="color: #E6DB74;">&quot;centerX&quot;</span> : cxxs,
                    <span style="color: #E6DB74;">&quot;centerY&quot;</span> : cyys,
                    <span style="color: #E6DB74;">&quot;length&quot;</span> : lengths,
                    <span style="color: #E6DB74;">&quot;fractionInTransverseRms&quot;</span> : frins <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> df

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">applyLogLCut</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, cutTab: <span style="color: #66D9EF;">CutValueInterpolator</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = df.mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;passLogL?&quot;</span> ~ <span style="color: #A6E22E;">(</span><span style="color: #F92672;">block</span>:
                                               <span style="color: #75715E;">#</span><span style="color: #75715E;">echo &quot;Cut value: &quot;, cutTab[idx(igEnergyFromCharge.toDset())], &quot; at dset &quot;, toRefDset(idx(igEnergyFromCharge.toDset())), &quot; at energy &quot;, idx(igEnergyFromCharge.toDset()) </span>
                                               idx<span style="color: #E6DB74;">(</span>igLikelihood.toDset<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">)</span> &lt; cutTab<span style="color: #E6DB74;">[</span>idx<span style="color: #FD971F;">(</span>igEnergyFromCharge.toDset<span style="color: #F92672;">()</span><span style="color: #FD971F;">)</span><span style="color: #E6DB74;">]</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">readRunData</span><span style="color: #AE81FF;">(</span>h5f: <span style="color: #66D9EF;">H5File</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #FD971F;">result</span> = h5f.readDsets<span style="color: #AE81FF;">(</span>chipDsets =
    some<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>chip: <span style="font-style: italic;">3</span>,
          dsets: @<span style="color: #E6DB74;">[</span>igEnergyFromCharge.toDset<span style="color: #FD971F;">()</span>,
                   igRmsTransverse.toDset<span style="color: #FD971F;">()</span>,
                   igLengthDivRmsTrans.toDset<span style="color: #FD971F;">()</span>,
                   igFractionInTransverseRms.toDset<span style="color: #FD971F;">()</span>,
                   igEccentricity.toDset<span style="color: #FD971F;">()</span>,
                   igCenterX.toDset<span style="color: #FD971F;">()</span>,
                   igCenterY.toDset<span style="color: #FD971F;">()</span>,
                   igLength.toDset<span style="color: #FD971F;">()</span>,
                   igLikelihood.toDset<span style="color: #FD971F;">()</span><span style="color: #E6DB74;">]</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">filterEvents</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, energy: <span style="color: #66D9EF;">float</span> = <span style="color: #66D9EF;">Inf</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCutsTab </span><span style="color: #AE81FF;">{</span>.<span style="color: #F92672;">global</span>.<span style="color: #AE81FF;">}</span> = getXrayCleaningCuts<span style="color: #AE81FF;">()</span>  
  <span style="color: #F92672;">template</span> <span style="color: #A6E22E;">applyFilters</span><span style="color: #AE81FF;">(</span>dfI: <span style="color: #66D9EF;">untyped</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">untyped</span> <span style="color: #AE81FF;">{</span>.<span style="color: #F92672;">dirty</span>.<span style="color: #AE81FF;">}</span> =
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">minRms </span>= xrayCuts.minRms
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">maxRms </span>= xrayCuts.maxRms
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">maxLen </span>= xrayCuts.maxLength
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">maxEcc </span>= xrayCuts.maxEccentricity
    dfI.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span> -&gt; <span style="color: #66D9EF;">bool</span>: idx<span style="color: #A6E22E;">(</span>igRmsTransverse.toDset<span style="color: #E6DB74;">()</span><span style="color: #A6E22E;">)</span> &lt; <span style="color: #66D9EF;">RmsCleaningCut</span> <span style="color: #F92672;">and</span>
      inRegion<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;centerX&quot;</span><span style="color: #E6DB74;">)</span>, idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;centerY&quot;</span><span style="color: #E6DB74;">)</span>, crSilver<span style="color: #A6E22E;">)</span> <span style="color: #F92672;">and</span>
      idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;rmsTransverse&quot;</span><span style="color: #A6E22E;">)</span> &gt;= minRms <span style="color: #F92672;">and</span>
      idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;rmsTransverse&quot;</span><span style="color: #A6E22E;">)</span> &lt;= maxRms <span style="color: #F92672;">and</span>
      idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;length&quot;</span><span style="color: #A6E22E;">)</span> &lt;= maxLen <span style="color: #F92672;">and</span>
      idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;eccentricity&quot;</span><span style="color: #A6E22E;">)</span> &lt;= maxEcc
    <span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> <span style="color: #E6DB74;">&quot;Peak&quot;</span> <span style="color: #F92672;">in</span> df:
    <span style="color: #F92672;">doAssert</span> classify<span style="color: #AE81FF;">(</span>energy<span style="color: #AE81FF;">)</span> == fcInf
    <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
    <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>df.group_by<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Peak&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">case</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>.toRefDset<span style="color: #AE81FF;">()</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCuts </span>= xrayCutsTab<span style="color: #AE81FF;">[</span>dset<span style="color: #AE81FF;">]</span>
        <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> applyFilters<span style="color: #AE81FF;">(</span>df<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= <span style="font-style: italic;">2</span>.<span style="font-style: italic;">9</span>.toRefDset<span style="color: #AE81FF;">()</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCuts </span>= xrayCutsTab<span style="color: #AE81FF;">[</span>dset<span style="color: #AE81FF;">]</span>
        <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> applyFilters<span style="color: #AE81FF;">(</span>df<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">else</span>: <span style="color: #F92672;">doAssert</span> <span style="color: #AE81FF;">false</span>, <span style="color: #E6DB74;">&quot;Invalid name&quot;</span>
  <span style="color: #F92672;">else</span>:
    <span style="color: #F92672;">doAssert</span> classify<span style="color: #AE81FF;">(</span>energy<span style="color: #AE81FF;">)</span> != fcInf
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dset </span>= energy.toRefDset<span style="color: #AE81FF;">()</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">xrayCuts </span>= xrayCutsTab<span style="color: #AE81FF;">[</span>dset<span style="color: #AE81FF;">]</span>
    <span style="color: #FD971F;">result</span> = applyFilters<span style="color: #AE81FF;">(</span>df<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">splitPeaks</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">eD </span>= igEnergyFromCharge.toDset<span style="color: #AE81FF;">()</span>
  <span style="color: #FD971F;">result</span> = df.mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span> -&gt; <span style="color: #66D9EF;">string</span>: <span style="color: #E6DB74;">&quot;Peak&quot;</span> ~ <span style="color: #A6E22E;">(</span>
    <span style="color: #F92672;">if</span> idx<span style="color: #E6DB74;">(</span>eD<span style="color: #E6DB74;">)</span> &lt; <span style="font-style: italic;">3</span>.<span style="font-style: italic;">5</span> <span style="color: #F92672;">and</span> idx<span style="color: #E6DB74;">(</span>eD<span style="color: #E6DB74;">)</span> &gt; <span style="font-style: italic;">2</span>.<span style="font-style: italic;">5</span>:
      <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>
    <span style="color: #F92672;">elif</span> idx<span style="color: #E6DB74;">(</span>eD<span style="color: #E6DB74;">)</span> &gt; <span style="font-style: italic;">4</span>.<span style="font-style: italic;">5</span> <span style="color: #F92672;">and</span> idx<span style="color: #E6DB74;">(</span>eD<span style="color: #E6DB74;">)</span> &lt; <span style="font-style: italic;">7</span>.<span style="font-style: italic;">5</span>:
      <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>
    <span style="color: #F92672;">else</span>:
      <span style="color: #E6DB74;">&quot;None&quot;</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`<span style="color: #66D9EF;">Peak</span>` != <span style="color: #E6DB74;">&quot;None&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">handleFile</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, cutTab: <span style="color: #66D9EF;">CutValueInterpolator</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #E6DB74;">## Given a single input file, performs application of the likelihood cut for all</span>
  <span style="color: #E6DB74;">## runs in it, split by photo &amp; escape peak. Returns a DF with column indicating</span>
  <span style="color: #E6DB74;">## the peak, energy of each event &amp; a column whether it passed the likelihood cut.</span>
  <span style="color: #E6DB74;">## Only events that are pass the input cuts are stored.</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span>fname, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  randomize<span style="color: #AE81FF;">(</span><span style="font-style: italic;">423</span><span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">data </span>= h5f.readRunData<span style="color: #AE81FF;">()</span>
    .splitPeaks<span style="color: #AE81FF;">()</span>
    .filterEvents<span style="color: #AE81FF;">()</span>
    .applyLogLCut<span style="color: #AE81FF;">(</span>cutTab<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> data
  <span style="color: #F92672;">when</span> <span style="color: #AE81FF;">false</span>:
    ggplot<span style="color: #AE81FF;">(</span><span style="color: #FD971F;">result</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;energyFromCharge&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span> +
      ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/ugl.pdf&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">discard</span> h5f.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">handleFakeData</span><span style="color: #AE81FF;">(</span>fname: <span style="color: #66D9EF;">string</span>, energy: <span style="color: #66D9EF;">float</span>, cutTab: <span style="color: #66D9EF;">CutValueInterpolator</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">DataFrame</span> =
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span>fname, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">data </span>= generateFakeData<span style="color: #AE81FF;">(</span>h5f, <span style="font-style: italic;">5000</span>, energy = energy<span style="color: #AE81FF;">)</span>
    .filterEvents<span style="color: #AE81FF;">(</span>energy<span style="color: #AE81FF;">)</span>
    .applyLogLCut<span style="color: #AE81FF;">(</span>cutTab<span style="color: #AE81FF;">)</span>
  <span style="color: #FD971F;">result</span> = data
  <span style="color: #F92672;">discard</span> h5f.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span>  

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">getIndices</span><span style="color: #AE81FF;">(</span>dset: <span style="color: #66D9EF;">string</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">seq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]</span> =
  <span style="color: #FD971F;">result</span> = <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]()</span>
  applyLogLFilterCuts<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">CdlFile</span>, <span style="color: #66D9EF;">RefFile</span>, dset, yr2018, igEnergyFromCharge<span style="color: #AE81FF;">)</span>:
    <span style="color: #FD971F;">result</span>.<span style="color: #F92672;">add</span> i

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">plotRefHistos</span><span style="color: #AE81FF;">(</span>df: <span style="color: #66D9EF;">DataFrame</span>, energy: <span style="color: #66D9EF;">float</span>, cutTab: <span style="color: #66D9EF;">CutValueInterpolator</span>,
                   dfAdditions: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #F92672;">tuple</span><span style="color: #A6E22E;">[</span>name: <span style="color: #66D9EF;">string</span>, df: <span style="color: #66D9EF;">DataFrame</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">]</span> = @<span style="color: #66D9EF;">[]</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">map input fake energy to reference dataset</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">grp </span>= energy.toRefDset<span style="color: #AE81FF;">()</span>

  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">passedInds </span>= getIndices<span style="color: #AE81FF;">(</span>grp<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">h5f </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">RefFile</span>, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">h5fC </span>= <span style="color: #66D9EF;">H5open</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">CdlFile</span>, <span style="color: #E6DB74;">&quot;r&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">xray_ref </span>= getXrayRefTable<span style="color: #AE81FF;">()</span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">for (i, grp) in pairs(xray_ref):</span>

  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfR </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">for</span> dset <span style="color: #F92672;">in</span> <span style="color: #66D9EF;">IngridDsetKind</span>:
    <span style="color: #F92672;">try</span>:
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">d </span>= dset.toDset<span style="color: #AE81FF;">()</span>
      <span style="color: #F92672;">if</span> d <span style="color: #F92672;">notin</span> df: <span style="color: #F92672;">continue</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">skip things not in input</span>
      <span style="color: #E6DB74;">## first read data from CDL file (exists for sure)</span>
      <span style="color: #E6DB74;">## extract all CDL data that passes the cuts used to generate the logL histograms</span>
      <span style="color: #F92672;">var</span> <span style="color: #FD971F;">cdlFiltered </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">](</span>passedInds.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cdlRaw </span>= h5fC<span style="color: #AE81FF;">[</span>cdlGroupName<span style="color: #66D9EF;">(</span>grp, <span style="color: #E6DB74;">&quot;2019&quot;</span>, d<span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>
      <span style="color: #F92672;">for</span> i, idx <span style="color: #F92672;">in</span> passedInds:
        cdlFiltered<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> = cdlRaw<span style="color: #AE81FF;">[</span>idx<span style="color: #AE81FF;">]</span>
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Total number of elements &quot;</span>, cdlRaw.<span style="color: #F92672;">len</span>, <span style="color: #E6DB74;">&quot; filtered to &quot;</span>, passedInds.<span style="color: #F92672;">len</span>
      dfR<span style="color: #AE81FF;">[</span>d<span style="color: #AE81FF;">]</span> = cdlFiltered
      <span style="color: #E6DB74;">## now read histograms from RefFile, if they exist (not all datasets do)</span>
      <span style="color: #F92672;">if</span> grp / d <span style="color: #F92672;">in</span> h5f:
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dsetH5 </span>= h5f<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span>grp / d<span style="color: #66D9EF;">)</span>.dset_str<span style="color: #AE81FF;">]</span>
        <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>bins, data<span style="color: #AE81FF;">)</span> = dsetH5<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]</span>.reshape2D<span style="color: #AE81FF;">(</span>dsetH5.shape<span style="color: #AE81FF;">)</span>.split<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Seq2Col</span><span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">fname </span>= &amp;<span style="color: #E6DB74;">&quot;/tmp/{grp}_{d}_energy_{energy:.1f}.pdf&quot;</span>
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Storing histogram in : &quot;</span>, fname
        <span style="color: #75715E;"># </span><span style="color: #75715E;">now add fake data</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dataSum </span>= simpson<span style="color: #AE81FF;">(</span>data, bins<span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">refDf </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;bins&quot;</span> : bins, <span style="color: #E6DB74;">&quot;data&quot;</span> : data<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
          .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;data&quot;</span> ~ `data` / dataSum<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= df.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: idx<span style="color: #A6E22E;">(</span>d<span style="color: #A6E22E;">)</span> &lt;= bins<span style="color: #A6E22E;">[</span>^<span style="font-style: italic;">1</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
        ggplot<span style="color: #AE81FF;">(</span>refDf, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;bins&quot;</span>, <span style="color: #E6DB74;">&quot;data&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
          geom_histogram<span style="color: #AE81FF;">(</span>stat = <span style="color: #E6DB74;">&quot;identity&quot;</span>, hdKind = hdOutline, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
          geom_histogram<span style="color: #AE81FF;">(</span>data = df, aes = aes<span style="color: #66D9EF;">(</span>d<span style="color: #66D9EF;">)</span>, bins = <span style="font-style: italic;">200</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>,
                         fillColor = <span style="color: #E6DB74;">&quot;orange&quot;</span>, density = <span style="color: #AE81FF;">true</span>, hdKind = hdOutline<span style="color: #AE81FF;">)</span> +
          ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;{d}. Orange: fake data from &apos;reducing&apos; 5.9 keV data @ {energy:.1f}. Black: CDL ref {grp}&quot;</span><span style="color: #AE81FF;">)</span> +
          ggsave<span style="color: #AE81FF;">(</span>fname, width = <span style="font-style: italic;">1000</span>, height = <span style="font-style: italic;">600</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">except</span> <span style="color: #66D9EF;">AssertionError</span>:
      <span style="color: #F92672;">continue</span>

  <span style="color: #75715E;"># </span><span style="color: #75715E;">get effect of logL cut on CDL data</span>
  dfR = dfR.applyLogLCut<span style="color: #AE81FF;">(</span>cutTab<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfs </span>= @<span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Fake&quot;</span>, df<span style="color: #66D9EF;">)</span>, <span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Real&quot;</span>, dfR<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">]</span>
  <span style="color: #F92672;">if</span> dfAdditions.<span style="color: #F92672;">len</span> &gt; <span style="font-style: italic;">0</span>:
    dfs = concat<span style="color: #AE81FF;">(</span>dfs, dfAdditions<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">dfPlot </span>= bind_rows<span style="color: #AE81FF;">(</span>dfs, <span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Rough filter removes: &quot;</span>, dfPlot.<span style="color: #F92672;">len</span>
  dfPlot = dfPlot.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>`lengthDivRmsTrans` &lt;= <span style="font-style: italic;">50</span>.<span style="font-style: italic;">0</span> <span style="color: #F92672;">and</span> `eccentricity` &lt;= <span style="font-style: italic;">5</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;To &quot;</span>, dfPlot.<span style="color: #F92672;">len</span>, <span style="color: #E6DB74;">&quot; elements&quot;</span>
  ggplot<span style="color: #AE81FF;">(</span>dfPlot, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;lengthDivRmsTrans&quot;</span>, <span style="color: #E6DB74;">&quot;fractionInTransverseRms&quot;</span>, color = <span style="color: #E6DB74;">&quot;eccentricity&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    facet_wrap<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #AE81FF;">)</span> + 
    geom_point<span style="color: #AE81FF;">(</span>size = <span style="font-style: italic;">1</span>.<span style="font-style: italic;">0</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Fake energy: {energy:.2f}, CDL dataset: {grp}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;/tmp/scatter_colored_fake_energy_{energy:.2f}.png&quot;</span>, width = <span style="font-style: italic;">1200</span>, height = <span style="font-style: italic;">800</span><span style="color: #AE81FF;">)</span>

  <span style="color: #75715E;"># </span><span style="color: #75715E;">plot likelihood histos</span>
  ggplot<span style="color: #AE81FF;">(</span>dfPlot, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;likelihood&quot;</span>, fill = <span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">200</span>, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, hdKind = hdOutline<span style="color: #AE81FF;">)</span> +
    ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;Fake energy: {energy:.2f}, CDL dataset: {grp}&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;/tmp/histogram_fake_energy_{energy:.2f}.pdf&quot;</span>, width = <span style="font-style: italic;">800</span>, height = <span style="font-style: italic;">600</span><span style="color: #AE81FF;">)</span>
    
  <span style="color: #F92672;">discard</span> h5f.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span>    
  <span style="color: #F92672;">discard</span> h5fC.<span style="color: #F92672;">close</span><span style="color: #AE81FF;">()</span>


  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;DATASET : &quot;</span>, grp, <span style="color: #E6DB74;">&quot;--------------------------------------------------------------------------------&quot;</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Efficiency of logL cut on filtered CDL data (should be 80%!) = &quot;</span>, dfR.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;passLogL?&quot;</span><span style="color: #A6E22E;">)</span> == <span style="color: #AE81FF;">true</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span> / dfR.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Elements passing using `passLogL?` &quot;</span>, dfR.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;passLogL?&quot;</span><span style="color: #A6E22E;">)</span> == <span style="color: #AE81FF;">true</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>.<span style="color: #F92672;">len</span>, <span style="color: #E6DB74;">&quot; vs total &quot;</span>, dfR.<span style="color: #F92672;">len</span>
  <span style="color: #F92672;">let</span> <span style="color: #AE81FF;">(</span>hist, bins<span style="color: #AE81FF;">)</span> = histogram<span style="color: #AE81FF;">(</span>dfR<span style="color: #66D9EF;">[</span><span style="color: #E6DB74;">&quot;likelihood&quot;</span>, <span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span>.toRawSeq, <span style="font-style: italic;">200</span>, <span style="color: #66D9EF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">30</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
  ggplot<span style="color: #AE81FF;">(</span>toDf<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">{</span><span style="color: #E6DB74;">&quot;Bins&quot;</span> : bins, <span style="color: #E6DB74;">&quot;Hist&quot;</span> : hist<span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Bins&quot;</span>, <span style="color: #E6DB74;">&quot;Hist&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
    geom_histogram<span style="color: #AE81FF;">(</span>stat = <span style="color: #E6DB74;">&quot;identity&quot;</span><span style="color: #AE81FF;">)</span> +
    ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/usage_histo_&quot;</span> &amp; $grp &amp; <span style="color: #E6DB74;">&quot;.pdf&quot;</span><span style="color: #AE81FF;">)</span>  
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cutval </span>= determineCutValue<span style="color: #AE81FF;">(</span>hist, eff = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">8</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Effficiency from `determineCutValue? &quot;</span>, bins<span style="color: #AE81FF;">[</span>cutVal<span style="color: #AE81FF;">]</span>

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">(</span>files: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">string</span><span style="color: #66D9EF;">]</span>, fake = <span style="color: #AE81FF;">false</span>, real = <span style="color: #AE81FF;">false</span>, refPlots = <span style="color: #AE81FF;">false</span>,
          energies: <span style="color: #66D9EF;">seq</span><span style="color: #66D9EF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">]</span> = @<span style="color: #66D9EF;">[]</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">## given the input files of calibration runs, walks all files to determine the</span>
  <span style="color: #E6DB74;">## &apos;real&apos; software efficiency for them &amp; generates a plot</span>
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">cutTab </span>= calcCutValueTab<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">CdlFile</span>, <span style="color: #66D9EF;">RefFile</span>, yr2018, igEnergyFromCharge<span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">var</span> <span style="color: #FD971F;">df </span>= newDataFrame<span style="color: #AE81FF;">()</span>
  <span style="color: #F92672;">if</span> real <span style="color: #F92672;">and</span> <span style="color: #F92672;">not</span> fake:
    <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> files:
      df.<span style="color: #F92672;">add</span> handleFile<span style="color: #AE81FF;">(</span>f, cutTab<span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">effEsc </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">effPho </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">nums </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">]()</span>
    <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>df.group_by<span style="color: #66D9EF;">(</span>@<span style="color: #A6E22E;">[</span><span style="color: #E6DB74;">&quot;runNumber&quot;</span>, <span style="color: #E6DB74;">&quot;Peak&quot;</span><span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;------------------&quot;</span>
      <span style="color: #F92672;">echo</span> tup
      <span style="color: #75715E;">#</span><span style="color: #75715E;">echo subDf</span>
      <span style="color: #F92672;">let</span> <span style="color: #FD971F;">eff </span>= subDf.filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span>idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;passLogL?&quot;</span><span style="color: #A6E22E;">)</span> == <span style="color: #AE81FF;">true</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span> / subDf.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span>
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Software efficiency: &quot;</span>, eff
      <span style="color: #F92672;">if</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr == <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>:
        effEsc.<span style="color: #F92672;">add</span> eff
      <span style="color: #F92672;">elif</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr == <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>:
        effPho.<span style="color: #F92672;">add</span> eff
        <span style="color: #75715E;"># </span><span style="color: #75715E;">only add in one branch</span>
        nums.<span style="color: #F92672;">add</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">toInt</span>
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;------------------&quot;</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfEff </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Escapepeak&quot;</span> : effEsc, <span style="color: #E6DB74;">&quot;Photopeak&quot;</span> : effPho, <span style="color: #E6DB74;">&quot;RunNumber&quot;</span> : nums<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">echo</span> dfEff.pretty<span style="color: #AE81FF;">(</span>-<span style="font-style: italic;">1</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">stdEsc </span>= effEsc.standardDeviationS
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">stdPho </span>= effPho.standardDeviationS
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">meanEsc </span>= effEsc.mean
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">meanPho </span>= effPho.mean
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Std Escape = &quot;</span>, stdEsc
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Std Photo = &quot;</span>, stdPho
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Mean Escape = &quot;</span>, meanEsc
    <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Mean Photo = &quot;</span>, meanPho    
    ggplot<span style="color: #AE81FF;">(</span>dfEff.gather<span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">[</span><span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>, <span style="color: #E6DB74;">&quot;Photopeak&quot;</span><span style="color: #A6E22E;">]</span>, <span style="color: #E6DB74;">&quot;Type&quot;</span>, <span style="color: #E6DB74;">&quot;Value&quot;</span><span style="color: #66D9EF;">)</span>, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Value&quot;</span>, fill = <span style="color: #E6DB74;">&quot;Type&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_histogram<span style="color: #AE81FF;">(</span>bins = <span style="font-style: italic;">20</span>, hdKind = hdOutline, alpha = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
      ggtitle<span style="color: #AE81FF;">(</span>&amp;<span style="color: #E6DB74;">&quot;σ_escape = {stdEsc:.4f}, μ_escape = {meanEsc:.4f}, σ_photo = {stdPho:.4f}, μ_photo = {meanPho:.4f}&quot;</span><span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/software_efficiencies_cast_escape_photo.pdf&quot;</span>, width = <span style="font-style: italic;">800</span>, height = <span style="font-style: italic;">600</span><span style="color: #AE81FF;">)</span>
    
    <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>df.group_by<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Peak&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">case</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>: plotRefHistos<span style="color: #AE81FF;">(</span>df, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">9</span>, cutTab<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>: plotRefHistos<span style="color: #AE81FF;">(</span>df, <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>, cutTab<span style="color: #AE81FF;">)</span>
      <span style="color: #F92672;">else</span>: <span style="color: #F92672;">doAssert</span> <span style="color: #AE81FF;">false</span>, <span style="color: #E6DB74;">&quot;Invalid data: &quot;</span> &amp; $tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr
  <span style="color: #F92672;">if</span> fake <span style="color: #F92672;">and</span> <span style="color: #F92672;">not</span> real:
    <span style="color: #F92672;">var</span> <span style="color: #FD971F;">effs </span>= <span style="color: #F92672;">newSeq</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">]()</span>
    <span style="color: #F92672;">for</span> e <span style="color: #F92672;">in</span> energies:
      <span style="color: #F92672;">if</span> e &gt; <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>:
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Warning: energy above 5.9 keV not allowed!&quot;</span>
        <span style="color: #F92672;">return</span>
      df = newDataFrame<span style="color: #AE81FF;">()</span>
      <span style="color: #F92672;">for</span> f <span style="color: #F92672;">in</span> files:
        df.<span style="color: #F92672;">add</span> handleFakeData<span style="color: #AE81FF;">(</span>f, e, cutTab<span style="color: #AE81FF;">)</span>
      plotRefHistos<span style="color: #AE81FF;">(</span>df, e, cutTab<span style="color: #AE81FF;">)</span>
        
      <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Done generating for energy &quot;</span>, e
      effs.<span style="color: #F92672;">add</span><span style="color: #AE81FF;">(</span>df.filter<span style="color: #66D9EF;">(</span>f<span style="color: #A6E22E;">{</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;passLogL?&quot;</span><span style="color: #E6DB74;">)</span> == <span style="color: #AE81FF;">true</span><span style="color: #A6E22E;">}</span><span style="color: #66D9EF;">)</span>.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span> / df.<span style="color: #F92672;">len</span>.<span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfL </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Energy&quot;</span> : energies, <span style="color: #E6DB74;">&quot;Efficiency&quot;</span> : effs<span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">echo</span> dfL
    ggplot<span style="color: #AE81FF;">(</span>dfL, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Energy&quot;</span>, <span style="color: #E6DB74;">&quot;Efficiency&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
      geom_point<span style="color: #AE81FF;">()</span> +
      ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;Software efficiency from &apos;fake&apos; events&quot;</span><span style="color: #AE81FF;">)</span> + 
      ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/fake_software_effs.pdf&quot;</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">if</span> fake <span style="color: #F92672;">and</span> real:
    <span style="color: #F92672;">doAssert</span> files.<span style="color: #F92672;">len</span> == <span style="font-style: italic;">1</span>, <span style="color: #E6DB74;">&quot;Not more than 1 file supported!&quot;</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">f </span>= files<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">]</span>
    <span style="color: #F92672;">let</span> <span style="color: #FD971F;">dfCast </span>= handleFile<span style="color: #AE81FF;">(</span>f, cutTab<span style="color: #AE81FF;">)</span>

    <span style="color: #F92672;">for</span> <span style="color: #AE81FF;">(</span>tup, subDf<span style="color: #AE81FF;">)</span> <span style="color: #F92672;">in</span> groups<span style="color: #AE81FF;">(</span>dfCast.group_by<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Peak&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>:
      <span style="color: #F92672;">case</span> tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Escapepeak&quot;</span>:
        plotRefHistos<span style="color: #AE81FF;">(</span>handleFakeData<span style="color: #66D9EF;">(</span>f, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">9</span>, cutTab<span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">9</span>, cutTab, @<span style="color: #66D9EF;">[</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;CAST&quot;</span>, subDf<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>
      <span style="color: #F92672; font-style: italic;">of</span> <span style="color: #E6DB74;">&quot;Photopeak&quot;</span>:
        plotRefHistos<span style="color: #AE81FF;">(</span>handleFakeData<span style="color: #66D9EF;">(</span>f, <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>, cutTab<span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">5</span>.<span style="font-style: italic;">9</span>, cutTab, @<span style="color: #66D9EF;">[</span><span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;CAST&quot;</span>, subDf<span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">]</span><span style="color: #AE81FF;">)</span>        
      <span style="color: #F92672;">else</span>: <span style="color: #F92672;">doAssert</span> <span style="color: #AE81FF;">false</span>, <span style="color: #E6DB74;">&quot;Invalid data: &quot;</span> &amp; $tup<span style="color: #AE81FF;">[</span><span style="font-style: italic;">0</span><span style="color: #AE81FF;">][</span><span style="font-style: italic;">1</span><span style="color: #AE81FF;">]</span>.toStr
    
  <span style="color: #75715E;">#</span><span style="color: #75715E;">if refPlots:</span>
  <span style="color: #75715E;">#  </span><span style="color: #75715E;">plotRefHistos()    </span>
  
<span style="color: #F92672;">when</span> <span style="color: #AE81FF;">isMainModule</span>:
  dispatch main
</pre>
</div>


<p>
<b>UPDATE</b> <span class="timestamp-wrapper">  <span class="timestamp">&lt;2022-05-06 Fri 12:32&gt;</span></span>: The discussion about the results of
the above code here is limited to the results relevant for the
systematic of the software efficiency. For the debugging of the
unexpected software efficiencies computed for the calibration photo &amp;
escape peaks, see section
[BROKEN LINK: sec:debug_software_efficiency_cdl_mapping_bug].
</p>

<p>
After the debugging session trying to figure out why the hell the
software efficiency is so different, here are finally the results of
this study.
</p>

<p>
The software efficiencies for the escape &amp; photopeak energies from
the calibration data at CAST are determined as follows:
</p>
<ul class="org-ul">
<li>filter to events with <code>rmsTransverse</code> &lt;= 1.5</li>
<li>filter to events within the silver region</li>
<li>filter to events passing the &apos;X-ray cuts&apos;</li>
<li>for escape &amp; photopeak each filter to energies of 1 &amp; 1.5 keV
around the peak</li>
</ul>
<p>
The remaining events are then used as the &quot;basis&quot; for the
evaluation. From here the likelihood cut method is applied to all
clusters.
In the final step the ratio of clusters passing the logL cut over all
clusters is computed, which gives the effective software efficiency
for the data.
</p>

<p>
For all 2017 and 2018 runs this gives:
</p>
<div class="org-src-container">
<pre class="src src-sh">Dataframe with 3 columns and 67 rows:
           Idx    Escapepeak     Photopeak     RunNumber
        dtype:         float         float           int
             0        0.6886         0.756            83
             1        0.6845         0.794            88
             2        0.6789        0.7722            93
             3        0.7748        0.7585            96
             4        0.8111         0.769           102
             5        0.7979         0.765           108
             6        0.7346        0.7736           110
             7        0.7682        0.7736           116
             8        0.7593         0.775           118
             9        0.7717        0.7754           120
            10        0.7628        0.7714           122
            11        0.7616        0.7675           126
            12        0.7757        0.7659           128
            13        0.8274        0.7889           145
            14        0.7974        0.7908           147
            15        0.7969        0.7846           149
            16        0.7919        0.7853           151
            17        0.7574        0.7913           153
            18         0.835        0.7887           155
            19        0.8119        0.7755           157
            20        0.7738        0.7763           159
            21        0.7937        0.7736           161
            22        0.7801         0.769           163
            23           0.8        0.7801           165
            24        0.8014         0.785           167
            25        0.7922         0.787           169
            26        0.8237        0.7945           171
            27        0.8392         0.781           173
            28        0.8092        0.7756           175
            29        0.8124        0.7864           177
            30         0.803        0.7818           179
            31        0.7727        0.7742           181
            32        0.7758        0.7676           183
            33        0.7993        0.7817           185
            34        0.8201        0.7757           187
            35         0.824        0.8269           239
            36        0.8369        0.8186           241
            37        0.7953        0.8097           243
            38        0.8205        0.8145           245
            39         0.775        0.8117           247
            40        0.8368        0.8264           249
            41        0.8405        0.8105           251
            42        0.7804         0.803           253
            43        0.8177        0.7907           255
            44         0.801        0.7868           257
            45         0.832        0.8168           259
            46        0.8182        0.8074           260
            47        0.7928        0.7995           262
            48        0.7906        0.8185           264
            49        0.7933        0.8039           266
            50        0.8026         0.811           269
            51        0.8328        0.8086           271
            52        0.8024        0.7989           273
            53        0.8065        0.7911           275
            54         0.807        0.8006           277
            55        0.7895        0.7963           280
            56        0.8133        0.7918           282
            57        0.7939        0.8037           284
            58        0.7963        0.8066           286
            59        0.8104        0.8181           288
            60        0.8056         0.809           290
            61         0.762        0.7999           292
            62        0.7659        0.8021           294
            63        0.7648          0.79           296
            64        0.7868        0.7952           300
            65        0.7815        0.8036           302
            66        0.8276        0.8078           304
</pre>
</div>

<p>
with the following statistical summaries:
</p>
<div class="org-src-container">
<pre class="src src-sh">Std <span style="color: #FD971F;">Escape</span> = 0.03320160467567293
Std <span style="color: #FD971F;">Photo</span> = 0.01727763707839311
Mean <span style="color: #FD971F;">Escape</span> = 0.7923601424260915
Mean <span style="color: #FD971F;">Photo</span> = 0.7909126317171645
</pre>
</div>
<p>
(where <code>Std</code> really is the standard deviation. For the escape data
this is skewed due to the first 3 runs as visible in the DF output
above).
</p>



<p>
The data as a histogram:
</p>


<figure id="orge207703">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/software_efficiencies_cast_escape_photo.svg" class="org-svg" alt="software_efficiencies_cast_escape_photo.svg" />

<figcaption>Figure 30: <span class="figure-number">Figure 102: </span>Histogram of the effective software efficiencies for escape and photopeak data at CAST for all 2017/18 calibration runs. The low efficiency outliers are the first 3 calibration runs in 2017.</figcaption>
</figure>

<p>
Further, we can also ask for the behavior of fake data now. Let&apos;s
generate a set and look at the effective efficiency of fake data.
</p>


<figure id="orgb2a45d4">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/fake_effective_software_efficiencies.svg" class="org-svg" alt="fake_effective_software_efficiencies.svg" />

<figcaption>Figure 31: <span class="figure-number">Figure 103: </span>Fake effective software efficiencies at different energies. Clusters are generated from valid 5.9 keV Photopeak clusters (that pass the required cuts) by randomly removing a certain number of pixels until the desired energy is reached. Given the approach, the achieved efficiencies seem fine.</figcaption>
</figure>


<figure id="orge798797">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/histograms_properties_fake_vs_referenc_data.svg" class="org-svg" alt="histograms_properties_fake_vs_referenc_data.svg" />

<figcaption>Figure 32: <span class="figure-number">Figure 104: </span>Histograms showing the different distributions of the properties for the generated fake data compared to the real reference data from the CDL. At the lowest energies the properties start to diverge quite a bit, likely explaining the lower efficiency there.</figcaption>
</figure>


<figure id="orgde26d6f">
<img src="./figs/home/basti/org/Figs/statusAndProgress/systematics/scatter_plots_logL_parameters_fake_vs_ref_data.svg" class="org-svg" alt="scatter_plots_logL_parameters_fake_vs_ref_data.svg" />

<figcaption>Figure 33: <span class="figure-number">Figure 105: </span>Scatter plots of the different parameters going into the logL cut method comparing the CDL reference data &amp; the fake generated data. The cuts (X-ray for fake &amp; X-ray + reference for CDL) are applied.</figcaption>
</figure>


<p>
<b>NOTE</b>: One big TODO is the following:
</p>
<ul class="org-ul">
<li class="off"><code>[ ]</code> Currently the cut values for the LogL are computed using a
histogram of 200 bins, resulting in significant variance already in
the CDL data of around 1%. By increasing the number of bins this
variance goes to 0 (eventually it depends on the number of data
points). In theory I don&apos;t see why we can&apos;t compute the cut value
purely based on the unbinned data. Investigate / do this!</li>
<li class="off"><code>[ ]</code> Choose the final uncertainty for this variable that we want to use.</li>
</ul>
</div>


<ol class="org-ol">
<li><a id="sec:large_events_few_pixels_tot"> </a>(While generating fake data) Events with large energy, but few pixels<br />
<div class="outline-text-6" id="text-sec:large_events_few_pixels_tot">
<p>
While developing some fake data using existing events in the photo
peak &amp; filtering out pixels to end up at ~3 keV, I noticed the
prevalence of events with &lt;150 pixels &amp; ~6 keV energy.
</p>

<p>
Code produced by splicing in the following code into the body of <code>generateFakeData</code>.
</p>
<div class="org-src-container">
<pre class="src src-nim">    <span style="color: #F92672;">for</span> i <span style="color: #F92672;">in</span> <span style="font-style: italic;">0</span> ..&lt; xs.<span style="color: #F92672;">len</span>:
      <span style="color: #F92672;">if</span> xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> &lt; <span style="font-style: italic;">150</span> <span style="color: #F92672;">and</span> energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span> &gt; <span style="font-style: italic;">5</span>.<span style="font-style: italic;">5</span>:
        <span style="color: #75715E;"># </span><span style="color: #75715E;">recompute from data</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">pp </span>= toSeq<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span> ..&lt; xs<span style="color: #66D9EF;">[</span>i<span style="color: #66D9EF;">]</span>.<span style="color: #F92672;">len</span><span style="color: #AE81FF;">)</span>.mapIt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>x: xs<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, y: ys<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span>, ch: ts<span style="color: #A6E22E;">[</span>i<span style="color: #A6E22E;">][</span>it<span style="color: #A6E22E;">]</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">newEnergy </span>= h5f.computeEnergy<span style="color: #AE81FF;">(</span>pp, group, a, b, c, t, bL, mL<span style="color: #AE81FF;">)</span>
        <span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Length &quot;</span>, xs<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>.<span style="color: #F92672;">len</span> , <span style="color: #E6DB74;">&quot; w/ energy &quot;</span>, energyInput<span style="color: #AE81FF;">[</span>i<span style="color: #AE81FF;">]</span>, <span style="color: #E6DB74;">&quot; recomp &quot;</span>, newEnergy
        <span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= toDf<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;x&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.x.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;y&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.y.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span>, <span style="color: #E6DB74;">&quot;ch&quot;</span> : pp.mapIt<span style="color: #A6E22E;">(</span>it.ch.<span style="color: #66D9EF;">int</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
        ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;x&quot;</span>, <span style="color: #E6DB74;">&quot;y&quot;</span>, color = <span style="color: #E6DB74;">&quot;ch&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
          geom_point<span style="color: #AE81FF;">()</span> +
          ggtitle<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;funny its real&quot;</span><span style="color: #AE81FF;">)</span> + 
          ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;/tmp/fake_event.pdf&quot;</span><span style="color: #AE81FF;">)</span>
        sleep<span style="color: #AE81FF;">(</span><span style="font-style: italic;">200</span><span style="color: #AE81FF;">)</span>
    <span style="color: #F92672;">if</span> <span style="color: #AE81FF;">true</span>: <span style="color: #F92672;">quit</span><span style="color: #AE81FF;">()</span>
</pre>
</div>

<p>
This gives about 100 events that fit the criteria out of a total of
O(20000). A ratio of 1/200 seems probably reasonable for absorption of
X-rays at 5.9 keV.
</p>

<p>
While plotting them I noticed that they all share that they are
incredibly dense, like:
<img src="./figs/home/basti/org/Figs/statusAndProgress/exampleEvents/event_few_pixels_large_energy.svg" class="org-svg" alt="event_few_pixels_large_energy.svg" />
</p>

<p>
These events must be events where the X-ray to photoelectron
conversion happens very close to the grid!
This is one argument &quot;in favor&quot; of using <code>ToT</code> instead of ToA on the
Timepix1 and more importantly a good reason to keep using the <code>ToT</code>
values instead of pure pixel counting for at least some events!
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> We should look at number of pixels vs. energy as a scatter plot to see</li>
</ul>
<p>
what this gives us.
</p>
</div>
</li>
</ol>
</div>
</div>
</div>



<div class="outline-3" id="outline-container-sec:limit:mcmc_calc_limit">
<h3 id="sec:limit:mcmc_calc_limit"><span class="section-number-3">13.12.</span> MCMC to sample the distribution and compute a limit</h3>
<div class="outline-text-3" id="text-sec:limit:mcmc_calc_limit">
<p>
The Metropolis-Hastings algorithm
(<a href="./bibliography.html#citeproc_bib_item_158">Metropolis et al. 1953</a>; <a href="./bibliography.html#citeproc_bib_item_105">Hastings 1970</a>) – as mentioned in
sec. <a href="./limit.html#sec:limit:method_mcmc">13.7</a> – is used to evaluate the integral over
the nuisance parameters to get the posterior likelihood.
</p>

<p>
Instead of building a very long MCMC, we opt to construct 3 Markov
chains with \(\num{150000}\) links to reduce the bias introduced by the
starting parameters. Ideally, one would construct even more chains,
but a certain number of steps from the starting parameter are usually
needed to get into the parameter space of large contributions to the
integral (unless the starting parameters are chosen in a very confined
region, which itself is problematic in terms of bias). These are
removed as the &apos;burn in&apos; and make the number of chains and links in
each chain a trade off.
</p>

<p>
The MCMC is built based on 5 dimensional vectors \(\vec{x}\),
</p>

<p>
\[
\vec{x} = \mtrix{g_{ae}² &amp; ϑ_s &amp; ϑ_b &amp; ϑ_x &amp; ϑ_y}^T
\]
</p>

<p>
containing the coupling constant of interest squared as the first
entry and the four nuisance parameters after. Here we mention the
axion-electron coupling constant \(g²_{ae}\), but generally it can also
be for example \(g_{ae}²·g_{aγ}²\) (equivalent to \(g²_{ae}\)!), \(g⁴_{aγ}\)
or \(β⁴_γ\), depending on the search to be conducted. The important
point is that the parameter is used, under which the likelihood
function is <i>linear</i>, as we otherwise bias our sampling (see the
extended thesis for a longer explanation).
</p>

<p>
Our initial starting vector \(\vec{x_i}\)  is randomly sampled by
</p>

<p>
\[
\vec{x} = \vektor{
  \text{rand}([0, 5]) · g²_{\text{base}} \\
  \text{rand}([-0.4, 0.4]) \\
  \text{rand}([-0.4, 0.4]) \\
  \text{rand}([-0.5, 0.5]) \\
  \text{rand}([-0.5, 0.5]) \\
  }
\]
</p>

<p>
where \(\text{rand}\) refers to a uniform random sampler in the given
interval and \(g_{\text{base}}\) is a reference coupling parameter of
choice, which also depends on the specific search.
</p>

<p>
Our default reference coupling constant for \(g_{\text{base}}²\) <sup>  <a role="doc-backlink" class="footref" id="fnr.13" href="#fn.13">13</a></sup> is \(g_{ae}² =
\num{1e-21}\), allowing for a range of parameters in the expected
parameter space. The nuisance parameters are allowed to vary in a
large region, given the standard deviations of \(σ &lt; 0.05\) for all four
nuisance parameters. In the updating stage to propose a new vector, we
use the following:
</p>

<p>
\[
\vec{x_{i+1}} = \vec{x_i} +
  \vektor{
    \text{rand}([ -0.5 · 3 g²_{\text{base}}, 0.5 · 3 g²_{\text{base}} ]) \\
    \text{rand}([ -0.5 · 0.025, 0.5 · 0.025 ]) \\
    \text{rand}([ -0.5 · 0.025, 0.5 · 0.025 ]) \\
    \text{rand}([ -0.5 · 0.05,  0.5 · 0.05 ]) \\
    \text{rand}([ -0.5 · 0.05,  0.5 · 0.05 ]) \\
  }
\]
</p>

<p>
This combination leads to an acceptance rate of the new proposal
typically between \(\SIrange{20}{30}{\%}\). After all three chains are
built, the first \(\num{50000}\) links each are thrown out as burn-in to
make sure we only include meaningful parameter space.
</p>

<p>
The parameter space for each of the 5 elements is restricted based on
the following
</p>

<p>
\[
\vektor{
  g = [0, ∞] \\
  ϑ_s = [-1, 1] \\
  ϑ_b = [-0.8, 1] \\
  ϑ_x = [-1, 1] \\
  ϑ_y = [-1, 1]
},
\]
</p>

<p>
meaning we restrict ourselves to physical coupling constants and give
loose bounds on the nuisance parameters. In particular for the \(ϑ_b\)
parameter the restriction to values larger than \(ϑ_b &gt; -0.8\) is due to
the singularity in \(\mathcal{L}_M\) at \(ϑ_b = -1\). For all realistic
values for the systematic uncertainty \(σ_b\) the region of \(ϑ_b \ll 1\)
has no physical meaning anyway. But for unit tests and sanity checks
of the implementation, larger uncertainties are tested for, which
cause computational issues if this restriction was not in place.
</p>

<p>
Example Markov chains can be seen in fig. <a href="#fig:limit:mcmc_example">34</a>
where we see the different nuisance parameters of the chain and how
they are distributed. As expected for our comparatively small values
of \(σ\), the chain is centered around 0 for each nuisance
parameter. And the coupling constant in
fig. <a href="#fig:limit:mcmc_theta_x_y">34(b)</a> also shows a clear increase
towards low values. 
</p>


<figure class="figure-wrapper" id="fig:limit:mcmc_example">
<figure class="subfigure" id="fig:limit:mcmc_theta_s_b" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/mcmc_lines_thetas_sb_real_syst_real_random_cands_0.svg" data-width="99%" />  <figcaption>Figure 34(a): \includegraphics[width=0.03\textwidth]{/home/basti/org/Figs/panda-face_emoji_bubu.png} $ϑ_s$ vs. $ϑ_b$</figcaption></figure> <figure class="subfigure" id="fig:limit:mcmc_theta_x_y" data-width="49%">  <img src="./figs/~/phd/Figs/limit/sanity/mcmc_lines_thetas_gy_real_syst_real_random_cands_0.svg" data-width="99%" />  <figcaption>Figure 34(b): $g²$ vs. $ϑ_y$</figcaption></figure>
<figcaption>Figure 34: <a href="#fig:limit:mcmc_theta_s_b">34(a)</a>: MCMC of the $ϑ_s$ nuisance parameter against $ϑ_b$ with the
           coupling constant as the color scale. <a href="#fig:limit:mcmc_theta_x_y">34(b)</a>: MCMC of the coupling constant against $ϑ_x$ and $ϑ_y$ in color.
          Both show a clear centering to values around 0, with the coupling
          constant a decrease in population towards larger couplings.</figcaption>
</figure>


<p>
The resulting three Markov chains are finally used to compute the
marginal posterior likelihood function by computing the histogram of
all sampled \(g²\) values. The distribution of the sampled \(g²\) values is
that of the marginal posterior likelihood. This then allows to compute
a limit by computing the empirical distribution function of the
sampled \(g²\) values and extracting the value corresponding to the
\(95^{\text{th}}\) percentile. An example for this is shown in
fig. <a href="#fig:limit:mcmc_calc_limit:limit">35</a>.
</p>


<figure id="fig:limit:mcmc_calc_limit:limit">
<img src="./figs/home/basti/phd/Figs/limit/sanity/mcmc_histo_real_syst_real_random_cands_0.svg" class="org-svg" alt="mcmc_histo_real_syst_real_random_cands_0.svg" />

<figcaption>Figure 35: <span class="figure-number">Figure 106: </span>Example likelihood as a function of \(g_{ae}²\) for a set of toy candidates with the limit indicated at the intersection of the blue and red colored areas. Blue is the lower 95-th percentile of the integral over the likelihood function and red the upper 5-th.</figcaption>
</figure>
</div>


<div class="outline-4" id="outline-container-org367adf1">
<h4 id="org367adf1"><span class="section-number-4">13.12.1.</span> Generate example MCMC plots (incl. histogram)   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-12-1">
<p>
These plots are produced from the sanity checks in
<code>mcmc_limit_calculation</code>.
</p>

<p>
Note, if you run the command like this, it will take a while, because
it will compute several points using regular numerical integration
(Romberg). Pass <code>--rombergIntegrationDepth 2</code> to speed it up, but the
last plot may not be produced successfully (but we don&apos;t care about
that plot here):
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">DEBUG_TEX</span>=true <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true <span style="color: #E6DB74; font-weight: bold;">\</span>
mcmc_limit_calculation sanity <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --sanityPath ~/phd/Figs/limit/sanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --realSystematics <span style="color: #E6DB74; font-weight: bold;">\</span>
                       --rombergIntegrationDepth 3
</pre>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:mcmc:notes_variation_coupling_parameter">
<h4 id="sec:limit:mcmc:notes_variation_coupling_parameter"><span class="section-number-4">13.12.2.</span> Notes and thoughts about the coupling as MCMC element   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:limit:mcmc:notes_variation_coupling_parameter">
<p>
When evaluating the likelihood function using a MCMC approach, the
choice of \(g²_{ae}\) in our case is not arbitrary. It may however seem
surprising, given that the previous limits for \(g_{ae}\) are always
quoted and given as \(g_{ae}·g_{aγ}\). The reason is that when
calculating a limit on \(g_{ae}\) one typically works under the
assumption that the solar axion flux via the axion-photon coupling
\(g_{aγ}\) is negligible. This means production is \(g_{ae}\) based and
reconversion \(g_{aγ}\) based. As a result for \(g_{ae}\) searches in
helioscopes the axion-photon coupling can be taken as constant and
only \(g_{ae}\) be varied. The final limit must be quoted as a product
regardless.
</p>

<p>
See the sanity check <code>--axionElectronAxionPhoton</code> of
<code>mcmc_limit_calculation</code> for proof that the deduced limit does not
change as a function of \(g_{aγ}\). In it we compute the limit for a
fixed set of candidates at different \(g_{aγ}\) values. The resulting
limit on \(g_{ae}·g_{aγ}\) remains unchanged (of course, the limit
produced in \(g²_{ae}\) space <i>will</i> change, but that is precisely why
one must never quote the \(g²_{ae}\) &apos;limit&apos; as such. It is still only a
temporary number).
</p>

<p>
The choice of coupling parameter to use inside of the MCMC is based on
linearizing the space. We choose the parameter under which the
likelihood function is a linear function. For the axion-electron
coupling – under the above stated assumptions – the likelihood via
the signal \(s\) is a linear function of \(g²_{ae}\) for a fixed value of
\(g²_{aγ}\). An <i>equivalent</i> way to parametrize the likelihood function
as a linear function is by usage of \(g²_{ae}·g²_{aγ}\), hence this
being a common choice in past papers. This produces the <b>same limit</b>
as the \(g²_{ae}\) limit. See the sanity check
<code>--axionElectronAxionPhotonLimit</code> of <code>mcmc_limit_calculation</code>, in
which we compute limits based on \(g²_{ae}·g²_{aγ}\) instead and see
that the limit is the same.
</p>

<p>
<i>Importantly though</i>, using \(g_{ae}·g_{aγ}\) (without the square) as an
argument to the MCMC does <b>not</b> linearize it and thus produces a wrong
limit.
</p>

<p>
For a search for the axion-photon coupling alone or the chameleon
coupling, the single coupling constant affects <i>both</i> the production
in the sun via \(g²_{aγ}\), \(β²_γ\) as well as the conversion probability
in the magnet. This means for these searches we <i>have</i> to use
\(g⁴_{aγ}\) and \(β⁴_γ\) as arguments to the MCMC.
</p>

<dl class="org-dl">
<dt>Why is that?</dt><dd><p>
The reason for this behavior is due to the random
sampling nature of the MCMC. The basic algorithm that adds new links
to the Markov chain works by <i>uniformly</i> sampling new values for
each entry of the parameter vector. <i>Uniform</i> is the crucial
point. If we work with parameters under which the likelihood
function is <i>not</i> linear and we uniformly sample that non-linear
parameter, we produce an effective <i>non-linear</i> sampling of the
linearized function.
</p>

<p>
For example for the axion-photon coupling \(g_{aγ}\), if wrongly use
\(g²_{aγ}\) in the MCMC, sample new values within
</p>

<p>
\[
  \text{rand}([0, 5]) · g²_{aγ, \text{base}} 
  \]
</p>

<p>
and <i>then</i> rescale \(s\) via:
</p>

<p>
\[
  s&apos;(g⁴_{aγ}) = α · f(g²_{aγ, \text{base}}) · P(g²_{aγ, \text{base}}) ·
  \left( \frac{g²_{aγ, \text{base}}}{g²_{aγ, \text{base}}} \right)²
  \]
</p>

<p>
we square \(g²_{aγ}\) again. This means we effectively did not perform
a <i>uniform</i> sampling at all! This directly affects the samples and
as a result the limit. The shape of the histogram of all coupling
constants ends up as stretched because of this.
</p></dd>
</dl>
</div>
</div>
</div>

<div class="outline-3" id="outline-container-sec:limit:expected_limits">
<h3 id="sec:limit:expected_limits"><span class="section-number-3">13.13.</span> Expected limits of different setups</h3>
<div class="outline-text-3" id="text-sec:limit:expected_limits">
<p>
One interesting approach to compute the expected limit usually
employed in binned likelihood approaches is the so called &apos;Asimov
dataset&apos;. The idea is to compute the limit based on the dataset, which
matches exactly the expectation value for each Poisson in each
bin. This has the tremendous computational advantage of providing an
expected limit by only computing the limit for a <i>single, very special</i>
candidate set. Unfortunately, for an unbinned approach this is less
straightforward, because there is no explicit mean of expectation
values anymore. On the other hand, the Asimov dataset calculation does
not provide information about the possible spread of all limits due to
the statistical variation possible in toy candidate sets. 
</p>

<p>
In our case then, we fall back to computing an expected limit based on
toy candidate sets (sec. <a href="./limit.html#sec:limit:method_expected_limit">13.5</a>) that we
draw from a discretized, grid version of the background interpolation,
as explained in sec. <a href="./limit.html#sec:limit:ingredients:candidates">13.10.9</a>.
</p>

<p>
We compute expected limits for different possible combinations of
classifier and detector vetoes, due to the signal efficiency penalties
that these imply. In a first rough &apos;scan&apos; we compute expected limits
based on a smaller number of toy candidates. The exact number depends
on the particular setup.
</p>

<ul class="org-ul">
<li>\(\num{1000}\) toys for setups using only a classifier without any
vetoes. Due to the much more background towards the corners (see
sec. <a href="./background.html#sec:background:all_vetoes_combined">12.6</a>), many more candidates are
sampled making computation significantly slower</li>
<li>\(\num{2500}\) toys for setups with the line or septem veto. Much
fewer total expected number of candidates, and hence much faster.</li>
</ul>

<p>
Then we narrow it down and compute \(\num{15000}\) toy limits for the
best few setups. Finally, we compute \(\num{50000}\) toys for the best
setup we find. The resulting setup is the one for which we unblind the
solar tracking data. 
</p>

<p>
Tab. <a href="#tab:limit:expected_limits">26</a> shows the different setups with their
respective expected limits. Some setups appear multiple times for the
different number of toy candidates that were run. It can be seen as an
extension of tab. <a href="#tab:background:background_rate_eff_comparisons">24</a> in
sec. <a href="./background.html#sec:background:all_vetoes_combined">12.6</a>. Also shown is the limit
achieved in case no candidate is present in the signal sensitive
region, as a theoretical lower bound on the limit. This &apos;no candidate&apos;
limit scales down with the total efficiency, as one would expect. All
limits are given as limits on \(g_{ae}·g_{aγ}\) based on a fixed \(g_{aγ}
= \SI{1e-12}{GeV⁻¹}\). Finally, it shows a standard variation
corresponding to how the expected limit varies when bootstrapping new
sets of limits (standard deviation of \(\num{1000}\) bootstrapped
expected limits sampling \(\num{10000}\) limits from the input). The
table does not show all setups that were initially considered. Further
considerations of other possible parameters were excluded in
preliminary studies on their effect on the expected limit.
</p>

<p>
In particular:
</p>
<ul class="org-ul">
<li>the scintillator veto is always used. It does not come with an
efficiency penalty and therefore there is no reason not to activate
it.</li>
<li>different FADC veto efficiencies as well as disabling it completely
were considered. The current \(ε_{\text{FADC}} = 0.98\) efficiency was
deemed optimal. Harder cuts do not yield significant improvements.</li>
<li>the potential eccentricity cutoff for the line veto, as discussed in
sec. <a href="./background.html#sec:background:line_veto">12.5.4</a> is fully disabled, as the efficiency
gains do not outweigh the positive effect on the expected limit in
practice.</li>
</ul>

<p>
Based on this study, the MLP produces the best expected limit,
surprisingly without any vetoes at software efficiencies of
\(\SI{98.04}{\%}\), \(\SI{90.59}{\%}\) and \(\SI{95.23}{\%}\). However, for
these case we did not run any more toy limits, because not having any
of the septem or line means there are a large number of candidates
towards the chip corners. These slow down the calculation, making it
too costly to run. In any case, given the small difference in the
expected limit between this case and the first including vetoes, the
MLP at \(\SI{95.23}{\%}\) with the line veto, we prefer to stick with
the addition of vetoes. The very inhomogeneous background rates are
problematic, as they make the result much more strongly dependent on
the value of the systematic position uncertainty. Also, for other
limit calculations with larger raytracing images, a lower background
over a larger area at the cost of lower total efficiency is more
valuable.
</p>

<p>
In this case with the line veto, the software efficiency
\(ε_{\text{eff}}\) corresponds to a target software efficiency based on
the simulated X-ray data of \(\SI{95}{\%}\). The total combined
efficiency comes out to \(\SI{79.69}{\%}\) (excluding the detection
efficiency of course!). This is the setup we will mainly consider for
the data unblinding. The expected limit for this setup is
</p>

<p>
\[
\left(g_{ae} · g_{aγ}\right)_{\text{expected}} = \SI{7.878225(6464)e-23}{GeV^{-1}},
\]
</p>

<p>
based on the \(\num{50 000}\) toy limits. The uncertainty is based on
the standard deviation computed via bootstrapping as mentioned
above. It is the uncertainty on the expected limit from a statistical
point of view. 
</p>

<p>
\footnotesize
</p>
<table id="tab:limit:expected_limits">
<caption class="t-above"><span class="table-number">Table 26:</span> The FADC veto is always in use (if either the septem or line veto are active) at an efficiency of \(ε_{\text{FADC}} = 0.98\) and so is the scintillator veto. These settings were defined in preliminary studies of the expected limits. Note the efficiencies associated with the septem veto \(ε_{\text{septem}} = \SI{83.11}{\%}\) and the line veto \(ε_{\text{line}} = \SI{85.39}{\%}\) and combined \(ε_{\text{septem+line}} = \SI{78.63}{\%}\), which are implicitly included based on the &apos;Septem&apos; and &apos;Line&apos; column values into the total efficiency \(ε_{\text{total}}\). &apos;No signal&apos; is the limit without any candidates, &apos;Exp. \(σ\)&apos; the bootstrapped standard deviation of the expected limit.</caption>

<colgroup>
<col class="org-right" />

<col class="org-right" />

<col class="org-left" />

<col class="org-left" />

<col class="org-left" />

<col class="org-right" />

<col class="org-right" />

<col class="org-right" />

<col class="org-right" />
</colgroup>
<thead>
<tr>
<th class="org-right" scope="col">ε<sub>eff</sub></th>
<th class="org-right" scope="col">nmc</th>
<th class="org-left" scope="col">Type</th>
<th class="org-left" scope="col">Septem</th>
<th class="org-left" scope="col">Line</th>
<th class="org-right" scope="col">ε<sub>total</sub></th>
<th class="org-right" scope="col">No signal [GeV⁻¹]</th>
<th class="org-right" scope="col">Expected [GeV⁻¹]</th>
<th class="org-right" scope="col">Exp. σ [GeV⁻¹]</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">0.9804</td>
<td class="org-right">1000</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.9804</td>
<td class="org-right">5.739e-23</td>
<td class="org-right">7.805e-23</td>
<td class="org-right">3.6807e-25</td>
</tr>

<tr>
<td class="org-right">0.9059</td>
<td class="org-right">1000</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.9059</td>
<td class="org-right">6.0109e-23</td>
<td class="org-right">7.856e-23</td>
<td class="org-right">4.301e-25</td>
</tr>

<tr>
<td class="org-right">0.9523</td>
<td class="org-right">1000</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.9523</td>
<td class="org-right">5.7685e-23</td>
<td class="org-right">7.8599e-23</td>
<td class="org-right">5.1078e-25</td>
</tr>

<tr>
<td class="org-right">0.9523</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.7969</td>
<td class="org-right">6.3874e-23</td>
<td class="org-right">7.8615e-23</td>
<td class="org-right">2.9482e-25</td>
</tr>

<tr>
<td class="org-right">0.9523</td>
<td class="org-right">50000</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.7969</td>
<td class="org-right">6.3874e-23</td>
<td class="org-right">7.8782e-23</td>
<td class="org-right">6.4635e-26</td>
</tr>

<tr>
<td class="org-right">0.9804</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.8204</td>
<td class="org-right">6.1992e-23</td>
<td class="org-right">7.8833e-23</td>
<td class="org-right">2.9977e-25</td>
</tr>

<tr>
<td class="org-right">0.8587</td>
<td class="org-right">1000</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.8587</td>
<td class="org-right">6.1067e-23</td>
<td class="org-right">7.9597e-23</td>
<td class="org-right">5.0781e-25</td>
</tr>

<tr>
<td class="org-right">0.9059</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.7581</td>
<td class="org-right">6.4704e-23</td>
<td class="org-right">7.9886e-23</td>
<td class="org-right">2.6437e-25</td>
</tr>

<tr>
<td class="org-right">0.9804</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.7554</td>
<td class="org-right">6.5492e-23</td>
<td class="org-right">8.0852e-23</td>
<td class="org-right">2.9225e-25</td>
</tr>

<tr>
<td class="org-right">0.9523</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">false</td>
<td class="org-right">0.7756</td>
<td class="org-right">6.4906e-23</td>
<td class="org-right">8.1135e-23</td>
<td class="org-right">3.5689e-25</td>
</tr>

<tr>
<td class="org-right">0.9523</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.7338</td>
<td class="org-right">6.6833e-23</td>
<td class="org-right">8.1251e-23</td>
<td class="org-right">3.0965e-25</td>
</tr>

<tr>
<td class="org-right">0.9804</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">false</td>
<td class="org-right">0.7985</td>
<td class="org-right">6.2664e-23</td>
<td class="org-right">8.1314e-23</td>
<td class="org-right">3.1934e-25</td>
</tr>

<tr>
<td class="org-right">0.8587</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.7186</td>
<td class="org-right">6.8094e-23</td>
<td class="org-right">8.1561e-23</td>
<td class="org-right">2.9893e-25</td>
</tr>

<tr>
<td class="org-right">0.9059</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">false</td>
<td class="org-right">0.7378</td>
<td class="org-right">6.5184e-23</td>
<td class="org-right">8.2169e-23</td>
<td class="org-right">2.8767e-25</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.7531</td>
<td class="org-right">6.4097e-23</td>
<td class="org-right">8.2171e-23</td>
<td class="org-right">3.7248e-25</td>
</tr>

<tr>
<td class="org-right">0.9059</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.6981</td>
<td class="org-right">6.8486e-23</td>
<td class="org-right">8.2868e-23</td>
<td class="org-right">3.2593e-25</td>
</tr>

<tr>
<td class="org-right">0.8587</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">false</td>
<td class="org-right">0.6994</td>
<td class="org-right">6.7322e-23</td>
<td class="org-right">8.4007e-23</td>
<td class="org-right">2.9498e-25</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.6935</td>
<td class="org-right">6.7386e-23</td>
<td class="org-right">8.4274e-23</td>
<td class="org-right">3.3644e-25</td>
</tr>

<tr>
<td class="org-right">0.8587</td>
<td class="org-right">2500</td>
<td class="org-left">MLP</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.6617</td>
<td class="org-right">6.9981e-23</td>
<td class="org-right">8.4589e-23</td>
<td class="org-right">3.4966e-25</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.6695</td>
<td class="org-right">6.9115e-23</td>
<td class="org-right">8.4993e-23</td>
<td class="org-right">3.1983e-25</td>
</tr>

<tr>
<td class="org-right">0.9</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.9</td>
<td class="org-right">5.9862e-23</td>
<td class="org-right">8.5786e-23</td>
<td class="org-right">3.7241e-25</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.8</td>
<td class="org-right">6.3885e-23</td>
<td class="org-right">8.7385e-23</td>
<td class="org-right">3.903e-25</td>
</tr>

<tr>
<td class="org-right">0.8</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.6165</td>
<td class="org-right">7.1705e-23</td>
<td class="org-right">8.747e-23</td>
<td class="org-right">4.099e-25</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">true</td>
<td class="org-right">0.5858</td>
<td class="org-right">7.4553e-23</td>
<td class="org-right">8.9298e-23</td>
<td class="org-right">4.0495e-25</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">false</td>
<td class="org-left">false</td>
<td class="org-right">0.7</td>
<td class="org-right">6.7647e-23</td>
<td class="org-right">9.0856e-23</td>
<td class="org-right">3.3235e-25</td>
</tr>

<tr>
<td class="org-right">0.7</td>
<td class="org-right">2500</td>
<td class="org-left">LnL</td>
<td class="org-left">true</td>
<td class="org-left">true</td>
<td class="org-right">0.5394</td>
<td class="org-right">7.7018e-23</td>
<td class="org-right">9.2565e-23</td>
<td class="org-right">3.4573e-25</td>
</tr>
</tbody>
</table>
<p>
\normalsize
</p>

<p>
The distribution of all toy limits for this best setup can be seen in
fig. <a href="#fig:limit:expected_limits:toy_limit_histogram">36</a>. It shows both the
limit for the case without any candidates (red line, equivalent to &apos;No
signal&apos; in the table above) as well as the expected limit (blue
line). Depending on the number of candidates that are inside the
signal sensitive region (in regions of the solar axion image with
significant flux expectation) based on \(\ln(1 + s_i/b_i) &gt; 0.5\) (at a
fixed coupling constant, \(g²_{ae} = (\num{8.1e-11})²\)), the limits are
split into histograms of different colors. Based on the location of
these histograms and the expected limit, the most likely case for the
real candidates seems to be 1 or 2 candidates in that region. Note
that there are some toy limits that are below the red line for the
case without candidates. This is expected, because the calculation of
each limit is based on the MCMC evaluation of the likelihood. As such
it is a statistical random process and the red line itself is a single
sample. Further, the purple histogram for &quot;0&quot; candidates is <b>not</b>
equivalent to the red line, because the definition of the number of
signal sensitive candidates is an arbitrary cutoff. For the red line
literally <span class="underline">no candidates</span> at all are considered and the limit is based
purely on the \(\exp(-s_{\text{tot}})\) term of the likelihood.
</p>


<figure id="fig:limit:expected_limits:toy_limit_histogram">
<img src="./figs/home/basti/phd/Figs/limit/mc_limit_lkMCMC_skInterpBackground_nmc_50000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_nmc_50k_pretty.svg" class="org-svg" alt="mc_limit_lkMCMC_skInterpBackground_nmc_50000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_nmc_50k_pretty.svg" />

<figcaption>Figure 36: <span class="figure-number">Figure 107: </span>Distribution of toy limits resulting in the best expected limit based on \(\num{50000}\) toy limits. The expected limit – the median – is shown as the blue line. The red line shows the limit for the case without any candidates. The different colored histograms correspond to toy sets with a different number of toy candidates in the signal sensitive region, defined by \(\ln(1 + s_i/b_i) &gt; 0.5\). The most likely number of candidates in the sensitive region seems to be 0, 1 or 2.</figcaption>
</figure>

<p>
To see how the limit might change as a function of different
candidates, see tab. <a href="#tab:appendix:expected_limits_percentiles">31</a> in
appendix <a href="./limit_additional.html#sec:appendix:exp_limit_percentiles">33.2</a>. It contains different
percentiles of the computed toy limit distribution for each veto
setup. The percentiles – and ranges between them – give insight into
the probabilities to obtain a specific observed limit. Each observed
limit is associated with a single possible set of candidates,
measureable in the experiment, out of all possible sets of candidates
compatible with the background hypothesis (as the toy limits are
sampled from it). For example, the experiment will measure an observed
limit in the range from \(P_{25}\) to \(P_{75}\) with a chance of
\(\SI{50}{\%}\).
</p>
</div>

<div class="outline-4" id="outline-container-orgff8227f">
<h4 id="orgff8227f"><span class="section-number-4">13.13.1.</span> Verification</h4>
<div class="outline-text-4" id="text-13-13-1">
<p>
Because of the significant complexity of the limit calculation, a
large number of sanity checks were written. They are used to verify all
internal results are consistent with expectation. They include things
like verifying the background interpolation reproduces a compatible
background rate or the individual \(s_i\) terms of the likelihood
reproduce the total \(s_{\text{tot}}\) term, while producing sensible numbers.
</p>

<p>
The details of this verification are left out of the main thesis, but
can be found in the extended version after this section.
</p>
</div>
</div>

<div class="outline-4" id="outline-container-orgafa13e6">
<h4 id="orgafa13e6"><span class="section-number-4">13.13.2.</span> Notes on all limit calculations   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-13-2">
<p>
All the notes about the expected limits are here:
<a href="./../org/journal.html">./../org/journal.html</a>.
</p>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:gen_expected_limit_table">
<h4 id="sec:limit:gen_expected_limit_table"><span class="section-number-4">13.13.3.</span> Generate expected limits table   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:limit:gen_expected_limit_table">
<p>
Originally written in
<a href="./../org/journal.html">./../org/journal.html</a>.
</p>

<div class="org-src-container">
<pre class="src src-sh">./generateExpectedLimitsTable --path ~/org/resources/lhood_limits_21_11_23/ --prefix <span style="color: #E6DB74;">&quot;mc_limit_lkMCMC&quot;</span> 
</pre>
</div>
</div>
</div>



<div class="outline-4" id="outline-container-org0e050e2">
<h4 id="org0e050e2"><span class="section-number-4">13.13.4.</span> Generate plot of expected limit histogram   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-13-4">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotFile ~/org/resources/lhood_limits_21_11_23/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/mc_limit_lkMCMC_skInterpBackground_nmc_50000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLow 2.5e-21 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xHigh 1.5e-20 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yHigh 1300 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --bins 100 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --linesTo 800 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --as_gae_gaγ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLabel <span style="color: #E6DB74;">&quot;Limit g_ae·g_aγ [GeV⁻¹]&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yLabel <span style="color: #E6DB74;">&quot;MC toy count&quot;</span>  <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/limit/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;_nmc_50k_pretty&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 50000
</pre>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:expected_limits:best_expected_50k">
<h4 id="sec:limit:expected_limits:best_expected_50k"><span class="section-number-4">13.13.5.</span> Run limit for 50k toys   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:limit:expected_limits:best_expected_50k">
<p>
Now run the best case scenario again for 50k toys! <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-11-26 Sun 21:27&gt;</span></span>.
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/org/resources/lhood_limits_21_11_23/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 50000
</pre>
</div>
<p>
It finished at some point during the night. 
</p>
</div>
</div>
</div>



<div class="outline-3" id="outline-container-sec:limit:candidates">
<h3 id="sec:limit:candidates"><span class="section-number-3">13.14.</span> Solar tracking candidates</h3>
<div class="outline-text-3" id="text-sec:limit:candidates">
<p>
Based on the best performing setup we can now look at the solar
tracking candidates. <sup>  <a role="doc-backlink" class="footref" id="fnr.14" href="#fn.14">14</a></sup> In this setup, based on the
background model a total of \(\num{845}\) candidates are expected over
the entire chip. <sup>  <a role="doc-backlink" class="footref" id="fnr.15" href="#fn.15">15</a></sup> Computing the real candidates
yields a total of \(\num{850}\) clusters over the chip. A figure
comparing the rate observed for the candidates compared to the
background over the entire chip is shown in
fig. <a href="#fig:limit:rate_candidates_background">38(b)</a>. 
</p>

<p>
Fig. <a href="#fig:limit:candidates">37</a> shows all solar tracking candidates that are
observed with the method yielding the best expected limit. Their
energy is color coded and written above each cluster within a
\(\SI{85}{pixel}\) radius of the chip center. The axion image is
underlaid to provide a visual reference of the importance of each
cluster. Very few candidates of relevant energies are seen within the
region of interest. Based on the previously mentioned \(\ln(1 +
s_i/b_i) &gt; 0.5\) condition, it is 1 candidate in the sensitive
region. See fig. <a href="#fig:limit:candidates_s_b">38(a)</a> for an overview of the
weighting of each candidate in this way, with only the single cluster
near coordinate \((x,y) = (105,125)\) crossing the threshold of \(\num{0.5}\).
</p>


<figure id="fig:limit:candidates">
<img src="./figs/home/basti/phd/Figs/trackingCandidates/background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" class="org-svg" alt="background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" />

<figcaption>Figure 37: <span class="figure-number">Figure 108: </span>Overview of all solar tracking candidates given the MLP@\SI{95}{\%} setup including all vetoes except the septem veto. \(\num{850}\) clusters are observed, with the majority low energy clusters in the chip corners. The axion image is underlaid and the energy of each cluster is color coded. For all candidates within a radius of \(\SI{85}{pixels}\) of the center the energy is also written above. We can see by eye that very few candidates of relevant energies are present in the region of expected signal.</figcaption>
</figure>


<figure class="figure-wrapper" id="fig:limit:candidates_s_b_rates">
<figure class="subfigure" id="fig:limit:candidates_s_b" data-width="49%">  <img src="./figs/~/phd/Figs/trackingCandidates/real_candidates_signal_over_background.svg" data-width="99%" />  <figcaption>Figure 38(a): $\ln(1 + s_i/b_i)$</figcaption></figure> <figure class="subfigure" id="fig:limit:rate_candidates_background" data-width="49%">  <img src="./figs/~/phd/Figs/trackingCandidates/rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.svg" data-width="99%" />  <figcaption>Figure 38(b): Rate candidates vs. background</figcaption></figure>
<figcaption>Figure 38: <a href="#fig:limit:candidates_s_b">38(a)</a>: Weighting of each candidate based on $\ln(1 + s_i/b_i)$. The largest weight given is for the \SI{2.96}{keV} cluster seen in fig. <a href="#fig:limit:candidates">37</a> near pixel $(105,125)$ and tops out at slighlty above $\num{0.5}$. <a href="#fig:limit:rate_candidates_background">38(b)</a>: Rate of background and candidate clusters over the entire chip as a log plot. Rates are
          generally compatible over the entire range.</figcaption>
</figure>
</div>

<div class="outline-4" id="outline-container-org9252ab7">
<h4 id="org9252ab7"><span class="section-number-4">13.14.1.</span> Rate plot comparing background to candidates   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-14-1">
<p>
Combined:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">ESCAPE_LATEX</span>=true plotBackgroundRate <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --centerChip 3 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --names <span style="color: #E6DB74;">&quot;Background&quot;</span> --names <span style="color: #E6DB74;">&quot;Background&quot;</span> --names <span style="color: #E6DB74;">&quot;Candidates&quot;</span> --names <span style="color: #E6DB74;">&quot;Candidates&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;Rate over whole chip, MLP@95 % + line veto&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --showNumClusters <span style="color: #E6DB74; font-weight: bold;">\</span>
    --region crAll <span style="color: #E6DB74; font-weight: bold;">\</span>
    --showTotalTime <span style="color: #E6DB74; font-weight: bold;">\</span>
    --topMargin 1.5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyDset energyFromCharge <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outfile rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.pdf <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --logPlot <span style="color: #E6DB74; font-weight: bold;">\</span>
    --hideErrors <span style="color: #E6DB74; font-weight: bold;">\</span>
    --useTeX <span style="color: #E6DB74; font-weight: bold;">\</span>
    --quiet
</pre>
</div>


<figure id="org583edef">
<img src="./figs/home/basti/phd/Figs/trackingCandidates/rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.svg" class="org-svg" alt="rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.svg" />

</figure>

<p>
-&gt; The two seem pretty compatible. Maybe there is minutely more in the
middle range than expected, but I suppose that is a statistical effect.
</p>
</div>
</div>


<div class="outline-4" id="outline-container-org973a004">
<h4 id="org973a004"><span class="section-number-4">13.14.2.</span> <b>OUTDATED</b> Rate plot comparing background to candidates   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-14-2">
<p>
Combined:
</p>
<div class="org-src-container">
<pre class="src src-sh">plotBackgroundRate <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/org/resources/lhood_limits_10_05_23_mlp_sEff_0.99/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh300_msecheckpoint_epoch_485000_loss_0.0055_acc_0.9933_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/org/resources/lhood_limits_10_05_23_mlp_sEff_0.99/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh300_msecheckpoint_epoch_485000_loss_0.0055_acc_0.9933_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/Sync/lhood_tracking_scinti_line_mlp_0.95_2017.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/Sync/lhood_tracking_scinti_line_mlp_0.95_2018.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --centerChip 3 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --names <span style="color: #E6DB74;">&quot;Background&quot;</span> --names <span style="color: #E6DB74;">&quot;Background&quot;</span> --names <span style="color: #E6DB74;">&quot;Candidates&quot;</span> --names <span style="color: #E6DB74;">&quot;Candidates&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;Rate over whole chip, MLP@91 % + line veto,&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --showNumClusters <span style="color: #E6DB74; font-weight: bold;">\</span>
    --region crAll <span style="color: #E6DB74; font-weight: bold;">\</span>
    --showTotalTime <span style="color: #E6DB74; font-weight: bold;">\</span>
    --topMargin 1.5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyDset energyFromCharge <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outfile rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.pdf <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/org/Figs/statusAndProgress/trackingCandidates/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --logPlot <span style="color: #E6DB74; font-weight: bold;">\</span>
    --hideErrors <span style="color: #E6DB74; font-weight: bold;">\</span>
    --quiet
</pre>
</div>


<figure id="orgdfa4df6">
<img src="./figs/home/basti/org/Figs/statusAndProgress/trackingCandidates/rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.svg" class="org-svg" alt="rate_real_candidates_vs_background_rate_crAll_mlp_0.95_scinti_fadc_line.svg" />

</figure>

<p>
Below 1 keV the candidates are <span class="underline">always</span> in excess. At higher energies
maybe there is still a slight excess, yes, but it <b>seems</b> (may not be
though) to be more in line with expectation. 
</p>
</div>
</div>



<div class="outline-4" id="outline-container-org7cf2dba">
<h4 id="org7cf2dba"><span class="section-number-4">13.14.3.</span> Perform the data unblinding and produce plots   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-14-3">
<ol class="org-ol">
<li>run <code>likelihood</code> with <code>--tracking</code></li>
<li>compute <code>mcmc_limit_calculation</code> based on the files</li>
</ol>

<p>
Running tracking classification for the best performing setup, MLP@95%
plus all vetoes except septem <span class="timestamp-wrapper">  <span class="timestamp">&lt;2023-11-27 Mon 12:16&gt;</span></span>:
</p>
<div class="org-src-container">
<pre class="src src-sh">./createAllLikelihoodCombinations <span style="color: #E6DB74; font-weight: bold;">\</span>
    --f2017 ~/CastData/data/DataRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --f2018 ~/CastData/data/DataRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --c2017 ~/CastData/data/CalibrationRuns2017_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --c2018 ~/CastData/data/CalibrationRuns2018_Reco.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --regions crAll <span style="color: #E6DB74; font-weight: bold;">\</span>
    --vetoSets <span style="color: #E6DB74;">&quot;{+fkMLP, +fkFadc, +fkScinti, fkLineVeto}&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --mlpPath ~/org/resources/nn_devel_mixing/17_11_23_adam_tanh30_sigmoid_mse_3keV/mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662.pt <span style="color: #E6DB74; font-weight: bold;">\</span>
    --fadcVetoPercentile 0.99 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --signalEfficiency 0.95 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --out ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --cdlFile ~/CastData/data/CDL_2019/calibration-cdl-2018.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --multiprocessing <span style="color: #E6DB74; font-weight: bold;">\</span>
    --jobs 8 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking <span style="color: #E6DB74; font-weight: bold;">\</span>
    --dryRun
</pre>
</div>
<pre class="example">
Running all likelihood combinations took 399.9733135700226 s
</pre>
<p>
Finished!
</p>

<p>
I&apos;m scared.
</p>
</div>
</div>

<div class="outline-4" id="outline-container-sec:limit:candidates:generate_candidate_plot">
<h4 id="sec:limit:candidates:generate_candidate_plot"><span class="section-number-4">13.14.4.</span> Generate plots for real candidates   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:limit:candidates:generate_candidate_plot">
<p>
Using the files created in the previous section, let&apos;s create some plots.
</p>

<div class="org-src-container">
<pre class="src src-sh">plotBackgroundClusters <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;MLP@95+FADC+Scinti+Line tracking clusters&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;mlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --filterNoisyPixels <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyText <span style="color: #E6DB74; font-weight: bold;">\</span>
    --colorBy energy <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyTextRadius 85.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --useTikZ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --singlePlot
</pre>
</div>


<figure id="org00effec">
<img src="./figs/home/basti/phd/Figs/trackingCandidates/background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" class="org-svg" alt="background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" />

</figure>
</div>
</div>


<div class="outline-4" id="outline-container-org04fa1a9">
<h4 id="org04fa1a9"><span class="section-number-4">13.14.5.</span> <b>OUTDATED</b> Generate plots for real candidates   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-14-5">
<p>
Using the files created in the previous section, let&apos;s create some plots.
</p>

<p>
(from <code>journal.org</code>)
</p>

<div class="org-src-container">
<pre class="src src-sh">plotBackgroundClusters <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/Sync/lhood_tracking_scinti_line_mlp_0.95_2017.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    /home/basti/Sync/lhood_tracking_scinti_line_mlp_0.95_2018.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;MLP@95+FADC+Scinti+Line tracking clusters&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/org/Figs/statusAndProgress/trackingCandidates/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;mlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --filterNoisyPixels <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage /home/basti/org/resources/axion_images/axion_image_2018_1487_93_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyText <span style="color: #E6DB74; font-weight: bold;">\</span>
    --colorBy energy <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyTextRadius 85.0
</pre>
</div>


<figure id="orgc2545d2">
<img src="./figs/home/basti/org/Figs/statusAndProgress/trackingCandidates/background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" class="org-svg" alt="background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_axion_image_with_energy_radius_85.svg" />

</figure>
</div>
</div>


<div class="outline-4" id="outline-container-org3ec6a54">
<h4 id="org3ec6a54"><span class="section-number-4">13.14.6.</span> Number of background clusters expected   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-14-6">
<p>
This is part of the <code>sanityCheckBackgroundSampling</code> procedure in the
limit code.
</p>

<p>
Running it on the MLP@95 + line veto files yields:
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation sanity --limitKind lkMCMC
</pre>
</div>

<ul class="org-ul">
<li class="off"><code>[ ]</code> <b>FURTHER INVESTIGATE</b> the missing time!</li>
</ul>
</div>
</div>


<div class="outline-4" id="outline-container-sec:limit:candidates:septemboard_layout_transformations">
<h4 id="sec:limit:candidates:septemboard_layout_transformations"><span class="section-number-4">13.14.7.</span> Determine correct rotation for candidates   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-sec:limit:candidates:septemboard_layout_transformations">
<p>
We know we need to apply a rotation to the candidates, because the
Septemboard detector is rotated in relation to the native &apos;readout&apos;
direction. In principle the detector is rotated by \(\SI{90}{°}\).  See
fig. <a href="#fig:detector:full_septemboard_exploded">16</a>, the larger spacing
between the middle and bottom row is parallel to the high voltage
bracket. The HV bracket was installed such that it leads the cables
outside the lead housing.
</p>

<p>
Reminder about the Septemboard layout: (why did I not just do it in
inkscape?)
<a id="septemboard_layout_view"> </a>
</p>
<div class="org-src-container">
<pre class="src src-sh">Coordinate system for chips *5* and *6*, each!
     0         256
256  +----------&gt; x
     |
     |
     |           =================         Legend:
  0  v           +-------+-------+         ======= &lt;- chip bonding area
     y           |       |       |        
                 |   6   |   5   |         
                 |       |       |
             +---+---+---+---+---+---+  
             |       |       |       |         
             |   2   |   3   |   4   |  
             |       |       |       |         
             +-------+-------+-------+         
             =========================         
                                               
256  y           +-------+-------+             
     ^           |       |       |             
     |           |   0   |   1   |             
     |           |       |       |             
     |           +-------+-------+             
     |           =================             
     |                                         
     |                                         
     |                                         
   0 +---------------------&gt; x   
    256                    0 

  ^--- Coordinates of chips 0, 1, 2, 3, 4 *each*
</pre>
</div>
<p>
Note that chips 5 and 6 are &quot;inverted&quot; in their ordering /
numbering. Also note the inversion of the coordinate systems for chips
5 and 6 due to being installed upside down compared to the other
chips. 
</p>

<p>
Keep this in mind for the explanation below:
</p>

<p>
This <i>should</i> imply that seen <b>from the front</b> (i.e. looking from the
telescope onto the septemboard):
</p>
<ul class="org-ul">
<li>the top row is on the right hand side vertically, so that chip 6 is
in the top right, chip 5 in the bottom right.</li>
<li>the center row is vertically in the center. Chip 2 is in the top
middle, chip 3 (== center chip) obviously in the middle and chip 4
in the bottom middle</li>
<li>the bottom row is on the left vertically. Chip 0 is in the top left
and chip 1 in the bottom left.</li>
</ul>

<p>
In this way the schematic above should be rotated by \(\SI{90}{°}\)
<i>clockwise</i>.
</p>

<p>
Kind of like this:
<a id="cast_septemboard_view"> </a>
</p>
<div class="org-src-container">
<pre class="src src-sh">                                         Legend:
               ‖+-------+                  ‖      
               ‖|       |                  ‖
  ‖+-------+   ‖|   2   +-------+‖         ‖
  ‖|       |   ‖|       |       |‖         ‖
  ‖|   0   |   ‖+-------+   6   |‖         ‖
  ‖|       |   ‖|       |       |‖         ^-- chip bonding area 
  ‖+-------+   ‖|   3   |-------+‖        
  ‖|       |   ‖|       |       |‖       
  ‖|   1   |   ‖+-------+   5   |‖
  ‖|       |   ‖|       |       |‖
  ‖+-------+   ‖|   4   +-------+‖
               ‖|       |
               ‖+-------+
</pre>
</div>
<p>
That should be the view from the front.
</p>

<p>
This implies that when we look at the data from a single GridPix, we
actually see the data in the plot matching <a href="septemboard_layout_view">13.14.7</a>
above, but we <span class="underline">want</span> to see it like this rotated view
<a href="cast_septemboard_view">13.14.7</a> here. This means we need to remap the
coordinates, so that we view the y axis as our x axis and vice versa.
</p>

<p>
To be more specific about the kind of transformation required to
get the desired coordinates and some details
that make this more tricky than it may appear (depending on how your
brain works :) ), see the next section.
</p>
</div>

<div class="outline-5" id="outline-container-orgcf1e4c9">
<h5 id="orgcf1e4c9"><span class="section-number-5">13.14.7.1.</span> Viewing direction and required transformations</h5>
<div class="outline-text-5" id="text-13-14-7-1">
<p>
One extremely confusing aspect about data taking with these detectors
(and presenting results) is that different people have different
notions on how to interpret the data.
</p>

<p>
For some people the detector is essentially a camera. We look at the
world from the detector&apos;s point of view and thus &apos;see&apos; the telescope
and Sun in front of us.
</p>

<p>
For other people the detector is an object that we look at from
outside, acting more like a photo plate or a fog chamber that you look
at. You thus see the image being built up from the view of the Sun or
the telescope.
</p>

<p>
To me, the latter interpretation makes more sense. I &apos;wait&apos; the time
of the data taking and then I &apos;look at&apos; the detector &apos;from above&apos; and
see what was recorded on each chip.
</p>

<p>
However, Christoph used the former approach in his analysis and
initially I copied that over. In our code mapping pixel numbers as
returned from TOS into physical positions we &apos;invert&apos; the x pixel
position by subtracting from the total number of pixels. See
<code>/TimepixAnalysis/Analysis/ingrid/private/geometry.nim</code> in
<code>applyPitchConversion</code>:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">func</span> <span style="color: #A6E22E; font-weight: bold; font-style: italic;">applyPitchConversion*</span><span style="color: #AE81FF;">[</span><span style="color: #66D9EF;">T</span>: <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">float</span> | <span style="color: #66D9EF;">SomeInteger</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">](</span>x, y: <span style="color: #66D9EF;">T</span>, npix: <span style="color: #66D9EF;">int</span><span style="color: #AE81FF;">)</span>: <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">float</span>, <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span> =
  <span style="color: #E6DB74;">## template which returns the converted positions on a Timepix</span>
  <span style="color: #E6DB74;">## pixel position --&gt; absolute position from pixel center in mm.</span>
  <span style="color: #E6DB74;">## Note that the x axis is &apos;inverted&apos;!</span>
  <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">(</span>npix<span style="color: #A6E22E;">)</span> - <span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">(</span>x<span style="color: #A6E22E;">)</span> + <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span> * <span style="color: #66D9EF;">PITCH</span>, <span style="color: #66D9EF;">(</span><span style="color: #66D9EF;">float</span><span style="color: #A6E22E;">(</span>y<span style="color: #A6E22E;">)</span> + <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span><span style="color: #66D9EF;">)</span> * <span style="color: #66D9EF;">PITCH</span><span style="color: #AE81FF;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">     Coordinate system of a single Timepix
                                          
       y                                  
   256 ^                                   Legend:                     
       |                                   ======= &lt;- chip bonding area
       |                                  
       |    +-------+                     
       |    |       |                     
       |    |       |                     
       |    |       |                     
       |    +-------+                     
       |    =========                     
       |                                  
     0 +-----------------&gt; x              
       0                256


becomes:

                                          
       y                                  
   256 ^                                   Legend:                     
       |                                   ======= &lt;- chip bonding area
       |                                  
       |    +-------+                     
       |    |       |                     
       |    |       |                     
       |    |       |                     
       |    +-------+                     
       |    =========                     
       |                                  
     0 +-----------------&gt; x              
      256                0

</pre>
</div>

<p>
which is equivalent to &apos;looking at&apos; (original coordinate system) the
detector from above or &apos;looking through&apos; the detector from behind
(transformed coordinate system).
</p>

<p>
Because all our physical coordinates (<code>centerX/Y</code> in particular) take
place in this &apos;inverted&apos; coordinate system we need to take that into
account when comparing to our raytracing results and present our final
data.
</p>

<p>
In particular our raytracer is a very obvious example for &apos;my&apos;
viewpoint, because it allows us to see the accumulation of signal on
an <code>ImageSensor</code>, see
fig. <a href="#fig:limit:septemboard_coordinates:traxer_view_at">43</a>.
</p>


<figure id="fig:limit:septemboard_coordinates:traxer_view_at">
<img src="./figs/home/basti/phd/Figs/raytracing/traxer_cast_view_top_magnet_to_imagesensor.png" alt="traxer_cast_view_top_magnet_to_imagesensor.png" />

<figcaption>Figure 43: <span class="figure-number">Figure 109: </span>Screenshot of TrAXer looking at an <code>ImageSensor</code> from on top of the magnet bore. The axion image is built up on the sensor and we view it &quot;from above&quot;.</figcaption>
</figure>

<p>
Let&apos;s be more specific now about what these things mean precisely and
how to get to the correct coordinate system we care about (looking
&apos;at&apos; the detector), taking into account the 90° rotation of the
septemboard at CAST. Our target is the &apos;looking at&apos; coordinates that
fall out of TrAXer as seen in the screenshot. Let&apos;s use the term
&apos;world coordinates&apos; for this view.
</p>

<dl class="org-dl">
<dt>Description of our data reconstruction</dt><dd><p>
As mentioned, our data reconstruction performs an inversion of the
data seen &apos;from above&apos; to &apos;through detector from behind&apos;.
</p>

<p>
This means we perform a reflection along the \(y\) axis and perform a
translation of 256 pixels, \(\vec{v}_x\)
</p>

<p>
A coordinate \((x, y)\) in the transformed coordinates becomes \((x&apos;,
  y&apos;)\), given by
</p>

\begin{align*}
\vektor{x&apos; \\ y&apos;} &amp;= \mathbf{T}_y · \vektor{x \\ y} + \vec{v}_x \\
                  &amp;= \mtrix{ -1 &amp; 0 \\
                              0 &amp; 1 } · \vektor{x \\ y} + \vektor{256 \\ 0} \\
                  &amp;= \vektor{-x \\ y} + \vektor{256 \\ 0} \\
                  &amp;= \vektor{256 - x \\ y} \\
                  &amp;= \vektor{\tilde{x} \\ y}
\end{align*}
<p>
where we introduced \(\tilde{x}\) for our new inverted x-coordinates, given in millimeter.
</p>

<p>
(Note: we could make the translation more robust by using a 3D
matrix (for this case) in homogeneous coordinates of the form
</p>

<p>
\[
  \mathbf{V} = \mtrix{ 1 &amp; 0 &amp; 256 \\
                       0 &amp; 1 &amp;   0 \\
                       0 &amp; 0 &amp;   1 }
  \]
where the last column performs a translation for us. Our input
vectors would need to be extended by a third row, which we would set
to 1. After applying the transformation we would then drop the 3rd
dimension again. The result is essentially the same as above, but
can be represented as a matrix product. This is commonly used in
computer graphics { with there adding a 4th dimension to 3D vectors
} )
</p></dd>

<dt>Description of the native data transformation</dt><dd><p>
To convert the raw GridPix data (without the above inversion) into
our target coordinates (in world coordinates) we need to account for
the rotation of the GridPix detector. As described in the previous
section, the detector is rotated by 90° clockwise (in world coordinates).
</p>

<p>
Rotations in mathematics commonly describe positive rotations as
anti clockwise. Thus, our detector is rotated by
\(\SI{-90}{°}\). Applying this rotation to our data yields the image
as seen from world coordinates, mapped to the TrAXer simulation:
</p>

\begin{align*}
\vektor{x&apos; \\ y&apos;} &amp;= R_{\SI{-90}{°}} · \vektor{x \\ y} \\
                  &amp;= \mtrix{ \cos θ &amp; -\sin θ \\
                             \sin θ &amp;  \cos θ } ·
                             \vektor{x \\ y} \\
                  &amp;= \mtrix{  0 &amp; 1 \\
                                         -1 &amp; 0 } ·
                                         \vektor{x \\ y} \\
                  &amp;= \vektor{y \\ -x}
\end{align*}
<p>
where we used \(θ = -π/2\).
</p></dd>

<dt>Comparing our current description to the target</dt><dd><p>
Our current reconstructed data is of the form \((-x, y)\) while our
target is \((y, -x)\). This means to get to the desired outcome all we
have to do is replace the x and y coordinates. In other words
perform a reflection along the line \(x = y\) in our data.
</p>

\begin{align*}
\vektor{x&apos; \\ y&apos;} &amp;= \mathbf{S}_{x = y} · \vektor{256 - x \\ y} \\
                  &amp;= \mtrix{ 0 &amp; 1 \\
                             1 &amp; 0 } · \vektor{256 - x \\ y} \\
                  &amp;= \vektor{y \\ 256 - x}
\end{align*}

<p>
which is exactly what we want outside of the translation by
\(\num{256}\), which is not strictly speaking there in our actual
data, due to the data being converted into millimeter. But this just
means <i>the numbers are different, but the features are in the right
place</i>. That latter part is important. In our coordinated (inverted)
data, the final transformation may look like \((y, \tilde{x})\) –
clearly different from our target \((y, -x)\) – the underlying
transformation is anyway of the form \((y, -x)\), barring a
translation. That translation is essentially just dropped due to the
millimeter conversion, but the inherent effect on the final geometry
is anyway retained (and encoded in the fact that all x coordinates
are reversed).
</p></dd>
</dl>

<p>
This means to bring our center cluster data to the same coordinates
that we get from TrAXer (the world coordinates, &apos;looking at&apos; the
detector), all we need to do is to transpose our coordinates; replace
x by y and vice versa.
</p>

<p>
From here we can cross check with the X-ray finger run, run 189, see
fig. <a href="#fig:cast:xray_finger_centers">#fig:cast:xray_finger_centers</a> generated in
sec. <a href="./cast.html#sec:cast:alignment:xray_finger_plots">10.2.2</a>, that this indeed makes
sense. To quickly reproduce that figure here and compare it to our
TrAXer raytracing for an X-ray finger run, see
fig. <a href="#fig:limit:candidates:layout_transformations">44</a>.
</p>


<figure class="figure-wrapper" id="fig:limit:candidates:layout_transformations">
<figure class="subfigure" id="fig:limit:candidates:xray_finger_transformed" data-width="49%">  <img src="./figs/~/phd/Figs/CAST_Alignment/xray_finger_centers_run_189.svg" data-width="99%" />  <figcaption>Figure 44(a): X-ray finger run</figcaption></figure> <figure class="subfigure" id="fig:limit:candidates:traxer_xray_finger" data-width="49%">  <img src="./figs/~/phd/Figs/raytracing/xray_finger_14.2m_3mm_3keV.svg" data-width="99%" />  <figcaption>Figure 44(b): MLP prediction</figcaption></figure>
<figcaption>Figure 44: <a href="#fig:limit:candidates:xray_finger_transformed">44(a)</a> X-ray finger run 189, which is transformed by $x ⇔ y$ transformation.<a href="#fig:limit:candidates:traxer_xray_finger">44(b)</a> TrAXer X-ray finger simulation already in world coordinates.
          As we can see comparing the two, the shape is the same.</figcaption>
</figure>


<p>
In the plotting code in that section we implement the required
transformation by exchanging the X by the Y center data. This is
correct, <i>but only</i> because the conversion from pixel coordinates to
milli meters when computing the cluster centers already includes the
inversion of the x axis. A transposition like that should yield a
clock wise rotation.
</p>

<p>
This means for our limit calculation: perform the same X ⇔ Y
replacement to get the correct rotation. Furthermore, let&apos;s look at an
X-ray finger run using <code>TrAXer</code> (read appendix
<a href="./raytracing.html#sec:appendix:raytracing">37</a> first) to reproduce the X-ray finger run of
run 189.
</p>

<blockquote>
<p>
Note: the TrAXer raytracing binary output files that store the image
sensor data are again inverted in y compared to what we see / what we
want. In our detector the bottom left is \((0, 0)\). But the data buffer
associated with an <code>ImageSensor</code> in TrAXer starts with \((0, 0)\) in the
top left. Hence you see <code>--invertY</code> in all calls to <code>plotBinary</code>!
</p>
</blockquote>
</div>
</div>
</div>
</div>



<div class="outline-3" id="outline-container-sec:limit:observed_limit">
<h3 id="sec:limit:observed_limit"><span class="section-number-3">13.15.</span> Observed limit - \(g_{ae}\)</h3>
<div class="outline-text-3" id="text-sec:limit:observed_limit">
<p>
With the data fully unblinded and the solar tracking candidates known,
we can now compute the observed limit for the axion-electron coupling
\(g_{ae}\). We compute an observed limit of
</p>

<p>
\[
\left(g_{ae} · g_{aγ}\right)_{\text{observed}} = \SI{7.34(9)e-23}{GeV⁻¹},
\]
</p>

<p>
which is lower than the expected limit, due to the distribution of
candidates and absence of any highly significant candidates. This
limit is the mean value out of \(\num{200}\) limits computed via 3
Markov Chains of \(\num{150000}\) links (same as for the expected limits)
computed for the real candidates. The printed uncertainty represents
the standard deviation out of those limits. Therefore, we may wish to
present an upper bound,
</p>

<p>
\[
\left(g_{ae} · g_{aγ}\right)_{\text{observed}} \lesssim \SI{7.35e-23}{GeV⁻¹} \text{ at } \SI{95}{\%} \text{ CL}.
\] 
</p>

<p>
The expected limit for this case was \(\left(g_{ae} ·
g_{aγ}\right)_{\text{expected}} = \SI{7.878225(6464)e-23}{GeV⁻¹}\) and
the limit without any candidates at all \(\left(g_{ae} ·
g_{aγ}\right)_{\text{no candidates}} = \SI{6.39e-23}{GeV⁻¹}\).
</p>

<p>
This is a good improvement compared to the current, best observed
limit by CAST in 2013 (<a href="./bibliography.html#citeproc_bib_item_38">Barth et al. 2013</a>), which achieved
</p>

<p>
\[
\left(g_{ae} · g_{aγ}\right)_{\text{CAST2013}} \lesssim \SI{8.1e-23}{GeV⁻¹}.
\]
</p>

<p>
Unfortunately, (<a href="./bibliography.html#citeproc_bib_item_38">Barth et al. 2013</a>) does not provide an expected limit to
compare to. <sup>  <a role="doc-backlink" class="footref" id="fnr.16" href="#fn.16">16</a></sup>
</p>

<p>
Fig. <a href="#fig:limit:observed_axion_electron">45</a> shows the marginal posterior
likelihood function for the observed solar tracking candidates, for a
single calculation run (out of the \(\num{200}\) mentioned). The limit
is at the \(95^{\text{th}}\) percentile of the histogram, shown by the
intersection of the blue and red filling. In addition the yellow line
shows values based on a numerical integration using Romberg&apos;s method
(<a href="./bibliography.html#citeproc_bib_item_187">Romberg 1955</a>) at 20 different coupling constants. This is
a cross validation of the MCMC
result. <sup>  <a role="doc-backlink" class="footref" id="fnr.17" href="#fn.17">17</a></sup>
</p>

<p>
Note that this observed limit is valid for axion masses in the range
where the coherence condition in the conversion probability is
met. That is, \(qL \ll π\), refer back to equation
\eqref{eq:theory:axion_interaction:conversion_probability}. This holds up to
axion masses around \(m_a \lesssim \SI{0.02}{eV}\), but the exact value
is both energy dependent and based on the desired cutoff in reduction
of the conversion probability. See
fig. <a href="#fig:appendix:conversion_probability_vs_mass">194</a> in appendix
<a href="./limit_additional.html#sec:appendix:conversion_probability">33.1</a> to see how the conversion
probability develops as a function of axion mass. The expected and
observed limits simply (inversely) follow the conversion probability,
i.e. out of coherence they get exponentially worse, superimposed with
the periodic modulation seen in the conversion probability. As we did
not perform a buffer gas run, the behavior in that range is not
computed, because it is mostly trivial (only the exact point at which
the limit decreases changes depending on the exact energies of the
candidates).
</p>

<p>
Finally, note that if one combines the existing astrophysical limits
on \(g_{ae}\) alone (for example tip of the red giant branch star
brightness limits, (<a href="./bibliography.html#citeproc_bib_item_59">Capozzi and Raffelt 2020</a>) at
\(g_{ae} &lt; \num{1.3e-13}\)) with an axion-photon coupling of choice (for
example the current best limit of (<a href="./bibliography.html#citeproc_bib_item_66">Collaboration and others 2017</a>)) one may very well
obtain a &apos;better&apos; limit on \(g_{ae}·g_{aγ}\). In that sense the above,
at the very least, represents the best helioscope limit on the product
of both coupling constants. It also suffers less from uncertainties as
astrophysical limits, see for example (<a href="./bibliography.html#citeproc_bib_item_79">Dennis and Sakstein 2023</a>).
</p>


<figure id="fig:limit:observed_axion_electron">
<img src="./figs/home/basti/phd/Figs/trackingCandidates/mcmc_real_limit_likelihood_ck_g_ae².svg" class="org-svg" alt="mcmc_real_limit_likelihood_ck_g_ae².svg" />

<figcaption>Figure 45: <span class="figure-number">Figure 110: </span>The marginal posterior likelihood function for the solar candidates with the observed limit at the intersection between the blue and red filling. Also shown is a line based on a numerical integration of the 4-fold integral at 20 steps as a cross check of the MCMC. The x-axis is the parameter we sample, namely \(g²_{ae}\). Limit at \(g² \approx \num{5.4e-21} ⇒ g \approx \num{7.35e-11}\).</figcaption>
</figure>
</div>

<div class="outline-5" id="outline-container-org09e5591">
<h5 id="org09e5591"><span class="section-number-5">13.15.0.1.</span> Sanity check   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-15-0-1">
<p>
This is only one of them, but quick, gives an overview:
</p>

<p>
Running the sanity checks for the limits by varying <code>g²_ae</code> as
described in the thesis:
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    sanity --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionElectronPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes --sanityPath ~/phd/Figs/limit/sanity/axionElectronSanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionElectronLimit
</pre>
</div>
<p>
See the plots in <a href="./Figs/limit/sanity/axionElectronSanity/">./Figs/limit/sanity/axionElectronSanity/</a> and the
sanity log:
</p>
<pre class="example">
[2024-01-11 - 15:39:15] - INFO: =============== Input ===============
[2024-01-11 - 15:39:15] - INFO: 	Input path: 
[2024-01-11 - 15:39:15] - INFO: 	Input files: @[(2017, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;), (2018, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;)]
[2024-01-11 - 15:39:15] - INFO: =============== Time ===============
[2024-01-11 - 15:39:15] - INFO: 	Total background time: 3158.01 h
[2024-01-11 - 15:39:15] - INFO: 	Total tracking time: 159.899 h
[2024-01-11 - 15:39:15] - INFO: 	Ratio of tracking to background time: 1 UnitLess
[2024-01-11 - 15:39:16] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronSanity/candidates_signal_over_background_axion_electron.pdf
[2024-01-11 - 15:39:16] - INFO: =============== Chameleon coupling constant ===============
[2024-01-11 - 15:39:16] - INFO: 	Conversion probability using default g_aγ² = 9.999999999999999e-25, yields P_a↦γ = 1.62702e-21 UnitLess
[2024-01-11 - 15:39:25] - INFO: Limit with default g_ae² = 1e-26 is = 4.773876062173374e-21, and as g_ae = 6.909324179811926e-11
[2024-01-11 - 15:39:25] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronSanity/candidates_signal_over_background_axion_electron.pdf
[2024-01-11 - 15:39:37] - INFO: 2. Limit with default g_ae² = 1e-26 is = 8.300544615154112e-21, and as g_ae = 9.110732470638194e-11
[2024-01-11 - 15:39:37] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronSanity/candidates_signal_over_background_axion_electron.pdf
[2024-01-11 - 15:39:46] - INFO: 3. Limit with default g_ae² = 1e-26 is = 5.284512161896287e-21, and as g_ae = 7.26946501600791e-11
[2024-01-11 - 15:39:47] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronSanity/candidates_signal_over_background_axion_electron.pdf
[2024-01-11 - 15:39:58] - INFO: 4. Limit with default g_ae² = 1e-26 is = 5.92914993487365e-21, and as g_ae = 7.700097359692051e-11
</pre>

<p>
And by varying g²<sub>ae</sub>·g²<sub>aγ</sub> instead (equivalent):
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    sanity --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionElectronPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes --sanityPath ~/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionElectronAxionPhotonLimit
</pre>
</div>
<p>
see <a href="./Figs/limit/sanity/axionElectronAxionPhotonSanity/">./Figs/limit/sanity/axionElectronAxionPhotonSanity/</a> and the
sanity log:
</p>
<pre class="example">
[2024-01-11 - 15:42:04] - INFO: =============== Input ===============
[2024-01-11 - 15:42:04] - INFO: 	Input path: 
[2024-01-11 - 15:42:04] - INFO: 	Input files: @[(2017, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;), (2018, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;)]
[2024-01-11 - 15:42:05] - INFO: =============== Time ===============
[2024-01-11 - 15:42:05] - INFO: 	Total background time: 3158.01 h
[2024-01-11 - 15:42:05] - INFO: 	Total tracking time: 159.899 h
[2024-01-11 - 15:42:05] - INFO: 	Ratio of tracking to background time: 1 UnitLess
[2024-01-11 - 15:42:05] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/candidates_signal_over_background_axion_electron_axion_photon.pdf
[2024-01-11 - 15:42:05] - INFO: =============== Axion-electron axion-photon coupling constant ===============
[2024-01-11 - 15:42:05] - INFO: 	Conversion probability using default g_aγ² = 9.999999999999999e-25, yields P_a↦γ = 1.62702e-21 UnitLess
[2024-01-11 - 15:42:14] - INFO: Limit is g_ae²·g_aγ² = 4.722738218023592e-45, as g_ae·g_aγ = 6.872218141199821e-23
[2024-01-11 - 15:42:14] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/candidates_signal_over_background_axion_electron_axion_photon.pdf
[2024-01-11 - 15:42:25] - INFO: 2. Limit is g_ae²·g_aγ² = 8.597830720112351e-45, as g_ae·g_aγ = 9.272448824400355e-23
[2024-01-11 - 15:42:25] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/candidates_signal_over_background_axion_electron_axion_photon.pdf
[2024-01-11 - 15:42:35] - INFO: 3. Limit is g_ae²·g_aγ² = 5.266187342850787e-45, as g_ae·g_aγ = 7.256850103764572e-23
[2024-01-11 - 15:42:35] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/candidates_signal_over_background_axion_electron_axion_photon.pdf
[2024-01-11 - 15:42:46] - INFO: 4. Limit is g_ae²·g_aγ² = 6.027243097935441e-45, as g_ae·g_aγ = 7.763532120069731e-23
</pre>
<p>
Compare the limits with the above to see that they are basically the
same limits (the variation is down to the MCMC uncertainty for a
single limit).
</p>

<p>
<b>NOTE</b>: Running the limit using <code>--axionElectronAxionPhotonLimitWrong</code>
will run it by varying <code>g_ae·g_aγ</code> (without the square) directly. This
is to illustrate the explanation of
sec. <a href="./limit.html#sec:limit:mcmc:notes_variation_coupling_parameter">13.12.2</a>. It will show
a distorted histogram and different limits than in the above two
cases:
</p>

<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    sanity --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionElectronPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes --sanityPath ~/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionElectronAxionPhotonLimitWrong
</pre>
</div>
<p>
See <a href="./Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/">./Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/</a> and
the sanity log:
</p>
<pre class="example">
[2024-01-11 - 15:43:43] - INFO: =============== Input ===============
[2024-01-11 - 15:43:43] - INFO: 	Input path: 
[2024-01-11 - 15:43:43] - INFO: 	Input files: @[(2017, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;), (2018, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;)]
[2024-01-11 - 15:43:43] - INFO: =============== Time ===============
[2024-01-11 - 15:43:43] - INFO: 	Total background time: 3158.01 h
[2024-01-11 - 15:43:43] - INFO: 	Total tracking time: 159.899 h
[2024-01-11 - 15:43:43] - INFO: 	Ratio of tracking to background time: 1 UnitLess
[2024-01-11 - 15:43:43] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/candidates_signal_over_background_axion_electron_axion_photon_wrong.pdf
[2024-01-11 - 15:43:44] - INFO: =============== Axion-electron axion-photon coupling constant via g_ae·g_aγ directly ===============
[2024-01-11 - 15:43:44] - INFO: 	Conversion probability using default g_aγ² = 9.999999999999999e-25, yields P_a↦γ = 1.62702e-21 UnitLess
[2024-01-11 - 15:43:53] - INFO: Limit is g_ae·g_aγ = 5.536231179166123e-23
[2024-01-11 - 15:43:54] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/candidates_signal_over_background_axion_electron_axion_photon_wrong.pdf
[2024-01-11 - 15:44:05] - INFO: 2. Limit is g_ae·g_aγ = 7.677750408651383e-23
[2024-01-11 - 15:44:05] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/candidates_signal_over_background_axion_electron_axion_photon_wrong.pdf
[2024-01-11 - 15:44:15] - INFO: 3. Limit is g_ae·g_aγ = 5.828448006406443e-23
[2024-01-11 - 15:44:15] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/candidates_signal_over_background_axion_electron_axion_photon_wrong.pdf
[2024-01-11 - 15:44:27] - INFO: 4. Limit is g_ae·g_aγ = 6.573837668159744e-23
</pre>
<p>
See how the limits are much lower than for the two cases above (the
additional 1e-12 difference is down to <code>g_aγ</code> not being included, note
the numbers outside of the power).
</p>

<p>
And in particular, compare
</p>


<figure id="org2c3d2d7">
<img src="./figs/home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonWrongSanity/mcmc_histo_real_syst_.svg" class="org-svg" alt="mcmc_histo_real_syst_.svg" />

</figure>

<p>
with the correct 
</p>

<p>
<img src="./figs/home/basti/phd/Figs/limit/sanity/axionElectronAxionPhotonSanity/mcmc_histo_real_syst_.svg" class="org-svg" alt="mcmc_histo_real_syst_.svg" /> 
and
<img src="./figs/home/basti/phd/Figs/limit/sanity/axionElectronSanity/mcmc_histo_real_syst_.svg" class="org-svg" alt="mcmc_histo_real_syst_.svg" />
</p>

<p>
which illustrates the sampling behavior nicely.
</p>
</div>
</div>

<div class="outline-5" id="outline-container-org892e073">
<h5 id="org892e073"><span class="section-number-5">13.15.0.2.</span> Calculate the observed limit   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-15-0-2">
<p>
We use <code>F_WIDTH=0.5</code> for the <code>ln(1 + s/b)</code> plot. The MCMC g<sub>ae</sub>²
histogram is forced to be 0.9 in width anyway.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/org/resources/axionProduction/axionElectronRealDistance/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionElectronPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span>
</pre>
</div>


<p>
-&gt; The plot looks exactly like the one already in the thesis? Surely
they should be switched around x/y?
</p>

<p>
The log file:
<a href="./Figs/trackingCandidates/real_candidates_limit.log">./Figs/trackingCandidates/real_candidates_limit.log</a>
</p>
</div>
</div>
</div>


<div class="outline-3" id="outline-container-sec:limit:other_couplings">
<h3 id="sec:limit:other_couplings"><span class="section-number-3">13.16.</span> Other coupling constants</h3>
<div class="outline-text-3" id="text-sec:limit:other_couplings">
<p>
As explained when we introduced the limit calculation method, one
important aim was to develop a method which is agnostic to the coupling
constant of choice. We will now make use of this to compute expected
and observed limits for the axion-photon coupling \(g_{aγ}\),
sec. <a href="./limit.html#sec:limit:axion_photon">13.16.1</a> and chameleon coupling \(β_γ\),
sec. <a href="./limit.html#sec:limit:chameleon">13.16.2</a>. 
</p>
</div>

<div class="outline-4" id="outline-container-sec:limit:axion_photon">
<h4 id="sec:limit:axion_photon"><span class="section-number-4">13.16.1.</span> Axion-photon coupling - \(g⁴_{aγ}\)</h4>
<div class="outline-text-4" id="text-sec:limit:axion_photon">
<p>
The axion-photon coupling requires the following changes:
</p>

<ul class="org-ul">
<li>use \(g⁴_{aγ}\) in the vector of the Markov Chain, replacing the
\(g²_{ae}\) term. As \(g_{aγ}\) both affects the production and
reconversion it needs to be in the fourth power.</li>
<li>the axion flux based on Primakoff production only.</li>
<li>the axion image based on the Primakoff flux only.</li>
</ul>

<p>
The axion flux and axion image for the Primakoff production are shown
in fig. <a href="#fig:limit:axion_photon:flux_image_inputs">47</a>. Note that the
axion image is computed at the same effective conversion position as
for the axion-electron flux. Strictly speaking this is not quite
correct, due to the different energies of the two fluxes and therefore
different absorption lengths. For the purposes here the inaccuracy is
acceptable.
</p>

<p>
Based on these we compute an expected limit for the same setup that
yielded the best expected limit for the axion-electron coupling
constant. Namely, the MLP classifier at \(\SI{95}{\%}\) efficiency using
all vetoes except the septem veto. We compute an expected limit based
on \(\num{1e4}\) toy
candidates. Fig. <a href="#fig:limit:axion_photon:expected_limit">48</a> shows the
distribution of limits obtained for different toy candidates,
including the expected limit. In appendix
<a href="./limit_additional.html#sec:appendix:exp_limit_percentiles">33.2</a>,
tab. <a href="#tab:appendix:expected_limits_percentiles_axion_photon">32</a> the
different percentiles for this distribution are shown. The obtained
expected limit is
</p>

<p>
\[
g_{aγ, \text{expected}} = \SI{9.0650(75)e-11}{GeV⁻¹},
\]
</p>

<p>
which compared to the observed CAST Nature (<a href="./bibliography.html#citeproc_bib_item_66">Collaboration and others 2017</a>) limit of
\(g_{aγ, \text{Nature}} = \SI{6.6e-11}{GeV^{−1}}\) is of course
significantly worse. This is expected however, due to significantly
less tracking time and higher background rates. The limit without any
candidates comes out to
</p>

<p>
\[
g_{aγ, \text{no candidates}} = \SI{7.95e-11}{GeV⁻¹}.
\]
</p>

<p>
Based on the same candidates as in sec. <a href="./limit.html#sec:limit:observed_limit">13.15</a> we
obtain an observed limit of
</p>

<p>
\[
g_{aγ, \text{observed}} = \SI{8.99(7)e-11}{GeV⁻¹},
\]
</p>

<p>
which again is the mean out of 200 MCMC limits. Once again it is
better than the expected limit, similar as for the axion-electron
limit, but the overall result is as expected.
</p>

<p>
As a bound then, it is
</p>

<p>
\[
g_{aγ, \text{observed}} \lesssim \SI{9.0e-11}{GeV⁻¹} \text{ at } \SI{95}{\%} \text{ CL}.
\]
</p>

<p>
The distribution of the posterior likelihood function can be found in
fig. <a href="#fig:appendix:posterior_likelihood_axion_photon">195</a> of appendix
<a href="./limit_additional.html#sec:appendix:limit_additional:axion_photon">33.3</a>. 
</p>


<figure class="figure-wrapper" id="fig:limit:axion_photon:flux_image_inputs">
<figure class="subfigure" id="fig:limit:axion_photon:flux" data-width="49%">  <img src="./figs/~/phd/Figs/axions/differential_axion_flux_primakoff.svg" data-width="99%" />  <figcaption>Figure 47(a): $g_{aγ}$ flux</figcaption></figure> <figure class="subfigure" id="fig:limit:axion_photon:image" data-width="49%">  <img src="./figs/~/phd/Figs/raytracing/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.svg" data-width="99%" />  <figcaption>Figure 47(b): $g_{aγ}$ image</figcaption></figure>
<figcaption>Figure 47: <a href="#fig:limit:axion_photon:flux">47(a)</a>: Differential axion flux arriving on Earth due to Primakoff production assuming $\SI{1e-12}{GeV⁻¹}$. <a href="#fig:limit:axion_photon:image">47(b)</a>: Axion image for the Primakoff emission in the Sun.</figcaption>
</figure>



<figure id="fig:limit:axion_photon:expected_limit">
<img src="./figs/home/basti/phd/Figs/limit/mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_axion_photon_nmc_10k_pretty.svg" class="org-svg" alt="mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_axion_photon_nmc_10k_pretty.svg" />

<figcaption>Figure 48: <span class="figure-number">Figure 111: </span>\(\num{1e4}\) toy limits for the axion-photon coupling \(g⁴_{aγ}\). The expected limit is determined to \(g_{aγ, \text{expected}} = \SI{9.0650(75)e-11}{GeV⁻¹}\), with the no candidates limit being \(g_{aγ, \text{no candidates}} = \SI{7.95e-11}{GeV⁻¹}\).</figcaption>
</figure>
</div>



<div class="outline-5" id="outline-container-org5691218">
<h5 id="org5691218"><span class="section-number-5">13.16.1.1.</span> Calculate differential axion-photon flux and emission rates   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-1-1">
<p>
Same as for the axion-electron coupling, we use <code>readOpacityFile</code> with
the <code>~--fluxKind fkAxionPhoton</code> argument (see also <a href="./raytracing.html#sec:appendix:raytracing:generate_axion_image">37.4.3</a>):
</p>
<div class="org-src-container">
<pre class="src src-sh">./readOpacityFile <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;_0.989AU&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --distanceSunEarth 0.9891144450781392.AU <span style="color: #E6DB74; font-weight: bold;">\</span>
    --fluxKind fkAxionPhoton <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotPath ~/phd/Figs/readOpacityFile/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/resources/readOpacityFile/
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-org3f64d4b">
<h5 id="org3f64d4b"><span class="section-number-5">13.16.1.2.</span> Generate plot of differential Primakoff flux   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-1-2">
<p>
Produce a standalone plot of the axion-photon flux:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim, unchained
<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv&quot;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">float</span>: <span style="color: #E6DB74;">&quot;Flux&quot;</span> ~ idx<span style="color: #A6E22E;">(</span><span style="color: #E6DB74;">&quot;Flux / keV⁻¹ m⁻² yr⁻¹&quot;</span><span style="color: #A6E22E;">)</span>.keV⁻¹•m⁻²•yr⁻¹.toDef<span style="color: #A6E22E;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #A6E22E;">)</span>.<span style="color: #66D9EF;">float</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
  .filter<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #66D9EF;">string</span>: `<span style="color: #F92672;">type</span>` == <span style="color: #E6DB74;">&quot;Total flux&quot;</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Energy [keV]&quot;</span>, <span style="color: #E6DB74;">&quot;Flux&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  ylab<span style="color: #AE81FF;">(</span>r<span style="color: #E6DB74;">&quot;Flux [$\si{keV⁻¹.cm⁻².s⁻¹}$]&quot;</span><span style="color: #AE81FF;">)</span> +
  margin<span style="color: #AE81FF;">(</span>left = <span style="font-style: italic;">4</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
  ggtitle<span style="color: #AE81FF;">(</span>r<span style="color: #E6DB74;">&quot;Primakoff flux at $g_{aγ} = \SI{1e-12}{GeV⁻¹}$&quot;</span><span style="color: #AE81FF;">)</span> +
  xlim<span style="color: #AE81FF;">(</span><span style="font-style: italic;">0</span>.<span style="font-style: italic;">0</span>, <span style="font-style: italic;">15</span>.<span style="font-style: italic;">0</span><span style="color: #AE81FF;">)</span> + 
  themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, width = <span style="font-style: italic;">600</span>, baseTheme = sideBySide<span style="color: #AE81FF;">)</span> +
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/axions/differential_axion_flux_primakoff.pdf&quot;</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>


<div class="outline-5" id="outline-container-org4a99627">
<h5 id="org4a99627"><span class="section-number-5">13.16.1.3.</span> Generate axion image for axion-photon emission   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-1-3">
<p>
Now we just run the raytracer, using the correct position (1492.93 mm
effective distance from telescope center) and produced emission file:
</p>
<div class="org-src-container">
<pre class="src src-sh">./raytracer <span style="color: #E6DB74; font-weight: bold;">\</span>
    --width 1200 --speed 10.0 --nJobs 32 --vfov 15 --maxDepth 5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --llnl --focalPoint --sourceKind skSun <span style="color: #E6DB74; font-weight: bold;">\</span>
    --solarModelFile ~/phd/resources/readOpacityFile/solar_model_dataframe_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --sensorKind sSum <span style="color: #E6DB74; font-weight: bold;">\</span>
    --usePerfectMirror=false <span style="color: #E6DB74; font-weight: bold;">\</span>
    --rayAt 0.995286666667 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --ignoreWindow
</pre>
</div>
<p>
[INFO] Writing buffers to binary files.
[INFO] Writing file: out/buffer<sub>2024</sub>-01-08T13:19:16+01:00<sub>type</sub><sub>uint32</sub><sub>len</sub><sub>1440000</sub><sub>width</sub><sub>1200</sub><sub>height</sub><sub>1200.dat</sub>
[INFO] Writing file: out/counts<sub>2024</sub>-01-08T13:19:16+01:00<sub>type</sub><sub>int</sub><sub>len</sub><sub>1440000</sub><sub>width</sub><sub>1200</sub><sub>height</sub><sub>1200.dat</sub>
[INFO] Writing file: out/image<sub>sensor</sub><sub>0</sub><sub>2024</sub>-01-08T13:19:16+01:00_<sub>dx</sub><sub>14.0</sub><sub>dy</sub><sub>14.0</sub><sub>dz</sub><sub>0.1</sub><sub>type</sub><sub>float</sub><sub>len</sub><sub>1000000</sub><sub>width</sub><sub>1000</sub><sub>height</sub><sub>1000.dat</sub>
</p>

<p>
And plot it, produce the CSV axion image for the limit:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">USE_TEX</span>=true ./plotBinary <span style="color: #E6DB74; font-weight: bold;">\</span>
    --dtype float <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f out/image_sensor_0_2024-01-08T13:19:16+01:00__dx_14.0_dy_14.0_dz_0.1_type_float_len_1000000_width_1000_height_1000.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --invertY <span style="color: #E6DB74; font-weight: bold;">\</span>
    --out ~/phd/Figs/raytracing/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.pdf <span style="color: #E6DB74; font-weight: bold;">\</span>
    --inPixels=false <span style="color: #E6DB74; font-weight: bold;">\</span>
    --gridpixOutfile ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;Solar axion image (g_aγ) at 0.989 AU from Sun, 1492.93 mm&quot;</span>
</pre>
</div>

<p>
yields:
</p>
<ul class="org-ul">
<li>  <img src="./figs/home/basti/phd/Figs/raytracing/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.svg" class="org-svg" alt="solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.svg" /></li>
<li>  <img src="./figs/home/basti/phd/Figs/raytracing/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm_log10.svg" class="org-svg" alt="solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm_log10.svg" /></li>
<li>  <img src="./figs/home/basti/phd/Figs/raytracing/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm_hpd_via_eef_50.svg" class="org-svg" alt="solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm_hpd_via_eef_50.svg" /></li>
</ul>
</div>
</div>

<div class="outline-5" id="outline-container-orgdacc20b">
<h5 id="orgdacc20b"><span class="section-number-5">13.16.1.4.</span> Compute an expected limit   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-1-4">
<p>
Given that this is only an &apos;add-on&apos;, we will just compute O(10k) toy
limits for an expected limit using the best performing setup from the
axion-electron limit. Based on those we will then compute the observed
limit too.
</p>

<p>
Sanity checks:
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    sanity --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes --sanityPath ~/phd/Figs/limit/sanity/axionPhotonSanity/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionPhotonLimit
</pre>
</div>
<p>
see <a href="./Figs/limit/sanity/axionPhotonSanity/">./Figs/limit/sanity/axionPhotonSanity/</a> and the sanity log file:
</p>
<pre class="example">
[2024-01-11 - 15:48:04] - INFO: =============== Input ===============
[2024-01-11 - 15:48:04] - INFO: 	Input path: 
[2024-01-11 - 15:48:04] - INFO: 	Input files: @[(2017, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;), (2018, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;)]
[2024-01-11 - 15:48:05] - INFO: =============== Time ===============
[2024-01-11 - 15:48:05] - INFO: 	Total background time: 3158.01 h
[2024-01-11 - 15:48:05] - INFO: 	Total tracking time: 159.899 h
[2024-01-11 - 15:48:05] - INFO: 	Ratio of tracking to background time: 1 UnitLess
[2024-01-11 - 15:48:05] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionPhotonSanity/candidates_signal_over_background_axionPhoton.pdf
[2024-01-11 - 15:48:05] - INFO: =============== Axion-photon coupling constant ===============
[2024-01-11 - 15:48:05] - INFO: 	Conversion probability using default g_aγ² = 9.999999999999999e-25, yields P_a↦γ = 7.97241e-18 UnitLess
[2024-01-11 - 15:48:24] - INFO: Limit with default g_aγ² = 9.999999999999999e-25 is = 5.348452506385883e-41, and as g_aγ = 8.551790162182624e-11
[2024-01-11 - 15:48:24] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionPhotonSanity/candidates_signal_over_background_axionPhoton.pdf
[2024-01-11 - 15:48:45] - INFO: 2. Limit with default g_aγ² = 9.999999999999999e-25 is = 9.258158870434389e-41, and as g_aγ = 9.809145065039609e-11
[2024-01-11 - 15:48:45] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionPhotonSanity/candidates_signal_over_background_axionPhoton.pdf
[2024-01-11 - 15:49:04] - INFO: 3. Limit with default g_aγ² = 9.999999999999999e-25 is = 6.93624112433336e-41, and as g_aγ = 9.126012210624729e-11
[2024-01-11 - 15:49:04] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/axionPhotonSanity/candidates_signal_over_background_axionPhoton.pdf
[2024-01-11 - 15:49:25] - INFO: 4. Limit with default g_aγ² = 9.999999999999999e-25 is = 6.105369380817466e-41, and as g_aγ = 8.839505819701355e-11
</pre>
<p>
The limits seem reasonable for our detector. Worse than the Nature
limit by quite a bit, but still acceptable!
</p>

<p>
See sec. <a href="./limit.html#sec:limit:expected_limits:best_expected_50k">13.13.5</a> for the command
for axion-electron using 50k toys. The main differences:
</p>
<ul class="org-ul">
<li>axion photon differential flux</li>
<li>axion photon axion image</li>
<li>couplingKind: g<sub>aγ</sub></li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_g_aγ⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/org/resources/lhood_limits_axion_photon_11_01_24/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 10000
</pre>
</div>
<p>
Expected limit: 6.752456878081697e-41
Generating group /ctx/trackingDf
Generating group /ctx/axionModel
Serializing Interpolator by evaluating 0.001 to 15.0 of name: axionSpl
Serializing Interpolator by evaluating 0.0 to 10.0 of name: efficiencySpl
Serializing Interpolator by evaluating 0.2 to 12.0 of name: backgroundSpl
Generating group /ctx/backgroundDf
Wrote outfile /home/basti/org/resources/lhood<sub>limits</sub><sub>axion</sub><sub>photon</sub><sub>11</sub><sub>01</sub><sub>24</sub>/lhood<sub>c18</sub><sub>R2</sub><sub>crAll</sub><sub>sEff</sub><sub>0.95</sub><sub>scinti</sub><sub>fadc</sub><sub>septem</sub><sub>line</sub><sub>mlp</sub><sub>mlp</sub><sub>tanh</sub><sub>sigmoid</sub><sub>MSE</sub><sub>Adam</sub><sub>30</sub><sub>2checkpoint</sub><sub>epoch</sub><sub>82000</sub><sub>loss</sub><sub>0.0249</sub><sub>acc</sub><sub>0.9662</sub><sub>vQ</sub><sub>0.99</sub>/mc<sub>limit</sub><sub>lkMCMC</sub><sub>skInterpBackground</sub><sub>nmc</sub><sub>10000</sub><sub>uncertainty</sub><sub>ukUncertain</sub><sub>σs</sub><sub>0.0276</sub><sub>σb</sub><sub>0.0028</sub><sub>posUncertain</sub><sub>puUncertain</sub><sub>σp</sub><sub>0.0500.h5</sub>
</p>

<p>
Finished <span class="timestamp-wrapper">  <span class="timestamp">&lt;2024-01-11 Thu 17:53&gt;</span></span>. It took about 3 hours maybe.
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> Make the output plot prettier! It&apos;s super ugly due to a few
<span class="underline">very</span> large limits.</li>
</ul>

<div class="org-src-container">
<pre class="src src-sh">./generateExpectedLimitsTable --path ~/org/resources/lhood_limits_axion_photon_11_01_24/ --prefix <span style="color: #E6DB74;">&quot;mc_limit_lkMCMC&quot;</span> --precision 2 --coupling ck_g_aγ⁴
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-orge55debe">
<h5 id="orge55debe"><span class="section-number-5">13.16.1.5.</span> Generate plot of expected limit histogram   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-1-5">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotFile ~/org/resources/lhood_limits_axion_photon_11_01_24/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLow 2e-41 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xHigh 2e-40 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_g_aγ⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yHigh 400 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --bins 100 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --linesTo 220 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLabel <span style="color: #E6DB74;">&quot;Limit g_aγ⁴ [GeV⁻⁴]&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yLabel <span style="color: #E6DB74;">&quot;MC toy count&quot;</span>  <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/limit/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;_axion_photon_nmc_10k_pretty&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 10000
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-sec:limit:axion_photon:compute_axion_photon_observed">
<h5 id="sec:limit:axion_photon:compute_axion_photon_observed"><span class="section-number-5">13.16.1.6.</span> Calculate the observed limit   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-sec:limit:axion_photon:compute_axion_photon_observed">
<p>
We use <code>F_WIDTH=0.5</code> for the <code>ln(1 + s/b)</code> plot. The MCMC g<sub>ae</sub>²
histogram is forced to be 0.9 in width anyway.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_g_aγ⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/axionPhoton/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span>
</pre>
</div>

<p>
The log file:
<a href="./Figs/trackingCandidates/axionPhoton/real_candidates_limit.log">./Figs/trackingCandidates/axionPhoton/real_candidates_limit.log</a>
</p>

<pre class="example">
[2024-01-18 - 14:18:05] - INFO: Mean of 200 real limits (3·150k MCMC) = 8.999457e-11
[2024-01-18 - 14:18:05] - INFO: Median of 200 real limits (3·150k MCMC) = 8.991653e-11
[2024-01-18 - 14:18:05] - INFO: σ of 200 real limits (3·150k MCMC) = 7.388529e-13
[2024-01-18 - 14:18:05] - INFO: Combined real limit (200 times 3·150k MCMC) = 8.99946(7389)e-11
[2024-01-18 - 14:18:05] - INFO: Real limit based on 3 150k long MCMCs: g_aγ = 8.961844793705987e-11
</pre>
<p>
(that should read g<sub>aγ</sub>⁴, to be updated),
yields
\(g_aγ = \SI{8.99946(7389)e-11}{GeV⁻¹}\)
</p>
</div>
</div>
</div>


<div class="outline-4" id="outline-container-sec:limit:chameleon">
<h4 id="sec:limit:chameleon"><span class="section-number-4">13.16.2.</span> Chameleon coupling - \(β⁴_γ\)</h4>
<div class="outline-text-4" id="text-sec:limit:chameleon">
<p>
Let&apos;s now have a look at the chameleon coupling. In addition to the
inputs and MCMC parameter that needs to be changed similarly to the
axion-photon coupling (flux, image and using \(β^4_γ\) in the MCMC), the
conversion probability needs to be adjusted according to
eq. \eqref{eq:theory:chameleon_conversion_prob}. This assumes the conversion
is fully coherent and we restrict ourselves to non-resonant
production. That means a chameleon-matter coupling \(β_m\) of
</p>

<p>
\[
1 \leq β_m \leq \num{1e6}.
\]
</p>

<p>
Further, because the chameleon production occurs in the solar
tachocline – at around \(0.7 · R_{\odot}\) – the angles under which
chameleons can reach the CAST magnet are much larger than for
axions. This leads to a significant fraction of chameleons not
traversing the entire magnet. For any chameleon traversing only parts
of it, its probability for conversion is decreased. According to
(<a href="./bibliography.html#citeproc_bib_item_8">Anastassopoulos et al. 2015</a>) this is accounted for by a correction factor
of \(\SI{38.9}{\%}\) in reduction of signal. (<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>)
used a simplified raytracing model for this. While the distance
through the magnet can easily be modeled with our raytracer (see
appendix <a href="./raytracing.html#sec:appendix:raytracing">37</a>), we will still use the correction
factor <sup>  <a role="doc-backlink" class="footref" id="fnr.18" href="#fn.18">18</a></sup>.
</p>

<p>
Fig. <a href="#fig:limit:chameleon:flux_image_inputs">49</a> shows the differential
chameleon flux, assuming a magnetic field of \(\SI{10}{T}\) at the solar
tachocline region and using \(β_γ = β^{\text{sun}}_γ = \num{6.46e10}\)
(the bound on the chameleon coupling from solar physics). The
chameleon image is in stark contrast to the very small axion image
seen in the previous sections. The outer most ring corresponds to
production in the tachocline regions in which our view is effectively
tangent to the tachocline normal (i.e. the &apos;outer ring&apos; of the solar
tachocline when looking at the Sun). Also visible is the asymmetry in
the signal on the chip, due to the LLNL telescope. The densest flux
regions are in the top and bottom. These correspond to the narrow
sides of the ellipsoid for example in
fig. <a href="#fig:limit:axion_photon:image">47(b)</a>. This &apos;focusing effect&apos; was not
visible in the raytracing simulation of (<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>), due
to the simpler raytracing approach, which approximated the ABRIXAS
telescope as a lens (slight differences between ABRIXAS and LLNL
telescope would of course exist). 
</p>

<p>
The relative size of the chameleon image compared to the size of the
GridPix was one of the main motivators to implement the background
interpolation as introduced in
sec. <a href="./limit.html#sec:limit:ingredients:background">13.10.8</a>. This allows us to utilize the
entire chameleon flux and weigh each chameleon candidate
correctly. This is a significant improvement compared to the 2014/15
detector result (<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>), in which the entire outer
ring of the chameleon flux had to be dropped. Not only can we include
these regions in our calculation due to our approach, but also our
background level is <i>significantly</i> lower in these outer regions
thanks to the usage of our vetoes (compare
fig. <a href="#fig:background:background_suppression_comparison">#fig:background:background_suppression_comparison</a>, where
<a href="#fig:background:suppression_lnL80_without">#fig:background:suppression_lnL80_without</a> is comparable to the
background level of (<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>)).
</p>

<p>
Again, we follow the approach used for the axion-photon coupling and
restrict ourselves to a single calculation of an expected limit for
the best veto setup (MLP at \(\SI{95}{\%}\) efficiency using vetoes
except the septem veto) based on \(\num{1e4}\) toy candidate sets. This
yields an expected limit of
</p>

<p>
\[
β_{γ, \text{expected}} = \num{3.6060(39)e+10}.
\]
</p>

<p>
Without any candidates, which for the chameleon due to its large
much larger focused image is significantly more extreme, the limit
comes out to
</p>

<p>
\[
β_{γ, \text{no candidates}} = \num{2.62e10}.
\]
</p>

<p>
Fig. <a href="#fig:limit:chameleon:expected_limit">50</a> shows the histograms of these
toy limits. The differently colored histograms are again based on an
arbitrary cutoff in \(\ln(1 + s/b)\) for a fixed coupling constant. We
can see that the difference between the &apos;no candidate&apos; limit and the
lowest toy limits is much larger than for the two axion limits. This
is due to the chameleon image covering a large fraction of the chip,
making it incredibly unlikely to have no candidates. Further, in appendix
<a href="./limit_additional.html#sec:appendix:exp_limit_percentiles">33.2</a> we find
tab. <a href="#tab:appendix:expected_limits_percentiles_chameleon">33</a>, containing
the different percentiles for the distribution of toy limits.
</p>

<p>
For the chameleon coupling it may be worthwhile to investigate other
veto setups again, because of the very different nature of the
chameleon image and even lower peak of the differential flux. Based on
the same setup we compute an observed limit using the same set of
candidates as previously of
</p>

<p>
\[
β_{γ, \text{observed}} = \num{3.10(2)e+10}.
\]
</p>

<p>
or as an upper bound
</p>

<p>
\[
β_{γ, \text{observed}} \lesssim \num{3.1e+10} \text{ at } \SI{95}{\%} \text{ CL}.
\] 
</p>


<p>
This is a good improvement over the limit of
(<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>; <a href="./bibliography.html#citeproc_bib_item_9">Anastassopoulos et al. 2019</a>), and the current best
chameleon-photon bound, of
</p>

<p>
\[
β_{γ, \text{Krieger}} = \num{5.74e10} \text{ at } \SI{95}{\%} \text{ CL}.
\]
</p>

<p>
despite significantly less solar tracking time than in the former (our
\(\SI{160}{h}\) to \(\SI{254}{h}\) in (<a href="./bibliography.html#citeproc_bib_item_137">Krieger 2018</a>)), thanks to
the significant improvements in background due to the detector vetoes,
higher detection efficiency (thinner window), better classifier and
improved limit calculation method allowing for the inclusion of the
entire chameleon flux.
</p>

<p>
A figure of the sampled coupling constants, similar to
fig. <a href="#fig:limit:observed_axion_electron">45</a> can be found in appendix
<a href="./limit_additional.html#sec:appendix:limit_additional:chameleon">33.4</a>,
fig. <a href="#fig:appendix:posterior_likelihood_chameleon">196</a>.
</p>

<p>
Note however, that it is somewhat surprising that the observed limit
is also an improvement over the expected limit, as the total number of
clusters in the tracking data is almost exactly as expected (850 for
844 expected). Based on all evaluations I have done, it seems to be a
real effect of the candidates. In
fig. <a href="#fig:limit:rate_candidates_background">38(b)</a> of the spectrum
comparing candidates to background, we see that there is a slight, but
noticeable lower rate at energies below \(\SI{2}{keV}\), which is the
relevant range for chameleons. As such it may very well be a real
effect, despite putting it below the \(5^{\text{th}}\) percentile of the
toy limits (compare
tab. <a href="#tab:appendix:expected_limits_percentiles_chameleon">33</a>). Further
investigation seems appropriate.
</p>


<figure class="figure-wrapper" id="fig:limit:chameleon:flux_image_inputs">
<figure class="subfigure" id="fig:limit:chameleon:flux" data-width="49%">  <img src="./figs/~/phd/Figs/axions/differential_chameleon_flux.svg" data-width="99%" />  <figcaption>Figure 49(a): $β_γ$ flux</figcaption></figure> <figure class="subfigure" id="fig:limit:chameleon:image" data-width="49%">  <img src="./figs/~/phd/Figs/raytracing/solar_chameleon_image_0.989AU_1500mm.svg" data-width="99%" />  <figcaption>Figure 49(b): $β_{γ}$ image</figcaption></figure>
<figcaption>Figure 49: <a href="#fig:limit:chameleon:flux">49(a)</a>: Differential chameleon flux arriving on Earth assuming $β_γ^{\text{sun}} = \num{6.46e10}$ and a magnetic field of $B = \SI{10}{T}$ in the solar tachocline. <a href="#fig:limit:chameleon:image">49(b)</a>: Chameleon image for chameleon emission in the Sun.</figcaption>
</figure>



<figure id="fig:limit:chameleon:expected_limit">
<img src="./figs/home/basti/phd/Figs/limit/mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_chameleon_nmc_10k_pretty.svg" class="org-svg" alt="mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500_chameleon_nmc_10k_pretty.svg" />

<figcaption>Figure 50: <span class="figure-number">Figure 112: </span>\(\num{1e4}\) toy limits for the chameleon coupling \(β⁴_{γ}\). The expected limit is determined to \(β_{γ, \text{expected}} = \num{3.6060(39)e10}\), with the no candidates limit being \(β_{γ, \text{no candidates}} = \num{2.62e10}\).</figcaption>
</figure>
</div>

<div class="outline-5" id="outline-container-org83c0e29">
<h5 id="org83c0e29"><span class="section-number-5">13.16.2.1.</span> Chameleon references   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-1">
<p>
For chameleon theory. Best overview in detail:
</p>

<p>
~/Documents/Papers/PapersHome/Masterarbeit/Chameleons/thorough<sub>chameleon</sub><sub>review</sub><sub>0611816.pdf</sub>
</p>

<p>
later review:
chameleon<sub>review</sub><sub>1602.03869.pdf</sub>
</p>


<p>
To differentiate chameleon gravity from other GR extensions:
especially
~/Documents/Papers/brax<sub>distinguishing</sub><sub>modified</sub><sub>gravity</sub><sub>models</sub><sub>1506.01519.pdf</sub>
and
~/Documents/Papers/brax<sub>lectures</sub><sub>on</sub><sub>screened</sub><sub>modified</sub><sub>gravity</sub><sub>1211.5237v1.pdf</sub>
</p>


<p>
Detection in experiments, e.g. CAST
~/Documents/Papers/brax<sub>detection</sub><sub>chameleons</sub><sub>1110.2583.pdf</sub>
and a bit brax<sub>solar</sub><sub>chameleons</sub><sub>1004.1846v1.pdf</sub> (is this a precursor preprint?)
</p>


<p>
Other reading:
chameleons and solar physics:
chameleons<sub>and</sub><sub>solar</sub><sub>physics</sub><sub>1405.1581.pdf</sub>
</p>


<p>
polarizations<sub>produced</sub><sub>by</sub><sub>chameleons</sub><sub>PhysRevD.79.044028.pdf</sub>
</p>
</div>
</div>

<div class="outline-5" id="outline-container-orgd06906b">
<h5 id="orgd06906b"><span class="section-number-5">13.16.2.2.</span> Chameleon spectrum and plot   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-2">
<p>
We have the chameleon spectrum from Christoph&apos;s limit code back in the
day. The file <a href="./resources/chameleon-spectrum.dat">./resources/chameleon-spectrum.dat</a> contains the flux
in units of <code>1/16mm2/hour/keV</code> at <code>β_m = β^sun_m = 10^10.81</code> assuming
a magnetic field of 10 T at the solar tachocline, iirc.
</p>

<p>
<a href="./../org/Misc/chameleon_spectrum.nim">./../org/Misc/chameleon_spectrum.nim</a>
</p>

<ul class="org-ul">
<li class="off"><code>[ ]</code> Insert flux!</li>
</ul>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> ggplotnim, unchained

<span style="color: #75715E;"># </span><span style="color: #75715E;">The data file `</span><span style="color: #AE81FF;">chameleon-spectrum.dat</span><span style="color: #75715E;">` contains the spectrum in units of</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">`</span><span style="color: #AE81FF;">keV⁻¹•16mm⁻²•h⁻¹</span><span style="color: #75715E;">` at β_m = β_m^sun = 6.457e10 or 10^10.81.</span>
<span style="color: #75715E;"># </span><span style="color: #75715E;">See fig. 11.2 in Christoph&apos;s thesis</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•mm⁻²•h⁻¹<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">func</span> <span style="color: #A6E22E;">conversionProbabilityChameleon</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">B</span>: <span style="color: #66D9EF;">Tesla</span>, <span style="color: #66D9EF;">L</span>: <span style="color: #66D9EF;">Meter</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">const</span> <span style="color: #66D9EF;">M_pl</span> = sqrt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>hp_bar * c<span style="color: #A6E22E;">)</span> / <span style="color: #66D9EF;">G_Newton</span><span style="color: #66D9EF;">)</span>.toDef<span style="color: #66D9EF;">(</span>kg²<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>.toNaturalUnit.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">GeV</span><span style="color: #AE81FF;">)</span> / sqrt<span style="color: #AE81FF;">(</span><span style="font-style: italic;">8</span> * π<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">reduced Planck mass in natural units</span>
  <span style="color: #F92672;">const</span> <span style="color: #FD971F;">βγsun </span>= pow<span style="color: #AE81FF;">(</span><span style="font-style: italic;">10</span>, <span style="font-style: italic;">10</span>.<span style="font-style: italic;">81</span><span style="color: #AE81FF;">)</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">M_γ</span> = <span style="color: #66D9EF;">M_pl</span> / βγsun
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">B</span>.toNaturalUnit * <span style="color: #66D9EF;">L</span>.toNaturalUnit / <span style="color: #66D9EF;">(</span><span style="font-style: italic;">2</span> * <span style="color: #66D9EF;">M_γ</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>^<span style="font-style: italic;">2</span>  
<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">convertChameleon</span><span style="color: #AE81FF;">(</span>x: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #75715E;"># </span><span style="color: #75715E;">divide by 16 to get from  /16mm² to /1mm². Input f</span>
  <span style="color: #75715E;"># </span><span style="color: #75715E;">idiotic flux has already taken conversion probability into account.</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">P</span> = conversionProbabilityChameleon<span style="color: #AE81FF;">(</span><span style="font-style: italic;">9</span>.<span style="font-style: italic;">0</span>.<span style="color: #66D9EF;">T</span>, <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m<span style="color: #AE81FF;">)</span> <span style="color: #75715E;"># </span><span style="color: #75715E;">used values by Christop!</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>x.keV⁻¹•mm⁻²•h⁻¹ / <span style="font-style: italic;">16</span>.<span style="font-style: italic;">0</span> / <span style="color: #66D9EF;">P</span><span style="color: #AE81FF;">)</span>.to<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>.<span style="color: #66D9EF;">float</span>

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">df </span>= readCsv<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/resources/chameleon-spectrum.dat&quot;</span>, sep = <span style="color: #E6DB74;">&apos;\t&apos;</span>, header = <span style="color: #E6DB74;">&quot;#&quot;</span><span style="color: #AE81FF;">)</span>
  .mutate<span style="color: #AE81FF;">(</span>f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Flux&quot;</span> ~ convertChameleon<span style="color: #A6E22E;">(</span>idx<span style="color: #E6DB74;">(</span><span style="color: #E6DB74;">&quot;I[/16mm2/hour/keV]&quot;</span><span style="color: #E6DB74;">)</span><span style="color: #A6E22E;">)</span><span style="color: #66D9EF;">}</span>,
          f<span style="color: #66D9EF;">{</span><span style="color: #E6DB74;">&quot;Energy [keV]&quot;</span> ~ `energy` / <span style="font-style: italic;">1000</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">}</span><span style="color: #AE81FF;">)</span>
ggplot<span style="color: #AE81FF;">(</span>df, aes<span style="color: #66D9EF;">(</span><span style="color: #E6DB74;">&quot;Energy [keV]&quot;</span>, <span style="color: #E6DB74;">&quot;Flux&quot;</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span> +
  geom_line<span style="color: #AE81FF;">()</span> +
  ylab<span style="color: #AE81FF;">(</span>r<span style="color: #E6DB74;">&quot;Flux [$\si{keV⁻¹.cm⁻².s⁻¹}$]&quot;</span><span style="color: #AE81FF;">)</span> +
  margin<span style="color: #AE81FF;">(</span>left = <span style="font-style: italic;">4</span>.<span style="font-style: italic;">5</span><span style="color: #AE81FF;">)</span> +
  ggtitle<span style="color: #AE81FF;">(</span>r<span style="color: #E6DB74;">&quot;Chameleon flux at $β^{\text{sun}}_γ = \num{6.46e10}$&quot;</span><span style="color: #AE81FF;">)</span> +
  themeLatex<span style="color: #AE81FF;">(</span>fWidth = <span style="font-style: italic;">0</span>.<span style="font-style: italic;">5</span>, width = <span style="font-style: italic;">600</span>, baseTheme = sideBySide<span style="color: #AE81FF;">)</span> +
  ggsave<span style="color: #AE81FF;">(</span><span style="color: #E6DB74;">&quot;~/phd/Figs/axions/differential_chameleon_flux.pdf&quot;</span><span style="color: #AE81FF;">)</span>
</pre>
</div>
</div>
</div>


<div class="outline-5" id="outline-container-orge7b3540">
<h5 id="orge7b3540"><span class="section-number-5">13.16.2.3.</span> Conversion probability   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-3">
<p>
Chameleon references:
(<a href="./bibliography.html#citeproc_bib_item_9">Anastassopoulos et al. 2019</a>) 
(<a href="./bibliography.html#citeproc_bib_item_8">Anastassopoulos et al. 2015</a>)
</p>

<p>
Conversion probability for back conversion. We are in the coherent
regime. In this case (<a href="./bibliography.html#citeproc_bib_item_53">Brax, Lindner, and Zioutas 2012</a>) equation 52:
</p>

<p>
\[
P_{c↦γ} = \frac{B² L²}{4 M²_γ}
\]
</p>

<p>
where \(M_γ\) is defined implicitly via the chameleon-photon coupling
\(β_γ\),
</p>

<p>
\[
β_γ = \frac{m_{\text{pl}}}{M_γ}
\]
</p>

<p>
where \(m_{\text{pl}}\) is the <i>reduced</i> Planck mass, \(m_{\text{pl}} =
\frac{M_{\text{pl}}}{\sqrt{8 π}}\) (i.e. using natural units with \(G =
\frac{1}{8π}\) instead of \(G = 1\), used in cosmology because it removes
the \(8π\) term from the Einstein field equations). See
(<a href="./bibliography.html#citeproc_bib_item_9">Anastassopoulos et al. 2019</a>) for mention that it is the reduced Planck
constant here. But the \(\sim \SI{2e18}{GeV}\) also gives it away. Let&apos;s
check that the numbers hold:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained

<span style="color: #F92672;">let</span> <span style="color: #66D9EF;">M_pl</span> = sqrt <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span>hp_bar * c<span style="color: #66D9EF;">)</span> / <span style="color: #66D9EF;">G_Newton</span><span style="color: #AE81FF;">)</span>.toDef<span style="color: #AE81FF;">(</span>kg²<span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Planck mass = &quot;</span>, <span style="color: #66D9EF;">M_pl</span>, <span style="color: #E6DB74;">&quot; in GeV = &quot;</span>, <span style="color: #66D9EF;">M_pl</span>.toNaturalUnit.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">GeV</span><span style="color: #AE81FF;">)</span> / sqrt<span style="color: #AE81FF;">(</span><span style="font-style: italic;">8</span> * π<span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
which indeed matches (although <b>2</b> is a rough approximation of the
value!).
</p>

<p>
Let&apos;s compute the conversion probability for a single \(β_γ\) value:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained

<span style="color: #F92672;">proc</span> <span style="color: #A6E22E;">conversionProbability</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">B</span>: <span style="color: #66D9EF;">Tesla</span>, <span style="color: #66D9EF;">L</span>: <span style="color: #66D9EF;">Meter</span>, β_γ: <span style="color: #66D9EF;">float</span><span style="color: #AE81FF;">)</span>: <span style="color: #66D9EF;">float</span> =
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">M_pl</span> = sqrt<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">(</span><span style="color: #A6E22E;">(</span>hp_bar * c<span style="color: #A6E22E;">)</span> / <span style="color: #66D9EF;">G_Newton</span><span style="color: #66D9EF;">)</span>.toDef<span style="color: #66D9EF;">(</span>kg²<span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>.toNaturalUnit.to<span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">GeV</span><span style="color: #AE81FF;">)</span> / sqrt<span style="color: #AE81FF;">(</span><span style="font-style: italic;">8</span> * π<span style="color: #AE81FF;">)</span>
  <span style="color: #75715E;">#</span><span style="color: #75715E;">let M_γ = M_pl / β_γ</span>
  <span style="color: #FD971F;">result</span> = <span style="color: #AE81FF;">(</span>β_γ * <span style="color: #66D9EF;">B</span>.toNaturalUnit<span style="color: #66D9EF;">()</span> * <span style="color: #66D9EF;">L</span>.toNaturalUnit<span style="color: #66D9EF;">()</span> / <span style="color: #66D9EF;">(</span><span style="font-style: italic;">2</span> * <span style="color: #66D9EF;">M_pl</span><span style="color: #66D9EF;">)</span><span style="color: #AE81FF;">)</span>^<span style="font-style: italic;">2</span>

<span style="color: #F92672;">echo</span> <span style="color: #E6DB74;">&quot;Conversion probability: &quot;</span>, conversionProbability<span style="color: #AE81FF;">(</span><span style="font-style: italic;">8</span>.<span style="font-style: italic;">8</span>.<span style="color: #66D9EF;">T</span>, <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m, <span style="font-style: italic;">5</span>.6e10<span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
O(1e-12) seems somewhat reasonable, given that the flux is generally
much lower than for axions? But maybe the flux is too low? The flux is
on the order of 1e-4 keV⁻¹•cm⁻²•s⁻¹ after all. 
</p>


<p>
Let&apos;s compare:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained, math
defUnit<span style="color: #AE81FF;">(</span>cm²<span style="color: #AE81FF;">)</span>
defUnit<span style="color: #AE81FF;">(</span>keV⁻¹<span style="color: #AE81FF;">)</span>

<span style="color: #F92672;">func</span> <span style="color: #A6E22E;">conversionProbability</span><span style="color: #AE81FF;">()</span>: <span style="color: #66D9EF;">UnitLess</span> =
  <span style="color: #E6DB74;">## the conversion probability in the CAST magnet (depends on g_aγ)</span>
  <span style="color: #E6DB74;">## simplified vacuum conversion prob. for small masses</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">B</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">0</span>.<span style="color: #66D9EF;">T</span>
  <span style="color: #F92672;">let</span> <span style="color: #66D9EF;">L</span> = <span style="font-style: italic;">9</span>.<span style="font-style: italic;">26</span>.m
  <span style="color: #F92672;">let</span> <span style="color: #FD971F;">g_aγ </span>= 1e-<span style="font-style: italic;">12</span>.GeV⁻¹ <span style="color: #75715E;"># </span><span style="color: #75715E;">``</span><span style="color: #AE81FF;">must</span><span style="color: #75715E;">`` be same as reference in Context</span>
  <span style="color: #FD971F;">result</span> = pow<span style="color: #AE81FF;">(</span> <span style="color: #66D9EF;">(</span>g_aγ * <span style="color: #66D9EF;">B</span>.toNaturalUnit * <span style="color: #66D9EF;">L</span>.toNaturalUnit / <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span><span style="color: #66D9EF;">)</span>, <span style="font-style: italic;">2</span>.<span style="font-style: italic;">0</span> <span style="color: #AE81FF;">)</span>
<span style="color: #F92672;">echo</span> conversionProbability<span style="color: #AE81FF;">()</span>  
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">import</span> unchained

<span style="color: #F92672;">let</span> <span style="color: #FD971F;">flx </span>= 2e18.keV⁻¹•m⁻²•yr⁻¹
<span style="color: #F92672;">echo</span> flx.toDef<span style="color: #AE81FF;">(</span>keV⁻¹•cm⁻²•s⁻¹<span style="color: #AE81FF;">)</span>
</pre>
</div>

<p>
So 6e6 axions at 1.7e-21 vs 8.6e-13 at 1e-4:
</p>
<div class="org-src-container">
<pre class="src src-nim"><span style="color: #F92672;">echo</span> 6e6 * <span style="font-style: italic;">1</span>.7e-<span style="font-style: italic;">21</span>
<span style="color: #F92672;">echo</span> 1e-<span style="font-style: italic;">4</span> * <span style="font-style: italic;">8</span>.6e-<span style="font-style: italic;">13</span>
</pre>
</div>

<p>
3 orders of magnitude difference. That seems like it would be too
much? Surely not made up by the fact that the area of interest is so
much larger, no? Only one way to find out, I guess.
</p>
</div>
</div>

<div class="outline-5" id="outline-container-orge3d20e4">
<h5 id="orge3d20e4"><span class="section-number-5">13.16.2.4.</span> Generate chameleon solar image   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-4">
<div class="org-src-container">
<pre class="src src-sh">./raytracer <span style="color: #E6DB74; font-weight: bold;">\</span>
    --width 1200 --speed 10.0 --nJobs 32 --vfov 15 --maxDepth 5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --llnl --focalPoint --sourceKind skSun <span style="color: #E6DB74; font-weight: bold;">\</span>
    --chameleonFile ~/org/resources/chameleon-spectrum.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --sensorKind sSum <span style="color: #E6DB74; font-weight: bold;">\</span>
    --usePerfectMirror=false <span style="color: #E6DB74; font-weight: bold;">\</span>
    --ignoreWindow <span style="color: #E6DB74; font-weight: bold;">\</span>
    --ignoreMagnet
</pre>
</div>
<p>
[INFO] Writing buffers to binary files.
[INFO] Writing file: out/buffer<sub>2024</sub>-01-08T20:29:05+01:00<sub>type</sub><sub>uint32</sub><sub>len</sub><sub>1440000</sub><sub>width</sub><sub>1200</sub><sub>height</sub><sub>1200.dat</sub>
[INFO] Writing file: out/counts<sub>2024</sub>-01-08T20:29:05+01:00<sub>type</sub><sub>int</sub><sub>len</sub><sub>1440000</sub><sub>width</sub><sub>1200</sub><sub>height</sub><sub>1200.dat</sub>
[INFO] Writing file: out/image<sub>sensor</sub><sub>0</sub><sub>2024</sub>-01-08T20:29:05+01:00_<sub>dx</sub><sub>14.0</sub><sub>dy</sub><sub>14.0</sub><sub>dz</sub><sub>0.1</sub><sub>type</sub><sub>float</sub><sub>len</sub><sub>1000000</sub><sub>width</sub><sub>1000</sub><sub>height</sub><sub>1000.dat</sub>
</p>

<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">USE_TEX</span>=true ./plotBinary <span style="color: #E6DB74; font-weight: bold;">\</span>
    --dtype float <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f out/image_sensor_0_2024-01-08T20:29:05+01:00__dx_14.0_dy_14.0_dz_0.1_type_float_len_1000000_width_1000_height_1000.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --invertY <span style="color: #E6DB74; font-weight: bold;">\</span>
    --out ~/phd/Figs/raytracing/solar_chameleon_image_0.989AU_1500mm.pdf <span style="color: #E6DB74; font-weight: bold;">\</span>
    --inPixels=false <span style="color: #E6DB74; font-weight: bold;">\</span>
    --gridpixOutfile ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;Solar chameleon image at 0.989 AU from Sun, 1500 mm&quot;</span>
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-org7f2d8e1">
<h5 id="org7f2d8e1"><span class="section-number-5">13.16.2.5.</span> Compute an expected limit   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-5">
<p>
Sanity checks:
</p>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    sanity --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/chameleon-spectrum.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --isChameleon <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes --sanityPath ~/phd/Figs/limit/sanity/chameleonSanity <span style="color: #E6DB74; font-weight: bold;">\</span>
    --chameleonLimit 
</pre>
</div>
<p>
see <a href="./Figs/limit/sanity/chameleonSanity/">./Figs/limit/sanity/chameleonSanity/</a> and the sanity log file:
</p>
<pre class="example">
[2024-01-11 - 15:50:40] - INFO: =============== Input ===============
[2024-01-11 - 15:50:40] - INFO: 	Input path: 
[2024-01-11 - 15:50:40] - INFO: 	Input files: @[(2017, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;), (2018, &quot;/home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5&quot;)]
[2024-01-11 - 15:50:41] - INFO: =============== Time ===============
[2024-01-11 - 15:50:41] - INFO: 	Total background time: 3158.01 h
[2024-01-11 - 15:50:41] - INFO: 	Total tracking time: 159.899 h
[2024-01-11 - 15:50:41] - INFO: 	Ratio of tracking to background time: 1 UnitLess
[2024-01-11 - 15:50:41] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/chameleonSanity/candidates_signal_over_background_chameleon.pdf
[2024-01-11 - 15:50:41] - INFO: =============== Chameleon coupling constant ===============
[2024-01-11 - 15:50:41] - INFO: 	Conversion probability using default β² = 4.168693834703363e+21, yields P_c↦γ = 1.06716e-14 UnitLess
[2024-01-11 - 15:50:52] - INFO: Limit with default β² = 4.168693834703363e+21 is = 1.637454027281386e+42, and as β = 3.577192e+10
[2024-01-11 - 15:50:52] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/chameleonSanity/candidates_signal_over_background_chameleon.pdf
[2024-01-11 - 15:51:03] - INFO: 2. Limit with default β² = 4.168693834703363e+21 is = 2.129378077440907e+42, and as β = 3.819999e+10
[2024-01-11 - 15:51:04] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/chameleonSanity/candidates_signal_over_background_chameleon.pdf
[2024-01-11 - 15:51:15] - INFO: 3. Limit with default β² = 4.168693834703363e+21 is = 1.890732758560203e+42, and as β = 3.708152e+10
[2024-01-11 - 15:51:15] - INFO: 	Saving plot: /home/basti/phd/Figs/limit/sanity/chameleonSanity/candidates_signal_over_background_chameleon.pdf
[2024-01-11 - 15:51:26] - INFO: 4. Limit with default β² = 4.168693834703363e+21 is = 1.391973234680927e+42, and as β = 3.434850e+10
</pre>
<p>
These limits look good! Quite a bit better than Christoph&apos;s (which was 5.5e10).
</p>

<p>
See sec. <a href="./limit.html#sec:limit:expected_limits:best_expected_50k">13.13.5</a> for the command
for axion-electron using 50k toys. The main differences:
</p>
<ul class="org-ul">
<li>chameleon differential flux</li>
<li>chameleon axion image</li>
<li>couplingKind: β<sub>m</sub></li>
</ul>
<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/chameleon-spectrum.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --isChameleon <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_β⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/org/resources/lhood_limits_chameleon_12_01_24/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 10000
</pre>
</div>
<p>
Expected limit: 3.605996073373334E10
Limit no candidates: 4.737234852038135E41 ^ 0.25 = 2.62350096896e10
</p>
</div>
</div>



<div class="outline-5" id="outline-container-org68d7c8a">
<h5 id="org68d7c8a"><span class="section-number-5">13.16.2.6.</span> Generate plot of expected limit histogram   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-6">
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/chameleon-spectrum.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --isChameleon <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_β⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --plotFile ~/org/resources/lhood_limits_chameleon_12_01_24/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_septem_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99/mc_limit_lkMCMC_skInterpBackground_nmc_10000_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLow 2e41 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xHigh 4.2e42 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yHigh 180 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --bins 100 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --linesTo 100 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --xLabel <span style="color: #E6DB74;">&quot;Limit β⁴&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --yLabel <span style="color: #E6DB74;">&quot;MC toy count&quot;</span>  <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/limit/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;_chameleon_nmc_10k_pretty&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --nmc 10000
</pre>
</div>
</div>
</div>

<div class="outline-5" id="outline-container-orgd757f8f">
<h5 id="orgd757f8f"><span class="section-number-5">13.16.2.7.</span> Compute the observed limit   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-7">
<p>
We use <code>F_WIDTH=0.5</code> for the <code>ln(1 + s/b)</code> plot. The MCMC g<sub>ae</sub>²
histogram is forced to be 0.9 in width anyway.
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #FD971F;">F_WIDTH</span>=0.5 <span style="color: #FD971F;">ESCAPE_LATEX</span>=true <span style="color: #FD971F;">USE_TEX</span>=true mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/chameleon-spectrum.dat <span style="color: #E6DB74; font-weight: bold;">\</span>
    --isChameleon <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_β⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/chameleon/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span>
</pre>
</div>

<p>
The log file:
<a href="./Figs/trackingCandidates/chameleon/real_candidates_limit.log">./Figs/trackingCandidates/chameleon/real_candidates_limit.log</a>
</p>

<pre class="example">
[2024-01-18 - 14:45:00] - INFO: Mean of 200 real limits (3·150k MCMC) = 3.103796e+10
[2024-01-18 - 14:45:00] - INFO: Median of 200 real limits (3·150k MCMC) = 3.103509e+10
[2024-01-18 - 14:45:00] - INFO: σ of 200 real limits (3·150k MCMC) = 2.299418e+08
[2024-01-18 - 14:45:00] - INFO: Combined real limit (200 times 3·150k MCMC) = 3.10380(2299)e+10
[2024-01-18 - 14:45:00] - INFO: Real limit based on 3 150k long MCMCs: β_γ = 31003855007.8231
</pre>
<p>
(that should read g<sub>aγ</sub>⁴, to be updated),
yields
\(β_γ = \num{3.10380(2299)e+10}\)
</p>
</div>
</div>

<div class="outline-5" id="outline-container-orgdd37860">
<h5 id="orgdd37860"><span class="section-number-5">13.16.2.8.</span> Generate a plot of the chameleon spectrum with the candidates   <span class="tag">  <span class="extended">extended</span></span></h5>
<div class="outline-text-5" id="text-13-16-2-8">
<div class="org-src-container">
<pre class="src src-sh">plotBackgroundClusters <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --title <span style="color: #E6DB74;">&quot;MLP@95+FADC+Scinti+Line tracking clusters&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/chameleon/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;mlp_0.95_scinti_fadc_line_tracking_candidates_chameleon_below_2keV&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 2.001 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --filterNoisyPixels <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_chameleon_image_0.989AU_1500mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyText <span style="color: #E6DB74; font-weight: bold;">\</span>
    --colorBy energy <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --useTikZ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --singlePlot
</pre>
</div>


<figure id="org7cc76ad">
<img src="./figs/home/basti/phd/Figs/trackingCandidates/chameleon/background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_chameleon_below_2keV.svg" class="org-svg" alt="background_cluster_centersmlp_0.95_scinti_fadc_line_tracking_candidates_chameleon_below_2keV.svg" />

</figure>
</div>
</div>
</div>

<div class="outline-4" id="outline-container-orgca14de1">
<h4 id="orgca14de1"><span class="section-number-4">13.16.3.</span> Further note on the difference between axion-electron and axion-photon/chameleon limits   <span class="tag">  <span class="extended">extended</span></span></h4>
<div class="outline-text-4" id="text-13-16-3">
<p>
There is a fundamental difference between computing a limit on the
axion-electron coupling and computing a limit for either axion-photon
or chameleon.
</p>

<p>
In case of axion-photon and chameleon, a change in the coupling
constant increases / decreases <b>both</b> the production and the
conversion probability by that amount, to be specific
</p>

<p>
\[
s(g⁴) = α · f(g²) · P(g²)
\]
</p>

<p>
where \(α\) is the entire contribution independent of \(g\). 
</p>

<p>
For the axion-electron coupling however, a change in \(g²_{ae}\) only
changes the production. Or, in case of working with \(g²_{ae}·g²_{aγ}\),
a fixed change of the product is &apos;dedicated&apos; only <i>partially</i> to
production and <i>partially</i> to the conversion probability.
</p>
</div>
</div>
</div>

<div class="outline-3" id="outline-container-org4cc5303">
<h3 id="org4cc5303"><span class="section-number-3">13.17.</span> Comparison to 2013 limit (using their method)   <span class="tag">  <span class="extended">extended</span></span></h3>
<div class="outline-text-3" id="text-13-17">
<p>
Some years ago I attempted to reproduce the limit calculation of the
CAST 2013 axion-electron limit paper (<a href="./bibliography.html#citeproc_bib_item_38">Barth et al. 2013</a>). Given that
their main approach is a binned likelihood approach I thought it
should be rather simple to reproduce by extracting the background
rates and candidates from the figures in the paper and implementing
the likelihood function.
</p>

<p>
I did this in
<a href="./../org/Doc/StatusAndProgress.html">./../org/Doc/StatusAndProgress.html</a> and
was not fully able to reproduce the numbers shown there. In particular
the \(χ²\) minimum was at values near \(\sim 40\) instead of \(\sim 22\).
</p>

<p>
However, at the time I was just learning about limit calculations and
I had a lot of misunderstandings, especially given the negative
coupling constants as well as generally how to compute a limit using
the \(χ²\) approach.
</p>

<p>
Still, I would like to see the numbers reproduced. At this time I do
have access to the code that was supposedly used to calculate the
numbers of that paper. I have yet to run them myself, but given the
limit calculation is so simple, reproducing the numbers should anyhow
be very easy.
</p>
</div>
</div>


<div class="outline-3" id="outline-container-orgb25e096">
<h3 id="orgb25e096"><span class="section-number-3">13.18.</span> Observed limit for different axion masses   <span class="tag">  <span class="extended">extended</span></span></h3>
<div class="outline-text-3" id="text-13-18">
</div>
<div class="outline-4" id="outline-container-sec:limit:limit_different_axion_mass:gen_data_plots">
<h4 id="sec:limit:limit_different_axion_mass:gen_data_plots"><span class="section-number-4">13.18.1.</span> Generate limits for different axion masses</h4>
<div class="outline-text-4" id="text-sec:limit:limit_different_axion_mass:gen_data_plots">
<p>
In order to compute the observed limit for the axion photon limit, we
reuse the command from
sec. <a href="./limit.html#sec:limit:axion_photon:compute_axion_photon_observed">13.16.1.6</a>, but add
the <code>--massLow/High/Steps</code> commands and adjust the output path:
</p>

<div class="org-src-container">
<pre class="src src-sh">mcmc_limit_calculation <span style="color: #E6DB74; font-weight: bold;">\</span>
    <span style="color: #F92672;">limit</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f /home/basti/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R2_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --tracking ~/org/resources/lhood_mlp_17_11_23_adam_tanh30_sigmoid_mse_82k_tracking/lhood_c18_R3_crAll_sEff_0.95_scinti_fadc_line_mlp_mlp_tanh_sigmoid_MSE_Adam_30_2checkpoint_epoch_82000_loss_0.0249_acc_0.9662_vQ_0.99.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionModel ~/phd/resources/readOpacityFile/solar_axion_flux_differential_g_ae_1e-13_g_ag_1e-12_g_aN_1e-15_fluxKind_fkAxionPhoton_0.989AU.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --axionImage ~/phd/resources/axionImages/solar_axion_image_fkAxionPhoton_0.989AU_1492.93mm.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --combinedEfficiencyFile ~/org/resources/combined_detector_efficiencies.csv <span style="color: #E6DB74; font-weight: bold;">\</span>
    --couplingKind ck_g_aγ⁴ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --switchAxes <span style="color: #E6DB74; font-weight: bold;">\</span>
    --path <span style="color: #E6DB74;">&quot;&quot;</span> <span style="color: #E6DB74; font-weight: bold;">\</span>
    --years 2017 --years 2018 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --σ_p 0.05 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --energyMin 0.2 --energyMax 12.0 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --limitKind lkMCMC <span style="color: #E6DB74; font-weight: bold;">\</span>
    --massLow 1e-4 --massHigh 2e-1 --massSteps 500 <span style="color: #E6DB74; font-weight: bold;">\</span>
    --outpath ~/phd/Figs/trackingCandidates/axionPhotonMassScan/ <span style="color: #E6DB74; font-weight: bold;">\</span>
    --suffix <span style="color: #E6DB74;">&quot;&quot;</span>
</pre>
</div>

<p>
Convert the output to a CSV file for external users:
</p>
<div class="org-src-container">
<pre class="src src-sh"><span style="color: #F92672;">cd</span> ~/CastData/ExternCode/TimepixAnalysis/Tools/exportLimitLikelihood/
./exportLimitLikelihood <span style="color: #E6DB74; font-weight: bold;">\</span>
    massScan <span style="color: #E6DB74; font-weight: bold;">\</span>
    -f ~/phd/resources/trackingCandidates/axionPhotonMassScan/mc_limit_lkMCMC_skInterpBackground_nmc_500_uncertainty_ukUncertain_σs_0.0276_σb_0.0028_posUncertain_puUncertain_σp_0.0500mass_scan.h5 <span style="color: #E6DB74; font-weight: bold;">\</span>
    -o ~/phd/resources/trackingCandidates/axionPhotonMassScan/gridpix_axion_photon_likelihood_vs_mass.csv
</pre>
</div>

<p>
With the fixes to the adjustment of the MCMC sampling range based on
the <code>integralBase</code> instead of the <code>conversionProbability</code> at a fixed
energy, the limits now <span class="timestamp-wrapper">  <span class="timestamp">&lt;2024-06-10 Mon 17:37&gt; </span></span> look good at all masses!
</p>
</div>
</div>
</div>
</div>

<div id="footnotes"><h2 class="footnotes">Footnotes: </h2><div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.1" href="#fnr.1">1</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
&apos;Toy&apos; is a common terminology for randomly sampled cases in
Monte Carlo calculations. In our case, sampling representative
candidates from the background distribution yields a set of &apos;toy candidates&apos;.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.2" href="#fnr.2">2</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
We could use \(P_i(k_i; λ_i = s_i + b_i)\), but among
other things a ratio is numerically more stable.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.3" href="#fnr.3">3</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
This equation essentially computes the confidence level at
\(\text{CL} = \SI{95}{\%} \equiv 0.95 = 1 - 0.05 = 1 - α\). In the
equation we already removed the prior and therefore adjusted the
integration range.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.4" href="#fnr.4">4</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
If one considers a position independent likelihood
function, there is no need to sample positions of course.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.5" href="#fnr.5">5</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
For different likelihood functions other
parameters may be affected.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.6" href="#fnr.6">6</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
The code was mainly developed by Johanna
von Oy under my supervision. I only contributed minor feature additions
and refactoring, as well as performance related improvements.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.7" href="#fnr.7">7</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Note that to calculate limits for larger axion masses
the \(\sinc\) term of
eq. \eqref{eq:theory:axion_interaction:conversion_probability} needs to be included.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.8" href="#fnr.8">8</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Also note that in a perfect analysis one would
compute the conversion in a realistic magnetic field, as the field
strength is not perfectly homogeneous. That would require a very
precise field map of the magnet. In addition, the calculations for
axion conversions in inhomogeneous magnetic fields is significantly
more complicated. As far as I understand it requires essentially a
&quot;path integral like&quot; approach of all possible paths through the
magnet, where each path sees different, varying field strengths. Due
to the small size of the LHC dipole prototype magnet and general
stringent requirements for homogeneity this is not done for this
analysis. However, likely for future (Baby)IAXO analyses this will be
necessary.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.9" href="#fnr.9">9</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Note that \(ε_{\text{tel}}\) here is the average effective
efficiency of the full telescope and <i>not</i> the reflectivity of a
single shell. As a Wolter I optic requires two reflections
\(ε_{\text{tel}}\) is equivalent to the reflectivity squared
\(R²\). Individual reflectivities of shells are further complicated by
the fact that different shells receive parallel light under different
angles, which means the reflectivity varies between shells. Therefore,
this is a measure for the average efficiency.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.10" href="#fnr.10">10</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
To my knowledge there exists no technical design
documentation about how the beamline was designed exactly. Jaime Ruz,
who was in charge of the LLNL telescope installation, told me this is
what he aligned to.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.11" href="#fnr.11">11</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
A big reason for this approach is that so far I have not
been able to reproduce the reflectivity (and thus effective area) of
the telescope to a sufficient degree. A pure raytracing approach would
overestimate the amount of flux currently. 
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.12" href="#fnr.12">12</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
I did not put them into the general appendix,
because mostly they are small to medium large pieces of code, which
simply run the relevant calculation with slightly different parameters
and in the end computes the ratio of the result to the unchanged
parameter result.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.13" href="#fnr.13">13</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Do not confuse \(g_{\text{base}}\) with the reference
coupling constant for which the axion flux is computed
\(g_{\text{ref}}\) mentioned earlier.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.14" href="#fnr.14">14</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
The actual data unblinding of the candidates
presented in this section was only done after the analysis of the
previous sections was fully complete. A presentation with discussion
took place first inside our own group and later with the relevant
members of the CAST collaboration to ascertain that our analysis
appears sound.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.15" href="#fnr.15">15</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
The background model contains \(\num{16630}\)
clusters in this case. \(\SI{3156.8}{h}\) of background data and
\(\SI{160.375}{h}\) of tracking data yields
\(\num{16630}·\frac{160.375}{3156.8} \approx 845\) clusters.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.16" href="#fnr.16">16</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Judging by the \(χ²\) distribution in
(<a href="#citeproc_bib_item_38">Barth et al. 2013</a>), fig. 6, having a minimum for negative \(g²_{ae}g²_{gγ}\)
values, potentially implies a better observed limit than expected. 
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.17" href="#fnr.17">17</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Note though, while the
calculation of the observed limit via the MCMC takes about
\(\SI{10}{s}\), the numerical integration using Romberg&apos;s method takes
\(\sim\SI{1}{h}\) for only 20 points. And that is only using an
integration level of 5 (a parameter of the Romberg method, one often
uses 8 for Romberg for accuracy). This highlights the need for Monte
Carlo methods, <span class="underline">especially</span> for expected limits.
</p></div></div>

<div class="footdef"><sup>  <a role="doc-backlink" class="footnum" id="fn.18" href="#fnr.18">18</a></sup> <div role="doc-footnote" class="footpara">  <p class="footpara">
Including the conversion probability from the
raytracer would ideally mean to include the reflectivities under
angles encountered for each ray. However, attempts to reproduce the
effective area as provided by LLNL raytracing simulations have failed
so far. In order to avoid complications with potential inaccuracies,
we stick to the previous approach for simplicity and better comparison.
</p></div></div>

</div>
<div class="hint-message">Click on any heading marked '<span class="extended">extended</span>' to open it</div>
</div>
</body>
</html>
